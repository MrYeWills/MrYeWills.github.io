<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>前端缓存笔记</title>
      <link href="/2019/06/17/font_end/"/>
      <url>/2019/06/17/font_end/</url>
      
        <content type="html"><![CDATA[<h2 id="缓存1"><a href="#缓存1" class="headerlink" title="缓存1"></a>缓存1</h2><h3 id="cookie-与-http"><a href="#cookie-与-http" class="headerlink" title="cookie 与 http"></a>cookie 与 http</h3><p>cookie是后台传给前台，前台再利用浏览器的cookie可以随http发回给后台的特性，对发回对cookie进行验证。</p><ul><li>第一次向后台发起请求后，后台返回的响应头（response headers）包含了给浏览器设置cookie对功能（set-cookie）<figure class="image-box">                <img src="/image/font_end/cookie.jpg" alt="" title="" class="">                <p></p>            </figure></li><li>浏览器拿到cookie后，cookie有个特性，同域名下的cookie在发起请求时，都会发回给后台</li><li>后台通过比对session的cookie，进行超时、登陆等校验</li></ul><p>补充一点cookie知识：<br>如下图 Expires／max-age 的值为 N／A是session永久有效的意思，另外一个每个cookie对应一个域名。<br><figure class="image-box">                <img src="/image/font_end/cookie1.jpg" alt="" title="" class="">                <p></p>            </figure></p>]]></content>
      
      
      <categories>
          
          <category> 前端缓存笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端缓存笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git笔记</title>
      <link href="/2019/05/23/git/"/>
      <url>/2019/05/23/git/</url>
      
        <content type="html"><![CDATA[<p>一直在用git，也想总结一点git笔记，因此就有了本篇。</p><h3 id="git图形化工具误你一生"><a href="#git图形化工具误你一生" class="headerlink" title="git图形化工具误你一生"></a>git图形化工具误你一生</h3><p>使用git图形化工具是使用git的错误开始，使用图形化越深，错的越深。<br>珍爱git，及早丢弃图形化。</p><h3 id="git-init-与-git-remote"><a href="#git-init-与-git-remote" class="headerlink" title="git init 与 git remote"></a>git init 与 git remote</h3><p>本地一个文件夹，里面有很多文件，你想从现在开始，对此文件进行版本管理，执行git init即可；<br>git init后，就可以尽情地对此项目各种版本管理操作；<br>有一天你想对这个git init项目上传到github上，<br>在命令窗口执行 git remote，cmd窗口会提示你如何上传到GitHub服务器上。</p><h3 id="看cmd窗口提示很关键"><a href="#看cmd窗口提示很关键" class="headerlink" title="看cmd窗口提示很关键"></a>看cmd窗口提示很关键</h3><p>上面说到了执行git remote cmd窗口会有提示，按照提示，就可以完成想做的事情。<br>git 提供了强大的提示功能，要重视cmd窗口提示信息，很关键。<br>git bash 粘贴复制很好用</p><h3 id="使用git-bash，放弃cmd"><a href="#使用git-bash，放弃cmd" class="headerlink" title="使用git bash，放弃cmd"></a>使用git bash，放弃cmd</h3><p>git bash才是最适合用来管理git的命令窗口，比如 git bash 能时刻显示当前你所处的分支名，能完整保留git的操作，因为cmd超过一定操作会删除以前的操作日志。</p><h3 id="git-fetch-git-pull-切远程分支"><a href="#git-fetch-git-pull-切远程分支" class="headerlink" title="git fetch\git pull\切远程分支"></a>git fetch\git pull\切远程分支</h3><p>git fetch 将远程分支更新到本地，但不与本地分支合并，下载到本地的分支的名字前面都有origin/,例如origin/master.<br>git pull 是git fetch与git merge origin/branch 的两步。</p><h4 id="拉取新项目时，如何切换到项目的其他分支"><a href="#拉取新项目时，如何切换到项目的其他分支" class="headerlink" title="拉取新项目时，如何切换到项目的其他分支"></a>拉取新项目时，如何切换到项目的其他分支</h4><p>执行 git fetch后，git checkout即可</p><h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><p>git checkout . 清除所有<br>git checkout string  ，此string可以是分支名，也可是commitHash</p><h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><h4 id="PR冲突时，处理冲突"><a href="#PR冲突时，处理冲突" class="headerlink" title="PR冲突时，处理冲突"></a>PR冲突时，处理冲突</h4><p>多人开发，在提PR给develop分支时，当github页面提示有冲突时,处理如下：<br>切到自己的分支(PR到develop的分支)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git rebase develop</span><br><span class="line">//这时会显示冲突内容，解决冲突，执行</span><br><span class="line">git add .</span><br><span class="line">git rebase --continue</span><br><span class="line">git push origin -f</span><br></pre></td></tr></table></figure></p><p>然后重新PR,这时就不报错了<br>有人将上一操作过程称为变基。<br>git rebase 功能类似 git merge，区别在于，git merge时，你的commit 是按先后顺序排列的，merge完成后可能一眼看不到自己的提交。<br>git rebase则不同，git rebase后，你与develop不同的提交(也就是你修改的)commit将显示在第一条，(注意的是，git rebase冲突修改将不会生成commit，从上面只有git add,没有git commit得到佐证，因为只有git commit 才会生成一条commit):<br><figure class="image-box">                <img src="/image/git/git3.png" alt="" title="" class="">                <p></p>            </figure></p><p>以上过程是把git rebase 当git merge来用，git rebase的这种当merge的用法，用的不多，用得最多的就是上面展示的，用来处理PR后的冲突。</p><h4 id="将最新修改合并过来，且保证提交的连续性"><a href="#将最新修改合并过来，且保证提交的连续性" class="headerlink" title="将最新修改合并过来，且保证提交的连续性"></a>将最新修改合并过来，且保证提交的连续性</h4><p>比如，你在做用户管理功能，同事在做登录功能；<br>你的用户管理的页面效果写好了，要做接口联调，需要用到同事做的登录功能的用户参数；<br>注意，<br>你可以直接merge 同事的代码过来，但弊端是，你自己做的用户管理提交可能无法显示在git log的最前面；<br>在此推荐用rebase 同事的代码，好处是，既将同事的修改merge过来，又可以将自己的修改显示最上方，保证当前业务功能的commit的连续性和直观性。</p><h4 id="rebase-与-merge"><a href="#rebase-与-merge" class="headerlink" title="rebase 与 merge"></a>rebase 与 merge</h4><p>如上所说，rebase有这么多好处，merge能做到的，rebase都能做到，为什么不都用rebase呢？<br>因为merge是无害的，不改变commithash值；<br>而rebase有改变commithash值的风险，这就意味着你做分支的合并时就会出现冲突，如果你有一群小伙伴一起开发，那么这个冲突起来，会让你hold不住，然而这并不妨碍你对rebase的热爱。</p><p>因此鉴于merge的无害性，一般情况下分支合并就使用merge；<br>在特定场景下才使用rebase；</p><h4 id="合并commit"><a href="#合并commit" class="headerlink" title="合并commit"></a>合并commit</h4><p>这是日常开发必备用法，不会此法，不能说会使用git</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//正常使用</span><br><span class="line">git rebase -i HEAD~6</span><br><span class="line">按字母i键，进入insert模式(编辑模式)</span><br><span class="line">留一个最上面的pick，</span><br><span class="line">后面的pick全部换成s；</span><br><span class="line">修改好后，按esc键(退出编辑模式)</span><br><span class="line">:wq //保存编辑修改，vim命令</span><br><span class="line">:q! //不保存编辑修改，vim命令</span><br></pre></td></tr></table></figure><p>如果遇到冲突，除了以上命令，按提示操作，还会执行以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//注意的是，执行完git add . 后，不必执行git commit</span><br><span class="line">git add .</span><br><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure></p><p>放弃rebase<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --abort</span><br></pre></td></tr></table></figure></p><p>注意的是以下两种方法都支持，两种方法各有优点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~6</span><br><span class="line">git rebase -i c9r26r869b8  //c9r26r869b8 此hash值不被合并，此hash以前的所有commit将被合并</span><br></pre></td></tr></table></figure></p><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><h4 id="将分支回滚到指定历史版本"><a href="#将分支回滚到指定历史版本" class="headerlink" title="将分支回滚到指定历史版本"></a>将分支回滚到指定历史版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// --hard 是强制的意思</span><br><span class="line">git reset --hard commitHash</span><br></pre></td></tr></table></figure><h4 id="放弃所有修改，回到干净的当前仓库版本"><a href="#放弃所有修改，回到干净的当前仓库版本" class="headerlink" title="放弃所有修改，回到干净的当前仓库版本"></a>放弃所有修改，回到干净的当前仓库版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD</span><br></pre></td></tr></table></figure><h4 id="git-reset-HEAD"><a href="#git-reset-HEAD" class="headerlink" title="git reset HEAD~"></a>git reset HEAD~</h4><p>这个方法非常好用，本意是重新修改上一次提交。<br>执行这个命令后，将上一次提交的所有文件将至于 not staged 状态,<br>然后，你可很直观看到这次提交修改的所有文件，<br>并且vscode对于not staged状态的文件，会将他们集中显示到源代码管理窗口，<br>这对于git rebase 很多commit后，然后再次整理或格式化所有的修改内容 是很棒的功能。</p><h4 id="回到指定提交后，并重新修改这一次提交内容"><a href="#回到指定提交后，并重新修改这一次提交内容" class="headerlink" title="回到指定提交后，并重新修改这一次提交内容"></a>回到指定提交后，并重新修改这一次提交内容</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard commitHash</span><br><span class="line">//~ 指的是上一次的意思</span><br><span class="line">git reset HEAD~</span><br></pre></td></tr></table></figure><h4 id="再次对前几次commit修改的内容修改"><a href="#再次对前几次commit修改的内容修改" class="headerlink" title="再次对前几次commit修改的内容修改"></a>再次对前几次commit修改的内容修改</h4><p>我们做一个面包屑菜单功能，可能做了很多次提交，现在想对这么多次的提交所修改的所有内容，重新审阅一遍，以便修改内容或者格式化，解决方案如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~6</span><br><span class="line">git reset HEAD~</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;面包屑功能&quot;</span><br></pre></td></tr></table></figure></p><p>参考《git reset HEAD~》</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>git reset后，要push时，都需加上-f，强制push</p><h3 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h3><p>如果你使用git reset,那么git log无法查到当前提交之后的提交日志，此时使用 git reflog</p><h3 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h3><p>不懂git cherry-pick，说明你还不懂git这位美女的基本套路，必备git操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick commitHash</span><br></pre></td></tr></table></figure></p><p>git cherry-pick 与 git reset 配合使用可以尽情任意穿插回滚修改版本提交，只有此时，你才懂git的美，从此爱不释手，相逢恨晚。</p><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -D branch //删除本地分支</span><br><span class="line">git branch -a // 查看远程有多少分支</span><br></pre></td></tr></table></figure><h3 id="git-push-删除远程分支"><a href="#git-push-删除远程分支" class="headerlink" title="git push 删除远程分支"></a>git push 删除远程分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin -d branch</span><br></pre></td></tr></table></figure><h3 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h3><p>命令简单，Google下命令即可，git tag很重要也很好用，<br>tag的好处有，它既像一个branch，保存了当次tag的所有提交，又提供了一个zip包，<br>很多开源框架的 历史版本API 都是通过tag完成，非常之好用</p><h3 id="gitk"><a href="#gitk" class="headerlink" title="gitk"></a>gitk</h3><p>非常好用的查看工具，git自带，此工具太好用，是查历史，凭关键字查提交的一把好手，太重要，用得太频繁，你必需会，<br>启动方法：<br>git bash中执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitk</span><br></pre></td></tr></table></figure></p><p>比较好的gitk命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//查询abc.js文件的历史修改记录，比任何插件显示的全</span><br><span class="line">gitk -- **/ abc.js</span><br></pre></td></tr></table></figure></p><h3 id="工作目录、index、HEAD、object、快照"><a href="#工作目录、index、HEAD、object、快照" class="headerlink" title="工作目录、index、HEAD、object、快照"></a>工作目录、index、HEAD、object、快照</h3><p>工作目录、index（暂存区）、HEAD（当前所处commit）、object（文件树）。<br>快照：可以理解为版本每次提交后，git会给提交拍照，用来记录版本信息。<br>尤其 工作目录、index、HEAD 这三个概念是git的三驾马车，就好比 action、reducer、selector 是react-redux的三驾马车一样。<br>要多刷视频和书籍《精通git》了解这仨，了解git一切只是什么指针或快照，虽然我现在也忘得差不多，但一定要了解。<br><figure class="image-box">                <img src="/image/git/git1.png" alt="" title="" class="">                <p></p>            </figure><br>工作目录，index（暂存区）、HEAD（master分支）、objexts（树）。<br>index与HEAD都是通过指针指向文件树objects；</p><h3 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br><span class="line">git stash apply</span><br><span class="line">git checkout -b branch</span><br><span class="line">git log -n</span><br><span class="line">git commit -amend</span><br><span class="line">git help stash //使用help方式一</span><br><span class="line">git stash --help //使用help方式二</span><br><span class="line">git diff</span><br></pre></td></tr></table></figure><h3 id="git-技巧"><a href="#git-技巧" class="headerlink" title="git 技巧"></a>git 技巧</h3><h4 id="空格使用"><a href="#空格使用" class="headerlink" title="空格使用"></a>空格使用</h4><p>清除多个或merge多个 可使用空格，一次搞定，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout file1.js file2.js</span><br><span class="line">git merge branch1 branch2</span><br></pre></td></tr></table></figure></p><h4 id="–abort"><a href="#–abort" class="headerlink" title="–abort"></a>–abort</h4><p>–abort一般是放弃的意思，如<br>放弃merge<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --abort</span><br></pre></td></tr></table></figure></p><h4 id="–contnue"><a href="#–contnue" class="headerlink" title="–contnue"></a>–contnue</h4><p>–abort一般是放弃的意思，如<br>放弃merge<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --contnue</span><br></pre></td></tr></table></figure></p><h4 id="字母q"><a href="#字母q" class="headerlink" title="字母q"></a>字母q</h4><p>在git log命令出来一堆历史时，按回车或其他键，只会显示更多历史，按字母q可退出。</p><h4 id="i"><a href="#i" class="headerlink" title="-i"></a>-i</h4><p>-i表示交互的意思。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~6</span><br></pre></td></tr></table></figure></p><h4 id="双点号，三点号的特殊意义"><a href="#双点号，三点号的特殊意义" class="headerlink" title="双点号，三点号的特殊意义"></a>双点号，三点号的特殊意义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -p master..origin/master 查看二者区别</span><br></pre></td></tr></table></figure><h4 id="gitk查看历史最可靠"><a href="#gitk查看历史最可靠" class="headerlink" title="gitk查看历史最可靠"></a>gitk查看历史最可靠</h4><p>vscode的一些插件(如 Git History)，可以很好地查看历史，不过也会有一些历史被漏掉，如对于一些git rebase -i的历史或者处理冲突的历史 有可能被漏掉不被显示，此时请使用gitk查历史，gitk最可靠，会显示所以提交，巨细无遗。</p><h4 id="多程序同时操作一个文件引起的报错"><a href="#多程序同时操作一个文件引起的报错" class="headerlink" title="多程序同时操作一个文件引起的报错"></a>多程序同时操作一个文件引起的报错</h4><p>执行复杂操作时，报 permission错误，可能是由于其他程序和git同时操作一个文件引起的，<br>此时，可以停止npm start或关闭编辑器，只让git一个程序操作项目，解决此问题。</p><h4 id="merge-commitHash"><a href="#merge-commitHash" class="headerlink" title="merge commitHash"></a>merge commitHash</h4><p>git merge branch，也可以git merge commitHash；<br>同理估计也可以git rebase commitHash</p><h4 id="vim命令"><a href="#vim命令" class="headerlink" title="vim命令"></a>vim命令</h4><p>需要懂那么点vim 操作知识，如:wq :q! 参考 《git rebase》</p><h4 id="手动处理冲突"><a href="#手动处理冲突" class="headerlink" title="手动处理冲突"></a>手动处理冲突</h4><p>手动处理冲突其实很简单，而且又做到不依赖插件。</p><h4 id="ssh可能并没有你想象重要"><a href="#ssh可能并没有你想象重要" class="headerlink" title="ssh可能并没有你想象重要"></a>ssh可能并没有你想象重要</h4><p>由于公司原因一直也没设置ssh，各种push什么的，也很少需要输入用户密码，不影响工作，也许ssh没有你现象的高大上。</p><h3 id="推荐使用vscode"><a href="#推荐使用vscode" class="headerlink" title="推荐使用vscode"></a>推荐使用vscode</h3><p>vscode内置了对git的支持，对git支持太友好，vscode自带的显示git版本变化的功能很好用，<br>配合vscode的一些git插件，能够很好的显示每行代码的历史记录，是甩锅，找坑的必备良器。</p><h3 id="不会用GitHub就是耍流氓"><a href="#不会用GitHub就是耍流氓" class="headerlink" title="不会用GitHub就是耍流氓"></a>不会用GitHub就是耍流氓</h3><p>用git，不会使用GitHub的基本操作，就是耍流氓，既然你跟git感情这么好，干嘛不更好一点，娶了她呢，这不是耍流氓吗。<br>主要要熟练 github的git workflow (也就是PR代码审核) 和 fork功能，以及看tag。<br>理解 git workflow的最核心的两大目的:PR代码审核 以及 维护一套测试、稳定和发布分支。<br><figure class="image-box">                <img src="/image/git/git2.png" alt="" title="" class="">                <p></p>            </figure></p><h3 id="git入门阶段不需知道的"><a href="#git入门阶段不需知道的" class="headerlink" title="git入门阶段不需知道的"></a>git入门阶段不需知道的</h3><h4 id="git-rebase-i-HEAD后记得合并到test-branch"><a href="#git-rebase-i-HEAD后记得合并到test-branch" class="headerlink" title="git rebase -i HEAD后记得合并到test branch"></a>git rebase -i HEAD后记得合并到test branch</h4><p>分支PR到develop后，如果在PR前做了合并历史(git rebase -i HEAD)，如果test branch基于develop创建，记得将自己被PR的分支 merge一次到test branch，由于test branch 滞后于develop branch，防止 从develop新建的branch merge到test branch时冲突，</p><h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><h4 id="unable-to-access-Could-not-resolve-host-github-com"><a href="#unable-to-access-Could-not-resolve-host-github-com" class="headerlink" title="unable to access ..Could not resolve host: github.com"></a>unable to access ..Could not resolve host: github.com</h4><p>之前git push还是好好的，用着用着就 git push 异常，并报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal: unable to access &apos;https://github.com/YeWills/YeWills.github.io.git/&apos;: Could not resolve host: github.com</span><br></pre></td></tr></table></figure><p>不过令人费解的是，<strong>试github其他仓库，不用科学上网，可以push成功的。</strong></p><p>终极解决方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># step1. ping github.com </span><br><span class="line">获取到github.com的ip为192.30.252.128 </span><br><span class="line"># step2. 在/etc/hosts中添加一行如下: </span><br><span class="line">sudo  vim /etc/hosts</span><br><span class="line">192.30.252.128 github.com</span><br></pre></td></tr></table></figure></p><p><a href="https://blog.csdn.net/piaotiejun/article/details/48734175" target="_blank" rel="noopener">参考</a><br>一般情况，上面即可解决，如果解决不了，考虑下面方法：</p><p>造成以上原因，有可能为以下几点：<br>网络被墙了？<br>使用了强制push –force （普通push是可以的）</p><p>亲测以下几种方式偶尔可以解决：</p><ul><li>科学上网，然后push，此方法有时有效，有时也无效；</li><li>重设账号密码：<br>（1）先重新设置本机git配置：git config –global credential.helper store （这一步可以不用）<br>（2）输入github账号和密码 （这一步可以不用）<br>（3）最后push代码：git push -u origin master （这一步必须，如果是强制push，加上 -f）</li></ul><p><a href="https://blog.csdn.net/mhs624014469/article/details/77124540?utm_source=blogxgwz3" target="_blank" rel="noopener">这里还有另外几种解决方式</a></p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>wills-react-pro项目笔记</title>
      <link href="/2019/05/23/wills_react_pro/"/>
      <url>/2019/05/23/wills_react_pro/</url>
      
        <content type="html"><![CDATA[<p>本篇博客针对 github 的<a href="https://github.com/YeWills/react-redux-demo" target="_blank" rel="noopener">react_redux_demo项目</a>一些知识点讲解。</p><h2 id="redux-thunk"><a href="#redux-thunk" class="headerlink" title="redux-thunk"></a>redux-thunk</h2><p>项目使用了redux-thunk来处理异步请求，redux-thunk最重要的思想，就是可以接受一个返回函数的action creator。如果这个action creator 返回的是一个函数，就执行它，如果不是，就按照原来的next(action)执行。<br>正因为这个action creator可以返回一个函数，那么就可以在这个函数中执行一些异步的操作。<br><a href="https://www.jianshu.com/p/a27ab19d3657" target="_blank" rel="noopener">参考</a><br>详细示例可参考 项目的tag login_pro_v1.0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//src/views/login/index.js</span><br><span class="line">const mapDispatchToProps = &#123;</span><br><span class="line">  loginUser: appAction.loginUser,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="ajax封装"><a href="#ajax封装" class="headerlink" title="ajax封装"></a>ajax封装</h2><h3 id="什么时候需要success提示"><a href="#什么时候需要success提示" class="headerlink" title="什么时候需要success提示"></a>什么时候需要success提示</h3><p>ajax分为两种：<br>一种是进入页面请求数据渲染页面的，此时不需要提示接口响应成功，只需loading即可。<br>一种是与后台交互，需要响应结果的，如交易、删除、编辑等，提交到后台，后台告知是否成功。<br>因此在做ajax封装时，可以不用配置success 的提示处理，需要提示的接口自行配置success提示处理。</p><h3 id="什么时候需要loading"><a href="#什么时候需要loading" class="headerlink" title="什么时候需要loading"></a>什么时候需要loading</h3><p>原则上每个请求都应该有loading，但是有很多组件有自己的loading样式，例如在非刷新整个页面的情况下，组件内刷新gird，只需在grid内显示loading，不需要统一的loading格式。<br>因此ajax封装时，配置可选的 loading标识是否loading。</p><h3 id="什么时候需要error提示"><a href="#什么时候需要error提示" class="headerlink" title="什么时候需要error提示"></a>什么时候需要error提示</h3><p>ajax封装需要封装请求异常处理并提示，统一的异常处理和提示应该放在最后，为了不同接口个性化errorhandle，配置errorhandle，优先级高于统一处理模式。</p><h3 id="断网时、请求超时的的error提示"><a href="#断网时、请求超时的的error提示" class="headerlink" title="断网时、请求超时的的error提示"></a>断网时、请求超时的的error提示</h3><p>断网和请求响应超时时，应该统一处理，并优先级最高。</p><h3 id="使用options"><a href="#使用options" class="headerlink" title="使用options"></a>使用options</h3><p>loading，errorhandle等等，有很多参数，使用一个对象参数options。</p><h3 id="ajax设计"><a href="#ajax设计" class="headerlink" title="ajax设计"></a>ajax设计</h3><p>项目通过两方面来封装 ajax：</p><ul><li>通过api.js 封装三个常用的ajax方法 post、get、delete，在此js上，主要封装axios相关。</li><li>通过createAsyncAction.js 抽象出 公共的请求的成功和异常处理。<br>这样的设计好处在于<br>可以将axios与 回调处理的代码分离管理，减少耦合性。<br>详细示例可参考 项目的tag login_pro_v1.0<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//src/views/login/index.js</span><br><span class="line">const mapDispatchToProps = &#123;</span><br><span class="line">  loginUser: appAction.loginUser,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="ajax过程的三次dispatch"><a href="#ajax过程的三次dispatch" class="headerlink" title="ajax过程的三次dispatch"></a>ajax过程的三次dispatch</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dispatch(&#123;</span><br><span class="line">    meta,</span><br><span class="line">    type: `$&#123;name&#125;_REQUEST`,</span><br><span class="line">  &#125;);</span><br><span class="line">dispatch(&#123;</span><br><span class="line">  meta,</span><br><span class="line">  type: `$&#123;name&#125;_SUCCESS`,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch(&#123;</span><br><span class="line">  meta,</span><br><span class="line">  type: `$&#123;name&#125;_ERROR`,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这三次dispatch可以用作如loading的控制等等。</p><h2 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a>eslint</h2><h3 id="禁用规则"><a href="#禁用规则" class="headerlink" title="禁用规则"></a>禁用规则</h3><p>基本上所有的规则都可以通过设置 值为 0的数组来禁用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;no-unused-expressions&quot;: [0]</span><br></pre></td></tr></table></figure></p><h2 id="jest"><a href="#jest" class="headerlink" title="jest"></a>jest</h2><h3 id="mock的用法"><a href="#mock的用法" class="headerlink" title="mock的用法"></a>mock的用法</h3><p>示例见 <a href="https://github.com/YeWills/wills-react-pro" target="_blank" rel="noopener">wills-react-pro 的 Login.test.js</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const mockPost = jest.fn(testPost(&#123; success: false &#125;));</span><br></pre></td></tr></table></figure></p><h2 id="enzyme"><a href="#enzyme" class="headerlink" title="enzyme"></a>enzyme</h2><h3 id="shallow的两种情况"><a href="#shallow的两种情况" class="headerlink" title="shallow的两种情况"></a>shallow的两种情况</h3><p>shallow一个组件时，和shallow组件内一个返回div的函数用法稍微有区别，<br>前者需要通过’&lt;&gt;‘括号起来，后者不需要。<br>示例见 <a href="https://github.com/YeWills/wills-react-pro" target="_blank" rel="noopener">wills-react-pro 的 Login.test.js</a></p><h4 id="shallow一个组件"><a href="#shallow一个组件" class="headerlink" title="shallow一个组件"></a>shallow一个组件</h4><p>这种情况最通用，不多说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shallow(&lt;Login /&gt;);</span><br></pre></td></tr></table></figure></p><h4 id="shallow组件内的函数返回的div"><a href="#shallow组件内的函数返回的div" class="headerlink" title="shallow组件内的函数返回的div"></a>shallow组件内的函数返回的div</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">renderErrorMsg = () =&gt; &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div className=&#123;`$&#123;prefixCls&#125;-errorMsg`&#125;&gt;</span><br><span class="line">          &#123;errorMsg&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  //测试代码如下：</span><br><span class="line">  const ErrorComponent = warpInstance.renderErrorMsg();</span><br><span class="line">  const errorWrap = shallow(ErrorComponent);</span><br><span class="line">  expect(errorWrap.exists(&apos;.view-login-errorMsg&apos;)).toBeTruthy();</span><br></pre></td></tr></table></figure><h2 id="connected-react-router-与-history"><a href="#connected-react-router-与-history" class="headerlink" title="connected-react-router 与 history"></a>connected-react-router 与 history</h2><p>这是一种固定写法，不用过多关注：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//参考 项目的tag login_pro_v1.0</span><br><span class="line">//src/app/init/createStore.js</span><br><span class="line">import &#123; connectRouter, routerMiddleware &#125; from &apos;connected-react-router&apos;;</span><br><span class="line"></span><br><span class="line">connectRouter(history)(combineReducers(reducers)),</span><br></pre></td></tr></table></figure></p><h2 id="路由设计"><a href="#路由设计" class="headerlink" title="路由设计"></a>路由设计</h2><h3 id="ConnectedRouter配置"><a href="#ConnectedRouter配置" class="headerlink" title="ConnectedRouter配置"></a>ConnectedRouter配置</h3><p>ConnectedRouter类似BrowserRouter。MultiIntlProvider可以不用管就是一个高阶组件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;ConnectedRouter history=&#123;history&#125;&gt;</span><br><span class="line">    &lt;MultiIntlProvider defaultLocale=&#123;locale&#125; messageMap=&#123;messages&#125; &gt;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">            &lt;Route key=&#123;path&#125; path=&quot;/dashboard/analysis/realtime&quot; component=&#123;Page&#125; /&gt;</span><br><span class="line">        &lt;/Switch&gt;</span><br><span class="line">    &lt;/MultiIntlProvider&gt;</span><br><span class="line"> &lt;/ConnectedRouter&gt;</span><br></pre></td></tr></table></figure><h3 id="使用BrowserRouter"><a href="#使用BrowserRouter" class="headerlink" title="使用BrowserRouter"></a>使用BrowserRouter</h3><p>项目的具体布局主要看 src/src-acl-router/AclRouter.jsx;<br>本项目应该用的是BrowserRouter，而非HashRouter，因为页面的路由都没有#。<br>整理出来如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;BrowserRouter history=&#123;history&#125;&gt;</span><br><span class="line">    &lt;Switch&gt;</span><br><span class="line">      &lt;Route</span><br><span class="line">        path=&quot;/&quot;</span><br><span class="line">        render=&#123;() =&gt; &lt;Redirect to=&quot;/outlets&quot; /&gt;&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;Route</span><br><span class="line">        path=&quot;/login&quot;</span><br><span class="line">        render=&#123;props =&gt; (</span><br><span class="line">          &lt;NormalLayout &#123;...props&#125;&gt;</span><br><span class="line">            &lt;RouteComponent &#123;...props&#125; /&gt;</span><br><span class="line">          &lt;/NormalLayout&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;Route</span><br><span class="line">        path=&quot;/outlets&quot;</span><br><span class="line">        render=&#123;props =&gt; (</span><br><span class="line">          &lt;BasicLayout &#123;...props&#125;&gt;</span><br><span class="line">            &lt;RouteComponent &#123;...props&#125; /&gt;</span><br><span class="line">          &lt;/BasicLayout&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;Route</span><br><span class="line">        path=&quot;/exception/403&quot;</span><br><span class="line">        render=&#123;props =&gt; (</span><br><span class="line">          &lt;BasicLayout &#123;...props&#125;&gt;</span><br><span class="line">            &lt;Unauthorized &#123;...props&#125; /&gt;</span><br><span class="line">          &lt;/BasicLayout&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;Route</span><br><span class="line">        render=&#123;props =&gt; (</span><br><span class="line">          &lt;NotFound &#123;...props&#125; /&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/Switch&gt;</span><br><span class="line"> &lt;/BrowserRouter&gt;</span><br></pre></td></tr></table></figure></p><h3 id="页面权限管理"><a href="#页面权限管理" class="headerlink" title="页面权限管理"></a>页面权限管理</h3><p>通过 permissions 配置，通过比对 登陆后 个人的权限user.authorities 与 页面的 permissions，来重组拼合 上面的 《使用BrowserRouter》：<br><strong>本项目在登陆后会重新重组渲染上面的 《使用BrowserRouter》</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &apos;/dashboard/analysis/offline&apos;,</span><br><span class="line">  exact: true,</span><br><span class="line">  permissions: [&apos;admin&apos;, &apos;user&apos;],</span><br><span class="line">  redirect: &apos;/login&apos;,</span><br><span class="line">  component: W11orkInProgress,</span><br><span class="line">  pageTitle: &apos;&apos;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>场景一：当用户对某个页面没有权限时，AclRouter会将此页面 重定向到403页面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route</span><br><span class="line">        path=&quot;/outlets&quot;</span><br><span class="line">        render=&#123;() =&gt; &lt;Redirect to=&quot;/exception/403&quot; /&gt;&#125;</span><br><span class="line">      /&gt;</span><br></pre></td></tr></table></figure></p><h3 id="NotFound"><a href="#NotFound" class="headerlink" title="NotFound"></a>NotFound</h3><p>在《使用BrowserRouter》中的NotFound页面的路由设计挺好，此路由没有配置path，当上面的路由都未匹配时，就顺延到NotFound页面。</p><h3 id="路由配置项介绍"><a href="#路由配置项介绍" class="headerlink" title="路由配置项介绍"></a>路由配置项介绍</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &apos;/outlets&apos;,</span><br><span class="line">  exact: true,</span><br><span class="line">  //权限</span><br><span class="line">  permissions: [&apos;admin&apos;, &apos;user&apos;],</span><br><span class="line">  //当有权限时，一切正常时显示Outlets</span><br><span class="line">  component: Outlets,</span><br><span class="line">  //当没有权限时，换成显示Unauthorized</span><br><span class="line">  unauthorized: Unauthorized,</span><br><span class="line">  pageTitle: &apos;pageTitle_outlets&apos;,</span><br><span class="line">  //面包屑</span><br><span class="line">  breadcrumb: [&apos;/outlets&apos;],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AclRouter"><a href="#AclRouter" class="headerlink" title="AclRouter"></a>AclRouter</h3><p>所有路由重组，全部在 AclRouter.js.<br>这个js亮点在于，在登陆前与登陆后，改变 mapStateToProps 中的 user props值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const Router = (&#123; history, user &#125;) =&gt; (</span><br><span class="line">  &lt;ConnectedRouter history=&#123;history&#125;&gt;</span><br><span class="line">    &lt;MultiIntlProvider</span><br><span class="line">      defaultLocale=&#123;locale&#125;</span><br><span class="line">      messageMap=&#123;messages&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;AclRouter</span><br><span class="line">        authorities=&#123;user.authorities&#125;</span><br><span class="line">        authorizedRoutes=&#123;authorizedRoutes&#125;</span><br><span class="line">        authorizedLayout=&#123;BasicLayout&#125;</span><br><span class="line">        normalRoutes=&#123;normalRoutes&#125;</span><br><span class="line">        normalLayout=&#123;NormalLayout&#125;</span><br><span class="line">        notFound=&#123;NotFound&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/MultiIntlProvider&gt;</span><br><span class="line">  &lt;/ConnectedRouter&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">const mapStateToProps = state =&gt; (&#123;</span><br><span class="line">  user: state.app.user,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Router.propTypes = propTypes;</span><br><span class="line">export default connect(mapStateToProps)(Router);</span><br></pre></td></tr></table></figure></p><p>根据登陆前后的user props值在 AclRouter.js中重组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;BrowserRouter history=&#123;history&#125;&gt;</span><br><span class="line">    &lt;Switch&gt;</span><br><span class="line">      &lt;Route</span><br><span class="line">        path=&quot;/&quot;</span><br><span class="line">        render=&#123;() =&gt; &lt;Redirect to=&quot;/outlets&quot; /&gt;&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;Route</span><br><span class="line">        path=&quot;/login&quot;</span><br><span class="line">        render=&#123;props =&gt; (</span><br><span class="line">          &lt;NormalLayout &#123;...props&#125;&gt;</span><br><span class="line">            &lt;RouteComponent &#123;...props&#125; /&gt;</span><br><span class="line">          &lt;/NormalLayout&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      ......</span><br><span class="line">    &lt;/Switch&gt;</span><br><span class="line"> &lt;/BrowserRouter&gt;</span><br></pre></td></tr></table></figure></p><p>真正做到了根据用户权限，动态改变重组整个BrowserRouter组件。</p><h3 id="BrowserRouter是组件"><a href="#BrowserRouter是组件" class="headerlink" title="BrowserRouter是组件"></a>BrowserRouter是组件</h3><p>如上，BrowserRouter 可通过connect 的 mapStateToProps 中的 user props值 重新渲染 BrowserRouter。<br>这也验证了 react-router中说的所有router都是组件的说法。</p><h3 id="因为BrowserRouter是组件，所以能理所当然地使用connect"><a href="#因为BrowserRouter是组件，所以能理所当然地使用connect" class="headerlink" title="因为BrowserRouter是组件，所以能理所当然地使用connect"></a>因为BrowserRouter是组件，所以能理所当然地使用connect</h3><p>见《BrowserRouter是组件》<br>参考demo /src/app/init/Router.js</p><h2 id="redux-设计"><a href="#redux-设计" class="headerlink" title="redux 设计"></a>redux 设计</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在初始化公共目录下的js中统一注入reducer，并写了一个公共的action和reducer，此公共的action和reducer可能很多页面都要用，因此写在公共目录下，供很多页面使用<br>：参考：src/app.<br>每个页面的reducer与action写在每个页面目录下,例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- outlets</span><br><span class="line">  - action.js</span><br><span class="line">  - index.js</span><br><span class="line">  - index.scss</span><br><span class="line">  - reducer.js</span><br></pre></td></tr></table></figure></p><h3 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h3><p>在初始化js中，统一注入reducer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import outlets from &apos;views/outlets/reducer&apos;;</span><br><span class="line">import outletDetail from &apos;views/outletDetail/reducer&apos;;</span><br><span class="line">import app from &apos;../reducer&apos;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  app,</span><br><span class="line">  outlets,</span><br><span class="line">  outletDetail,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>每个页面的reducer写在每个页面的目录下。</p><h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3><p>参考上面。</p><h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><p>每个页面都要处理 connect(mapStateToProps, mapDispatchToProps)(injectIntl(OutletDetail));</p><h3 id="等待改进部分"><a href="#等待改进部分" class="headerlink" title="等待改进部分"></a>等待改进部分</h3><p>connect 和 公共的action 单独整理 成connect高阶件，然后对比 考虑如何将post等继承其中</p><h2 id="待做"><a href="#待做" class="headerlink" title="待做"></a>待做</h2><ul><li>js源码调试</li><li>css-source map</li><li>mock</li><li>跨域请求 koa</li><li>webpack 代码分离 DllPlugin</li></ul><h1 id="版本v0-01"><a href="#版本v0-01" class="headerlink" title="版本v0.01"></a>版本v0.01</h1><h2 id="版本介绍"><a href="#版本介绍" class="headerlink" title="版本介绍"></a>版本介绍</h2><p>此版本是一个最简单的工程配置版本，指包含一个简单界面和项目最基本的html js css webpack处理。</p><h2 id="如何开始从0启动一个webpack项目"><a href="#如何开始从0启动一个webpack项目" class="headerlink" title="如何开始从0启动一个webpack项目"></a>如何开始从0启动一个webpack项目</h2><h3 id="注重-webpack-入口-："><a href="#注重-webpack-入口-：" class="headerlink" title="注重 webpack 入口 ："></a>注重 webpack 入口 ：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;webpack-dev-server --config webpack.dev.js&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h3 id="项目最基本配置："><a href="#项目最基本配置：" class="headerlink" title="项目最基本配置："></a>项目最基本配置：</h3><p>一个项目无非围绕 html，css，js，图片，axios进行，因此对应的配置如下，本版本下的package.json配置的依赖都是基于以下最基本的配置：</p><h4 id="html"><a href="#html" class="headerlink" title="html"></a>html</h4><p>html模版插件</p><h4 id="css"><a href="#css" class="headerlink" title="css"></a>css</h4><p>scss、css、图片 loader<br>css、图片与html分离<br>css3加兼容性前缀</p><h4 id="js"><a href="#js" class="headerlink" title="js"></a>js</h4><p>es6、es7编译成es5<br>es6、es7的api(如Promise等等)运行profill<br>一些es6等相关的babel js插件</p><h4 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h4><h4 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h4><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>webpack无非就是对html css js 图片文件的打包，因为又多了babel对js的打包，可以说工程项目中对js的打包是最丰富的。</p>]]></content>
      
      
      <categories>
          
          <category> 前端工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> redux-thunk </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>dva与umi笔记</title>
      <link href="/2019/05/22/dva_umi/"/>
      <url>/2019/05/22/dva_umi/</url>
      
        <content type="html"><![CDATA[<p>暂时没有想好如何整理笔记，暂且以每个项目为章节记笔记。</p><h2 id="user-dashboard项目细节"><a href="#user-dashboard项目细节" class="headerlink" title="user-dashboard项目细节"></a>user-dashboard项目细节</h2><h3 id="umi-目录"><a href="#umi-目录" class="headerlink" title=".umi/ 目录"></a>.umi/ 目录</h3><p> 此目录为验证目录，npm start生成，没有作用，也不推荐在此修改代码，为方便验证而生。</p><h3 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h3> <figure class="image-box">                <img src="/image/dva_umi/user-dashboard.png" alt="" title="" class="">                <p></p>            </figure><h3 id="入口页面"><a href="#入口页面" class="headerlink" title="入口页面"></a>入口页面</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src\pages\.umi\umi.js  ---ReactDOM.render</span><br></pre></td></tr></table></figure><p>此页面集成了一个项目的两大要素： dva (状态) 和 路由：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">src\pages\.umi\DvaContainer.js  ---dva (状态)</span><br><span class="line">src\pages\.umi\router.js ---路由</span><br></pre></td></tr></table></figure></p><h3 id="dva-布局"><a href="#dva-布局" class="headerlink" title="dva 布局"></a>dva 布局</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">src\pages\.umi\DvaContainer.js</span><br><span class="line">src\pages\users\models\users.js (reducers effects)</span><br><span class="line">src\pages\users\components\Users\Users.js (connect mapStateToProps dispatch) 【dispatch 由connect集成】</span><br></pre></td></tr></table></figure><h3 id="User-js页面分析"><a href="#User-js页面分析" class="headerlink" title="User.js页面分析"></a>User.js页面分析</h3><h4 id="subscriptions-setup"><a href="#subscriptions-setup" class="headerlink" title="subscriptions setup"></a>subscriptions setup</h4><p>进入User页面后，首先触发 src\pages\users\models\users.js 下的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">subscriptions: &#123;</span><br><span class="line">    setup(&#123; dispatch, history &#125;) &#123;</span><br><span class="line">      return history.listen((&#123; pathname, query &#125;) =&gt; &#123;</span><br><span class="line">        if (pathname === &apos;/users&apos;) &#123;</span><br><span class="line">          dispatch(&#123; type: &apos;fetch&apos;, payload: query &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>在setup 中触发 改js下的 effects fetch.<br><a href="https://dvajs.com/knowledgemap/#%E5%BC%82%E6%AD%A5%E6%95%B0%E6%8D%AE%E5%88%9D%E5%A7%8B%E5%8C%96" target="_blank" rel="noopener">原因参考dva文档—异步数据初始化</a></p><h4 id="effects-fetch"><a href="#effects-fetch" class="headerlink" title="effects fetch"></a>effects fetch</h4><p>在fetch中首先 usersService.fetch 向后台请求数据；<br>然后将返回的数据，put触发 reducers save;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*fetch(&#123; payload: &#123; page = 1 &#125; &#125;, &#123; call, put &#125;) &#123;</span><br><span class="line">     const &#123; data, headers &#125; = yield call(usersService.fetch, &#123; page &#125;);</span><br><span class="line">     yield put(&#123;</span><br><span class="line">       type: &apos;save&apos;,</span><br><span class="line">       payload: &#123;</span><br><span class="line">         data,</span><br><span class="line">         total: parseInt(headers[&apos;x-total-count&apos;], 10),</span><br><span class="line">         page: parseInt(page, 10),</span><br><span class="line">       &#125;,</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure></p><h4 id="reducers-save"><a href="#reducers-save" class="headerlink" title="reducers save"></a>reducers save</h4><p>通过save reducer忘redux上造数据list，total。。。以后User页面使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">reducers: &#123;</span><br><span class="line">   save(state, &#123; payload: &#123; data: list, total, page &#125; &#125;) &#123;</span><br><span class="line">     return &#123; ...state, list, total, page &#125;;</span><br><span class="line">   &#125;,</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure></p><h3 id="细节关注点"><a href="#细节关注点" class="headerlink" title="细节关注点"></a>细节关注点</h3><h4 id="fetch-与-yield-的-generateor写法"><a href="#fetch-与-yield-的-generateor写法" class="headerlink" title="*fetch 与 yield 的 generateor写法"></a>*fetch 与 yield 的 generateor写法</h4><p>这里的*和yield是 generateor的写法，可到mdn网查询了解。</p><h4 id="fetch的loading是怎么来的"><a href="#fetch的loading是怎么来的" class="headerlink" title="fetch的loading是怎么来的"></a>fetch的loading是怎么来的</h4><p>发fetch请求时，通过dva-loading 配合dva中间件，会自动给redux 的store 改变store.loading的state，<br>在fetch开始和完成时将store.loading置为true或false：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//src\pages\.umi\DvaContainer.js</span><br><span class="line">import createLoading from &apos;dva-loading&apos;;</span><br><span class="line">app.use(createLoading());</span><br></pre></td></tr></table></figure><p>在页面中，通过mapStateToProps拿到这个redux的state.loading值，根据这个值，自行开启或关闭loading组件或效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//src\pages\users\components\Users\Users.js</span><br><span class="line">&lt;Table</span><br><span class="line">    columns=&#123;columns&#125;</span><br><span class="line">    dataSource=&#123;dataSource&#125;</span><br><span class="line">    loading=&#123;loading&#125;</span><br><span class="line">    rowKey=&#123;record =&gt; record.id&#125;</span><br><span class="line">    pagination=&#123;false&#125;</span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line">function mapStateToProps(state) &#123;</span><br><span class="line">  const &#123; list, total, page &#125; = state.users;</span><br><span class="line">  return &#123;</span><br><span class="line">    loading: state.loading.models.users,</span><br><span class="line">    list,</span><br><span class="line">    total,</span><br><span class="line">    page,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default connect(mapStateToProps)(Users);</span><br></pre></td></tr></table></figure></p><h4 id="import-styles-from-‘-index-css’-的运用："><a href="#import-styles-from-‘-index-css’-的运用：" class="headerlink" title="import styles from ‘./index.css’ 的运用："></a>import styles from ‘./index.css’ 的运用：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import styles from &apos;./index.css&apos;;</span><br><span class="line">console.log(styles)//&#123;normal: &quot;index__normal___3v60A&quot;, content: &quot;index__content___14HDd&quot;, main: &quot;index__main___nz_0B&quot;&#125;</span><br><span class="line"> &lt;div className=&#123;styles.main&#125;&gt;&#123;children&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="dva与umijs在项目中起的作用统筹分析"><a href="#dva与umijs在项目中起的作用统筹分析" class="headerlink" title="dva与umijs在项目中起的作用统筹分析"></a>dva与umijs在项目中起的作用统筹分析</h3><p>本节分析参考pages/.umi/下的文件进行。</p><h4 id="dva"><a href="#dva" class="headerlink" title="dva"></a>dva</h4><p>项目中，通过dva，你不用写store与Provider的集成代码，dva帮你把这块实现,dva又将路由这块的逻辑剥离出来，提供类似接口(this.props.children)方式，方便接入项目路由js；(因此，dva只专注做redux相关的状态部分，并剥离路由且提供路由接口，方便接入路由)</p><p>而你只需专注于：</p><p>1、写reducer；(按dva规定，将reducer写在model下，以便dva能解析)</p><p>2、哪个组件需要redux了，给组件包一层connect，写好mapStateToProps，</p><h4 id="umijs"><a href="#umijs" class="headerlink" title="umijs"></a>umijs</h4><p>至于路由，则由umijs处理，umijs可以将pages下的文件自动解析为路由router.js(.umi下的router.js);</p><p>至此，一个项目的 redux与路由两大块全部写好。<br>剩下一个工作就是 如何将redux与路由两大块有机结合起来呢，<br>这个工作就是umijs做的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function render() &#123;</span><br><span class="line">  const DvaContainer = require(&apos;./DvaContainer&apos;).default; //dva处理的redux逻辑部分</span><br><span class="line">ReactDOM.render(React.createElement(</span><br><span class="line">  DvaContainer,</span><br><span class="line">  null,</span><br><span class="line">  React.createElement(require(&apos;./router&apos;).default)  //umijs处理的路由部分逻辑部分</span><br><span class="line">), document.getElementById(&apos;root&apos;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>因此在以上过程umijs做了以下事情：</p><p>1、封装路由，按约定会将pages下的文件编译为路由文件；</p><p>2、将上面的路由文件与 dva封装好的redux的reducer状态文件有机组合；</p><p>3、有机结合路由和redux后，ReactDOM.render生成启动入口js；</p><p>由上可知，umijs至始至终没有处理过redux部分，都是dva处理好后，umijs拿过来组合下而已。</p><p>整个项目过程，dva只做了一件事情：</p><p>封装reducer，处理redux，dva按约定会将model目录下的文件封装成reducer；</p><p>另外在整个过程中，umijs顺手还做了 webpack配置，比如module.hot 热更新。</p><h3 id="user-dashboard-与-with-dva"><a href="#user-dashboard-与-with-dva" class="headerlink" title="user-dashboard 与 with-dva"></a>user-dashboard 与 with-dva</h3><p>分析这两个项目，有利于理解dva与umi两个人干的事情，这两个项目将他们二人的配置有机串起来，<br>在刷一遍dva与umi文档的基础上，看这两个项目，看完项目后，再去看dva与umi的文档，发现更能看懂在文档中所表达的意思。<br>以上过程入手和研究其他框架的常用手段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">网上大量刷一些有关框架的作用比较和题外话，加深框架的整体影响；</span><br><span class="line">刷一遍文档(快速)；</span><br><span class="line">启动下官方推荐的例子；</span><br><span class="line">再次刷文档；</span><br></pre></td></tr></table></figure></p><h2 id="with-dva项目细节"><a href="#with-dva项目细节" class="headerlink" title="with-dva项目细节"></a>with-dva项目细节</h2><h3 id="layout-js-与-嵌套路由"><a href="#layout-js-与-嵌套路由" class="headerlink" title="_layout.js 与 嵌套路由"></a>_layout.js 与 嵌套路由</h3><p><a href="https://umijs.org/zh/guide/router.html#%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1" target="_blank" rel="noopener">umi 里约定目录下有 _layout.js 时会生成嵌套路由，以 _layout.js 为该目录的 layout 。</a></p><p>本例的src\pages\list_layout.js 是嵌套路由。</p><h3 id="全局-layout"><a href="#全局-layout" class="headerlink" title="全局 layout"></a>全局 layout</h3><p>与上相应的是，全局路由，<a href="https://umijs.org/zh/guide/router.html#%E5%85%A8%E5%B1%80-layout" target="_blank" rel="noopener">参考官网</a>。<br>本例的src\layouts\index.js 是 全局路由。</p><h3 id="model-js-与-models-目录"><a href="#model-js-与-models-目录" class="headerlink" title="model.js 与 models/ 目录"></a>model.js 与 models/ 目录</h3><p><a href="https://dvajs.com/guide/getting-started.html#%E5%AE%9A%E4%B9%89-model" target="_blank" rel="noopener">参考官网–快速上手-定义model</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">本例的 src\pages\list\search\model.js</span><br><span class="line">本例的 src\pages\list\models\</span><br></pre></td></tr></table></figure></p><p>以上两种情况都会被dva用来解析成reducer，组装store.getState().[nameSpace],也就是组装全局state的key值；<br>任何组件都可以通过store.getState()获取</p><p>这里想说的是，项目中，在不同位置定义的model，看起来没有什么区别或特殊，任意一个地方定义了model后，任何组件都可以凭model的nameSpace获取该状态。</p><h3 id="src-pages-index路由说明"><a href="#src-pages-index路由说明" class="headerlink" title="src\pages\index路由说明"></a>src\pages\index路由说明</h3><p>在目录的 src\pages\index下有以下文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ pages/</span><br><span class="line">  + index/</span><br><span class="line">    - components/</span><br><span class="line">      - Count.js</span><br><span class="line">    - model.js</span><br><span class="line">    - index.js</span><br></pre></td></tr></table></figure></p><p>按照umijs约定，输入以下路由到浏览器url上，应该是可以显示Count页面的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8000/#/index/components/Count</span><br></pre></td></tr></table></figure></p><p>但是却不行，原因是src\pages\index是主目录路由，src\pages\index\目录下定义的文件都将不被解析为路由，此目录下的index.js为默认主域名下的页面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8000/#/</span><br></pre></td></tr></table></figure></p><h3 id="本例具有hot-loader功能"><a href="#本例具有hot-loader功能" class="headerlink" title="本例具有hot-loader功能"></a>本例具有hot-loader功能</h3><p>本例具有热更新功能，有兴趣可以研究底层配置实现。</p><h3 id="effects"><a href="#effects" class="headerlink" title="effects"></a>effects</h3><p>Effect 被称为副作用，在我们的应用中，最常见的就是异步操作。<br>项目的异步请求，以及异步请求后根据接口数据，发起action，都是写在effects中。<br>effects定义了一些关键字(put\call\select..)用来处理比如发送action：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yield put(&#123; type: &apos;reload&apos; &#125;);</span><br></pre></td></tr></table></figure></p><p><a href="https://dvajs.com/guide/concepts.html#effect" target="_blank" rel="noopener">参考dva–指南-dva概念-models-Effect</a><br><a href="https://dvajs.com/knowledgemap/#effects" target="_blank" rel="noopener">参考dva–知识地图-Effect-effects</a></p><h3 id="effects与reducers"><a href="#effects与reducers" class="headerlink" title="effects与reducers"></a>effects与reducers</h3><p>effects跟reducers定义相似，二者都是用来定义action的reducer操作，不同的是，effects用来定义异步action，当action要发起post请求时，一般用effects；<br>相对的，reducer用来定义同步：<a href="https://github.com/YeWills/dva-example/tree/user-dashboard" target="_blank" rel="noopener">参考示例user-dashboard—src\pages\users\models\users.js</a></p><h2 id="umi"><a href="#umi" class="headerlink" title="umi"></a>umi</h2><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><h4 id="权限路由-与-Routes"><a href="#权限路由-与-Routes" class="headerlink" title="权限路由 与 Routes"></a>权限路由 与 Routes</h4><p>umi 的权限路由是通过配置路由的 Routes 属性来实现。<br><a href="https://github.com/YeWills/umi-example/tree/routes-via-config" target="_blank" rel="noopener">参考demo</a><br>以下是权限路由的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; path: &apos;/list&apos;, component: &apos;./pages/list.js&apos;, Routes: [&apos;./routes/PrivateRoute.js&apos;] &#125;,</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//PrivateRoute.js</span><br><span class="line">export default (props) =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;PrivateRoute (routes/PrivateRoute.js)&lt;/div&gt;</span><br><span class="line">      &#123; props.children &#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于Routes定义的权限组件PrivateRoute而言，PrivateRoute可以通过props.children能访问上面component定义的组件，然后跳转到/list路由url时，实际显示的是Routes的组件。Routes组件拥有最高权限，通过props.child决定是否显示component定义的组件。</p><p>权限路由有些类似全局路由。<br>更多说明，<a href="https://umijs.org/zh/guide/router.html#%E6%9D%83%E9%99%90%E8%B7%AF%E7%94%B1" target="_blank" rel="noopener">参考 umi–指南-路由-权限路由</a></p><h3 id="umi-command-not-found"><a href="#umi-command-not-found" class="headerlink" title="umi:command not found"></a>umi:command not found</h3><h4 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn global install umi</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//查看yarn目录</span><br><span class="line">yarn global bin</span><br><span class="line">/Users/js/.yarn/bin</span><br></pre></td></tr></table></figure><p>设置环境变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi ~/.bash_profile</span><br><span class="line">//然后输入用户密码</span><br><span class="line">//添加这一句话到.bash_profile文件</span><br><span class="line">export PATH=&quot;$PATH:`yarn global bin`&quot;</span><br></pre></td></tr></table></figure></p><p>重启命令窗口<br>再次输入umi就可以了。</p><h4 id="关于mac环境变量配置有关"><a href="#关于mac环境变量配置有关" class="headerlink" title="关于mac环境变量配置有关"></a>关于mac环境变量配置有关</h4><h4 id="PATH的字符串写法"><a href="#PATH的字符串写法" class="headerlink" title="$PATH的字符串写法"></a>$PATH的字符串写法</h4><p>接着上面mac对umi的环境变量配置，上面设置环境变量的步骤设置成如下也是的一样的效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/Users/js/.yarn/bin</span><br></pre></td></tr></table></figure></p><h4 id="PATH的变量写法"><a href="#PATH的变量写法" class="headerlink" title="$PATH的变量写法"></a>$PATH的变量写法</h4><p>我们观察到，export PATH=”$PATH:<code>yarn global bin</code>“ 是一种变量的写法，将yarn global bin 这个整体当成一个变量。<br>类似于 yarn global bin 等价于 /Users/js/.yarn/bin；<br>因为bash中执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//查看yarn目录</span><br><span class="line">yarn global bin</span><br><span class="line">/Users/js/.yarn/bin</span><br></pre></td></tr></table></figure></p><h4 id="多个环境变量以：打印echo输出"><a href="#多个环境变量以：打印echo输出" class="headerlink" title="多个环境变量以：打印echo输出"></a>多个环境变量以：打印echo输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi ~/.bash_profile</span><br><span class="line">//进入vim模式后，文件内容如下：</span><br><span class="line">export PATH=$PATH:/usr/local/mongodb/bin</span><br><span class="line">export PATH=$PATH:/Users/js/.yarn/bin</span><br><span class="line">$ echo $PATH</span><br><span class="line">/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/mongodb/bin:/Users/js/.yarn/bin</span><br><span class="line">我们看到了 mongodb的环境变量并没有被后面的yarn路径覆盖，他们全部被平行保存，通过冒号:隔开表示。</span><br></pre></td></tr></table></figure><h4 id="bash-profile中的环境变量不会覆盖"><a href="#bash-profile中的环境变量不会覆盖" class="headerlink" title=".bash_profile中的环境变量不会覆盖"></a>.bash_profile中的环境变量不会覆盖</h4><p>如上分析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/mongodb/bin</span><br><span class="line">export PATH=$PATH:/Users/js/.yarn/bin</span><br></pre></td></tr></table></figure></p><p>虽然使用PATH=先后定义了mongodb和yarn，但是yarn并没有覆盖mongodb，通过echo打印可以查证。具体参考上面分析。</p><h4 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h4><p>windows解决方式一样，唯一不同的是，是将 yarn global bin 打印的地址添加到环境变量中。</p><h3 id="umi的使用"><a href="#umi的使用" class="headerlink" title="umi的使用"></a>umi的使用</h3><p>官网中通过 <code>快速上手</code> 和 <code>通过脚手架创建项目</code> 两部分详细介绍了如何使用umi，通过这种方式来创建项目工程，很有借鉴学习之用，亲试可行，在此单独从官网从拎出来说明，以示重视。</p><h4 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h4><p><a href="https://umijs.org/zh/guide/getting-started.html" target="_blank" rel="noopener">参考umi–指南-快速上手</a></p><h4 id="通过脚手架创建项目"><a href="#通过脚手架创建项目" class="headerlink" title="通过脚手架创建项目"></a>通过脚手架创建项目</h4><p><a href="https://umijs.org/zh/guide/create-umi-app.html" target="_blank" rel="noopener">参考umi–指南-通过脚手架创建项目</a></p><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><h3 id="with-dva"><a href="#with-dva" class="headerlink" title="with-dva"></a>with-dva</h3><p><a href="https://github.com/YeWills/umi-example/tree/with-dva" target="_blank" rel="noopener">demo地址</a><br>一个很好的 umi 配合 dva的例子，讲了各种路由配置,已经dva的运用，是 umi约定式路由范例。<br>参考《with-dva项目细节》<br> <figure class="image-box">                <img src="/image/dva_umi/with-dva.png" alt="" title="" class="">                <p></p>            </figure></p><h3 id="routes"><a href="#routes" class="headerlink" title="routes"></a>routes</h3><p><a href="https://github.com/YeWills/umi-example/tree/routes" target="_blank" rel="noopener">demo地址</a><br>本例展示在umijs中如何按约定生成 各种类型的路由，如 基础、动态、可选动态、嵌套、全局、404路由。<br>相关讲解，<a href="https://umijs.org/zh/guide/router.html#%E5%9F%BA%E7%A1%80%E8%B7%AF%E7%94%B1" target="_blank" rel="noopener">参考umi–指南-路由-约定式路由</a><br>本项目也可用于react项目常用到的一些路由知识学习<br> <figure class="image-box">                <img src="/image/dva_umi/routes.png" alt="" title="" class="">                <p></p>            </figure></p><h3 id="routes-via-config"><a href="#routes-via-config" class="headerlink" title="routes-via-config"></a>routes-via-config</h3><p>此demo相对简单，在umijs下，如何自行配置路由。是 umi配置式路由范例。<br>通过本例知道，主要是通过.umirc.js 来进行配置路由。 本例运用了权限路由。<br><a href="https://umijs.org/zh/guide/router.html#%E9%85%8D%E7%BD%AE%E5%BC%8F%E8%B7%AF%E7%94%B1" target="_blank" rel="noopener">参考umi–指南-路由-配置式路由</a><br> <figure class="image-box">                <img src="/image/dva_umi/routes-via-config.png" alt="" title="" class="">                <p></p>            </figure></p><h3 id="umi-dva-user-dashboard"><a href="#umi-dva-user-dashboard" class="headerlink" title="umi-dva-user-dashboard"></a>umi-dva-user-dashboard</h3><p>一个简单的示例，可作为umi与dva结合的示例。是了解umi与dva的入门demo，其解说参见《user-dashboard项目细节》，<br>是下面的user-dashboard示例的优化版。<br><a href="https://github.com/YeWills/umi-example/tree/umi-dva-user-dashboard" target="_blank" rel="noopener">demo地址</a><br> <figure class="image-box">                <img src="/image/dva_umi/umi-dva-user-dashboard.png" alt="" title="" class="">                <p></p>            </figure></p><h3 id="user-dashboard"><a href="#user-dashboard" class="headerlink" title="user-dashboard"></a>user-dashboard</h3><p>参考《user-dashboard项目细节》<br>这个示例没有 上面的 umi-dva-user-dashboard精细，但也可一看。<br> <figure class="image-box">                <img src="/image/dva_umi/user-dashboard-view.png" alt="" title="" class="">                <p></p>            </figure></p><h3 id="with-nav-and-sidebar"><a href="#with-nav-and-sidebar" class="headerlink" title="with-nav-and-sidebar"></a>with-nav-and-sidebar</h3><p><a href="https://github.com/YeWills/umi-example/tree/with-nav-and-sidebar" target="_blank" rel="noopener">demo地址</a><br>要做侧边栏(sidebar)和导航栏时，可参考本示例，非常简洁的，只有侧边栏和导航栏的示例<br><img src="https://gw.alipayobjects.com/zos/rmsportal/DReQIejdcJPeaXWEDKDe.png"></p><h3 id="ant-design-pro"><a href="#ant-design-pro" class="headerlink" title="ant-design-pro"></a>ant-design-pro</h3><p>深入了解umi与dva的综合示例</p><h2 id="学习资料与小结"><a href="#学习资料与小结" class="headerlink" title="学习资料与小结"></a>学习资料与小结</h2><h3 id="github仓库"><a href="#github仓库" class="headerlink" title="github仓库"></a>github仓库</h3><p>github中以下仓库为学习期间的全部demo：<br><a href="https://github.com/YeWills/umi-example" target="_blank" rel="noopener">umi-example</a><br><a href="https://github.com/YeWills/dva-example" target="_blank" rel="noopener">dva-example</a><br><a href="https://github.com/YeWills/ant-design-pro" target="_blank" rel="noopener">ant-design-pro</a><br>以上demo都基于官网开源demo，感谢。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><h4 id="dva与umi学习"><a href="#dva与umi学习" class="headerlink" title="dva与umi学习"></a>dva与umi学习</h4><p>学习dva与umi，建议先从dva了解开始，然后是umi，然后再是ant-design-pro；<br>dva与umi的学习，快速过官网文档，然后运行文档中给出的demo，对照demo，再针对性看文档，多看文档。<br>以上熟悉后，再看ant-design-pro。</p><h4 id="dva与umi认识"><a href="#dva与umi认识" class="headerlink" title="dva与umi认识"></a>dva与umi认识</h4><p>dva与umi创建项目的方式新颖，通过包管理方式创建脚手架，是很多公司大厂的常规做法，umi更像一个大厂内部的标准工程脚手架。<br>如果你处于一个公司的架构师位置，想要出一个全公司统一的前端开发脚手架，你所在公司安全级别高，对项目依赖包有安全要求，对项目有管控需求以便达到安全级别，umi无疑是你的标杆。<br>如果你们公司不是一个五六百人的公司，而且没有对公司内所有前端项目所用依赖包的版本有管制需求，并且没有统一前端脚手架的需求，建议还是自行配置一套脚手架，有利于 版本升级，问题追踪，风险可控性好。<br>总而言之，umi这种react标准化工程项目的做法非常妙，无论你想直接用它或者从中借鉴理念或方案都非常值得你一看。</p><h2 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h2><h3 id="dva-1"><a href="#dva-1" class="headerlink" title="dva"></a>dva</h3><p><a href="https://dvajs.com/guide/getting-started.html#%E5%AE%9A%E4%B9%89-model" target="_blank" rel="noopener">参考dva–指南-快速上手-定义model</a><br><a href="https://dvajs.com/guide/concepts.html#effect" target="_blank" rel="noopener">参考dva–指南-dva概念-models-Effect</a><br><a href="https://dvajs.com/knowledgemap/#effects" target="_blank" rel="noopener">参考dva–知识地图-Effect-effects</a></p><h3 id="umi-1"><a href="#umi-1" class="headerlink" title="umi"></a>umi</h3><p><a href="https://umijs.org/zh/guide/router.html#%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1" target="_blank" rel="noopener">参考umi–指南-路由-约定式路由</a></p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dva </tag>
            
            <tag> umi </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vertical-align、行盒子、baseline</title>
      <link href="/2019/05/21/css_vertical_align/"/>
      <url>/2019/05/21/css_vertical_align/</url>
      
        <content type="html"><![CDATA[<p>本文讲解vertical-align, baseline, 行盒子, x-height, line-height, 半铅空,以及这些概念如何运用于行内元素居中、和使用line-height让元素居中，其中花了大量示例和说明介绍了如何确定父元素和行内元素的baseline。</p><h2 id="vertical-align"><a href="#vertical-align" class="headerlink" title="vertical-align"></a>vertical-align</h2><h3 id="为什么会这样"><a href="#为什么会这样" class="headerlink" title="为什么会这样"></a>为什么会这样</h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>如图两个定义为inline-block的div一模一样，就是一个多了555：<br>没有555时，两个div还是一起的：<br><figure class="image-box">                <img src="/image/css/question1.png" alt="" title="" class="">                <p></p>            </figure><br>加了555，两个div不一起了：<br><figure class="image-box">                <img src="/image/css/question2.png" alt="" title="" class="">                <p></p>            </figure><br>源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">        div&#123;</span><br><span class="line">            background: blue;</span><br><span class="line">        &#125;</span><br><span class="line">        .qq&#123;</span><br><span class="line">            height: 80px;</span><br><span class="line">            width: 80px;</span><br><span class="line">            border: 1px solid black;</span><br><span class="line">            display: inline-block;</span><br><span class="line">        &#125;</span><br><span class="line">        .a1&#123;</span><br><span class="line">            background-color: yellow;</span><br><span class="line">        &#125;</span><br><span class="line">        .a2&#123;</span><br><span class="line">            background-color: red;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;div class=&quot;a1 qq&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;a2 qq&quot;&gt;555&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><h5 id="为什么之前是对齐的"><a href="#为什么之前是对齐的" class="headerlink" title="为什么之前是对齐的"></a>为什么之前是对齐的</h5><p>在a2中没有加555之前，a2这个inline-block，它的基线(baseline)，就是它的下边距。因为<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/vertical-align" target="_blank" rel="noopener">没有基线的元素，使用外边距的下边缘替代</a>；<br>a2所在的父元素，它的基线由父元素内的inline-block元素确定，那么父元素的基线，也是a1和a2的下边距，<br>此时 a1、a2默认的垂直对齐方式都是 vertical-align:baseline；<br>所以a1和a2是对齐的；</p><h5 id="为什么之后不对齐"><a href="#为什么之后不对齐" class="headerlink" title="为什么之后不对齐"></a>为什么之后不对齐</h5><p>在a2中加555之后，它的基线(baseline)就是a2行内块中的555这串文字决定的，它的基线就是下图黄色矩形框的下黄色边框；<br><figure class="image-box">                <img src="/image/css/vertical-align/vertical1.png" alt="" title="" class="">                <p></p>            </figure><br>，因为a1、a2默认的垂直对齐方式都是 vertical-align:baseline，而父基线由a1决定，就是a1的下边框；所以a2需要下降，让它的的基线与父基线位置一致。</p><h3 id="如何对齐"><a href="#如何对齐" class="headerlink" title="如何对齐"></a>如何对齐</h3><p>将同时设置两个inline-block 为<br>vertical-align: middle;<br>或者<br>    vertical-align: top;都可以<br>当然，还可以设置inline-block为浮动元素，脱离文档流，也可以对齐；<br>解释下同时设置两个inline-block 为 vertical-align: middle时为何能对齐；<br>上面的例子，a1是空的inline-block，a2是非空inline-block，父基线以 空的a1为准，当a1设置vertical-align: middle，<br>a1将父基线的位置由a1的下边距，提升至a1的中部+x-height/2,可以近似看成就是a1的中部。<br>a2也将自己的中部与父基线对齐，所以就对齐了。<br>如果不清楚，可以看下面章节《如何确定父元素的baseline》或《另外一个例子》</p><h3 id="对上面例子延伸"><a href="#对上面例子延伸" class="headerlink" title="对上面例子延伸"></a>对上面例子延伸</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 其他都一样 --&gt;</span><br><span class="line">  &lt;div class=&quot;a1 qq&quot;&gt;555&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;a2 qq&quot;&gt;555&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这时候，他们又对齐了：<br><figure class="image-box">                <img src="/image/css/vertical-align/vertical2.jpg" alt="" title="" class="">                <p></p>            </figure></p><p>这是因为他们的父baseline就是下图所示黄色矩形框的下边框，父级baseline其实就是a1和a2的baseline；<br><figure class="image-box">                <img src="/image/css/vertical-align/vertical3.jpg" alt="" title="" class="">                <p></p>            </figure></p><p>在本例的修改基础上，现在我们又将a1定义为vertical-align:middle,其他保持不变<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 其他保持不变 --&gt;</span><br><span class="line">.a1&#123;</span><br><span class="line">   vertical-align: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>效果变成如下：<br><figure class="image-box">                <img src="/image/css/vertical-align/vertical4.jpg" alt="" title="" class="">                <p></p>            </figure></p><p>vertical-align: middle 意思是：使元素的中部与父元素的基线加上父元素x-height的一半对齐。</p><p>本例中，x-height的值差不多5px，x-height 的值计算，参考下面章节《x-height》,<br>父元素的基线就是a2的基线，a2的基线如图所示，所以变成这样的效果。</p><h3 id="确定父基线最简单的方法"><a href="#确定父基线最简单的方法" class="headerlink" title="确定父基线最简单的方法"></a>确定父基线最简单的方法</h3><p>可能你疑惑，上面例子中，父基线真的是上面所说的吗，怎么验证呢，一个简单的方法，就是在父元素内，增加一段匿名行内元素，简单点说就是在父元素内，增加一段字符，那么这个字符的位置就说明了父元素的基线位置，因为，父元素的基线 总是与其内的匿名行内元素的基线一致：<br>比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    background: blue;</span><br><span class="line">&#125;</span><br><span class="line">.qq&#123;</span><br><span class="line">    height: 80px;</span><br><span class="line">    width: 80px;</span><br><span class="line">    border: 1px solid black;</span><br><span class="line">    display: inline-block;</span><br><span class="line">&#125;</span><br><span class="line">.a1&#123;</span><br><span class="line">    background-color: yellow;</span><br><span class="line">&#125;</span><br><span class="line">.a2&#123;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">     我这几个字就是所谓的匿名行内元素哦</span><br><span class="line">    &lt;div class=&quot;a1 qq&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;a2 qq&quot;&gt;555&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>效果如下：<br><figure class="image-box">                <img src="/image/css/vertical-align/vae1.jpg" alt="" title="" class="">                <p></p>            </figure></p><p>继续修改，其他不变，在a1中加555字符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 其他都一样 --&gt;</span><br><span class="line">  &lt;div class=&quot;a1 qq&quot;&gt;555&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>效果如下：<br><figure class="image-box">                <img src="/image/css/vertical-align/ver2.jpg" alt="" title="" class="">                <p></p>            </figure></p><p>继续修改，其他不变，修改如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 其他保持不变 --&gt;</span><br><span class="line">.a1&#123;</span><br><span class="line">   vertical-align: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>效果如下：<br><figure class="image-box">                <img src="/image/css/vertical-align/ver3.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="另外一个例子"><a href="#另外一个例子" class="headerlink" title="另外一个例子"></a>另外一个例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.wrap&#123;</span><br><span class="line">      background: blue;</span><br><span class="line">  &#125;</span><br><span class="line">  .item&#123;</span><br><span class="line">      height: 80px;</span><br><span class="line">      width: 80px;</span><br><span class="line">      border: 1px solid black;</span><br><span class="line">      display: inline-block;</span><br><span class="line">      background-color: yellow;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &lt;div class=&quot;wrap&quot;&gt;</span><br><span class="line">             6666</span><br><span class="line">              &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">          &lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="/image/css/vertical-align/more1.jpg" alt="" title="" class="">                <p></p>            </figure><p>现在修改如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//其他不变</span><br><span class="line">.item&#123;</span><br><span class="line">     vertical-align: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>效果如下：<br><figure class="image-box">                <img src="/image/css/vertical-align/more2.jpg" alt="" title="" class="">                <p></p>            </figure></p><p>为什么呢，原因是，item改为vertical-align: middle时，直接将父baseline改到自身的中部位置了，<br>这个例子说明，<strong>父级内的空的inline-block元素，可以通过vertical-align: middle将父baseline改到自身的中部位置。</strong></p><h3 id="如何确定父元素的baseline"><a href="#如何确定父元素的baseline" class="headerlink" title="如何确定父元素的baseline"></a>如何确定父元素的baseline</h3><p>父元素的baseline依据其内部行内元素类型不同，baseline不同。<br>通过以上例子，我们可以看到</p><h4 id="全部是行内元素"><a href="#全部是行内元素" class="headerlink" title="全部是行内元素"></a>全部是行内元素</h4><p>当父元素内，全部是行内元素(非inline-block)时，类似：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;father&quot;&gt;</span><br><span class="line">   abc文字符</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>父元素内的baseline 由’abc文字符’这几个字确定，此时父baseline就是文字的下划线的位置上</p><h4 id="有inline-block"><a href="#有inline-block" class="headerlink" title="有inline-block"></a>有inline-block</h4><p>如果父元素内有inline-block，且inline-block内没有文字时，父baseline就是inline-block的下边距线；<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;father&quot;&gt;</span><br><span class="line">   &lt;div class=&quot;inline-block&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>如果父元素内有多个inline-block，且有些inline-block内有文字时,此时父元素内的baseline以没有文字的inline-block为准；<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;father&quot;&gt;</span><br><span class="line">   &lt;div class=&quot;inline-block&quot;&gt;来电文字&lt;/div&gt;</span><br><span class="line">   &lt;div class=&quot;inline-block&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>详细，参见上面例子。</p><h4 id="有img图片"><a href="#有img图片" class="headerlink" title="有img图片"></a>有img图片</h4><p>父元素含有img图片其实就是空的inline-block，规则参见《有inline-block》</p><h4 id="可使用vertical-align修改父基线"><a href="#可使用vertical-align修改父基线" class="headerlink" title="可使用vertical-align修改父基线"></a>可使用vertical-align修改父基线</h4><p>父级内的空的inline-block元素，可以通过设置不同的vertical-align值达到修改父baseline。<br>见《另外一个例子》</p><h3 id="如何确定自己的baseline"><a href="#如何确定自己的baseline" class="headerlink" title="如何确定自己的baseline"></a>如何确定自己的baseline</h3><p>这里的自己，就是上面例子中的a1、a2、字符串等等的行内元素，依据不同类型行内元素的自己，baseline取值不同</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>这个最简单，基线几乎等于紧贴字符串的下划线<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abc字符串</span><br></pre></td></tr></table></figure></p><h4 id="inline-block"><a href="#inline-block" class="headerlink" title="inline-block"></a>inline-block</h4><p>当自己是inline-block时，<br>分两种情况：</p><ul><li><p>当自己是空的inline-block时，自己的基线就是自己的下边框,如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;inline-block&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>当自己是非空的inline-block时，自己的基线就是自己元素内部的字符串的下边框，也就是紧贴字符串的下划线,更多请参考《为什么之后不对齐》</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;inline-block&quot;&gt;abc456&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="img"><a href="#img" class="headerlink" title="img"></a>img</h4><p>这种最好分别，参考同《inline-block》的空inline-block情况，它的基线就是图片下边框。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>要解答文首抛出的疑问，我们要了解 父元素的baseline 如何确定；<br>inline-block内有无文字时，其baseline如何确定；<br>中间涉及到行内盒子的x-height概念。<br>而vertical-align并没有什么神秘，其实就是制定对齐规则而已。<br>本例只专门讨论<br>vertical-align:baseline<br>vertical-align:middle<br>这两种情况，用得最多，其他情况根据这两种情况类推就行。</p><p>还要特别注意的，在mdn上说了，<strong>vertical-align只作用于 行内元素，inline-block，img 这些元素。</strong></p><h3 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h3><h4 id="为什么有间隙"><a href="#为什么有间隙" class="headerlink" title="为什么有间隙"></a>为什么有间隙</h4><p>在文首的提问中，为什么这里有缝隙呢，<a href="https://www.cnblogs.com/starof/p/4512284.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">原来这个默认vertical-align:baseline，而baseline的下方会给字母的一部分留出空间，因此会产生一个空隙，要产生理想的效果</a>,链接上文章上说它与vertical-align有关（顺便说下，此链接上的文章有些例子有问题，注意了），至于为什么或者到底是否与vertical-align有关就不要穷究了，可能是vertical-align造成就行。<br><figure class="image-box">                <img src="/image/css/question1.png" alt="" title="" class="">                <p></p>            </figure></p><h4 id="利用伪类垂直居中"><a href="#利用伪类垂直居中" class="headerlink" title="利用伪类垂直居中"></a>利用伪类垂直居中</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  .wrap &#123;</span><br><span class="line">        background: #00bcd4ba;</span><br><span class="line">        height: 150px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .item &#123;</span><br><span class="line">        vertical-align: middle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .item1 &#123;</span><br><span class="line">        height: 50px;</span><br><span class="line">        width: 50px;</span><br><span class="line">        display: inline-block;</span><br><span class="line">        background: blue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .item2 &#123;</span><br><span class="line">        height: 80px;</span><br><span class="line">        width: 80px;</span><br><span class="line">        display: inline-block;</span><br><span class="line">        background: blue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;wrap&quot;&gt;</span><br><span class="line">    80版经典上海滩</span><br><span class="line">    &lt;div class=&quot;item1 item&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item2 item&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>效果：<br><figure class="image-box">                <img src="/image/css/vertical-align/after1.jpg" alt="" title="" class="">                <p></p>            </figure></p><p>你看到就算你把item1和item2都做了vertical-align: middle;<br>都无法让元素相对于整个wrap元素垂直居中，<br>增加下面代码就可以了,给父层增加一个伪类，设置这个伪类为inline-block,从而能设置宽高；<br>这个伪类的高度撑满整个wrap，然后设置vertical-align: middle;<br>因为这个伪类的高度相对其他元素最高，所以，它设置vertical-align: middle会将父元素的baseline拉到伪类的中部去，<br>而伪类又与父元素同高，这样就可以达到相对父元素垂直居中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.wrap::after &#123;</span><br><span class="line">    content: &apos;&apos;;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    height: 100%;</span><br><span class="line">    &lt;!-- 注意的是上面代码不起作用时，可以定义width: 1px; 一般是不必定义width: 1px--&gt;</span><br><span class="line">    &lt;!-- width: 1px; --&gt;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实这样的after伪类有些人也称为幽灵元素。<br>效果：<br><figure class="image-box">                <img src="/image/css/vertical-align/after2.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="关于vertical-align你要知道的"><a href="#关于vertical-align你要知道的" class="headerlink" title="关于vertical-align你要知道的"></a>关于vertical-align你要知道的</h3><p>vertical-align 就是用来让行内元素对齐的；vertical-align这个属性就是为了行内元素而生，如果没有行内元素，vertical-align就没有任何存在的意义；<br>同样的，如何要做行内元素的对齐，你可以不使用vertical-align，但如果不懂vertical-align，那么你能把行内元素做得对齐，也是碰运气，瞎搞搞。<br>要全面的理解vertical-align，不仅要知道vertical-align的定义，还要知道行内元素的特性，如行内元素的基线；<br>还要知道父元素的基线(这是最难的)，还要知道行盒子的概念，例如x-height,行盒子的baseline；<br>很多奇型八怪的问题都是 父元素 与 行内元素的vertical-align 搞出来的。</p><h2 id="行盒子"><a href="#行盒子" class="headerlink" title="行盒子"></a>行盒子</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>每行文本都会生成一个行盒子。(语出《精通css 高级web标准解决方案》)<br>行盒子主要涉及以下概念：<br>x-height；<br>行盒子的baseline；<br>注意font-size 与 行盒子的关系；<br>半铅空(《精通css 高级web标准解决方案》有讲到)，以下也有讲解；<br>直接上图理解吧，以下三张都是行盒子介绍图：<br><figure class="image-box">                <img src="/image/css/vertical-align/column.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/css/vertical-align/x-height.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/css/vertical-align/inline-box.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="行盒子-与-行内盒子"><a href="#行盒子-与-行内盒子" class="headerlink" title="行盒子 与 行内盒子"></a>行盒子 与 行内盒子</h3><p>span、strong等等这些是行内元素，他们内容以<strong>行内盒子</strong>形式展示，直白的说span 元素就是一个行内盒子；<br>由一行文本形成的水平盒子叫行盒子，行盒子的高度由它所包含的行内盒子决定；<br>以上均语出《css精通》 P43 P44。<br>由上可知，行盒子可以包含很多个行内盒子。当行盒子只有一个行内盒子时，行内盒子就是行盒子。</p><h3 id="x-height"><a href="#x-height" class="headerlink" title="x-height"></a>x-height</h3><p>x-height,也就是上面图片中的x高度，说白点，就是小写字母X的高度；<br>另外一个注意的是，<strong>相同的font-size，相同的字符，在不同的字体font-family中x-height是不同的</strong>，这也就解释了有些字体下，明明文本看起来是居中的，换其他字体可能就看起来不太居中了。<br>上面的例子中，font-size,默认是浏览器的16px，那么x-height值差不多是font-size的三分之一，就是5px左右。</p><h3 id="line-height居中原理"><a href="#line-height居中原理" class="headerlink" title="line-height居中原理"></a>line-height居中原理</h3><p>我们经常会利用将height于line-height设置成一致进行居中，如下，然而，这个原理是什么呢？ 其实它的居中利用的是行盒子上下两个半铅空永远相等得到的,下面会慢慢讲解:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">height: 100%;</span><br><span class="line">line-height: 100%;</span><br></pre></td></tr></table></figure></p><p>我们先看一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.wrap&#123;</span><br><span class="line">    background: #00bcd4b5;</span><br><span class="line">    height: 75px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> &lt;div class=&quot;wrap&quot;&gt;</span><br><span class="line">   经典good morning, koa2!</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>此时wrap内的文字不居中，这个不居中与 “经典good morning, koa2!”这段文本生成的行盒子有莫大关系，<br>根据line-height默认值是1.2，我们可以画出行盒子的line-height,下面是这串代码的效果图和文本行生成的行盒子：<br><figure class="image-box">                <img src="/image/css/vertical-align/line-height.jpg" alt="" title="" class="">                <p></p>            </figure></p><p>其他不变，我们把line-height设置为75px:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.wrap&#123;</span><br><span class="line">    line-height: 75px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>居中了，效果如下：<br><figure class="image-box">                <img src="/image/css/vertical-align/line-height2.jpg" alt="" title="" class="">                <p></p>            </figure><br>由图中可以看出，使用height与line-height相同值达到居中的，其实是利用了行盒子半铅空相等的特性,因为在行盒子内，文本相对于行盒子，永远是居中的，行盒子的高度取决于line-height，如何将line-height的值设成与height一致，就达到了，height高度下的文字居中了。</p><h2 id="父元素与对齐相关的概念"><a href="#父元素与对齐相关的概念" class="headerlink" title="父元素与对齐相关的概念"></a>父元素与对齐相关的概念</h2><p>这里说的父元素，就是上面通篇都在讲的父元素,这个父元素一般就是一个div，div内有文字，有inline-block元素，有img；（img也是一种inline-block），<br>那么这个父元素与行内元素垂直对齐相关的有哪些概念或属性呢，直接上图说明：<br><figure class="image-box">                <img src="/image/css/vertical-align/father.jpg" alt="" title="" class="">                <p></p>            </figure></p><p>为什么这些属性与行内元素垂直对齐相关呢，这都是因为vertical-align,我们说过，vertical-align就是为了行内元素对齐而生而创造的，<br>vertical-align有以下对齐方式，可参考mdn：<br>baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length><br>这些对齐方式就是基于父元素的相关属性。<br>具体信息参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/vertical-align" target="_blank" rel="noopener">mdn</a></length></percentage></p><h2 id="行内元素与对齐相关的概念"><a href="#行内元素与对齐相关的概念" class="headerlink" title="行内元素与对齐相关的概念"></a>行内元素与对齐相关的概念</h2><p>这里的行内元素，包含了inline-block、img元素；<br>行内元素与对齐相关的 是 元素中部、顶部、底部、基线；<br>前三者好理解，只有基线这个不好理解，请参考《如何确定自己的baseline》</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>关于如何划定父元素的baseline，目前就算官方也没有一个很清晰的定义，上文中关于baseline的划定，在参考了很多资料后，很多都基于试验而来,读者请分别好。<br>另外就参考资料而言，mdn里面讲得很好，解释了vertical-align特性，还讲了元素的基线确定。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/vertical-align" target="_blank" rel="noopener">MDN</a><br><a href="https://www.w3schools.com/cssref/pr_pos_vertical-align.asp" target="_blank" rel="noopener">外网w3c</a><br><a href="http://www.ituring.com.cn/book/1910" target="_blank" rel="noopener">精通css 高级web标准解决方案</a></p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> vertical-align </tag>
            
            <tag> baseline </tag>
            
            <tag> 行盒子 </tag>
            
            <tag> x-height </tag>
            
            <tag> line-height </tag>
            
            <tag> 半铅空 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>css之布局</title>
      <link href="/2019/05/21/css_layout/"/>
      <url>/2019/05/21/css_layout/</url>
      
        <content type="html"><![CDATA[<p>我们都知道，定位、浮动、flexbox，这些可以用来布局；<br>我们也知道什么固定布局，流式布局等等，这些也是布局；<br>那么定位、浮动这些是什么布局呢，是固定布局吗?<br>都不是，所以固定布局、弹性布局、流式布局，这些更代表了一种布局的设计思想，一种布局方案，<br>而定位、浮动、flexbox这些是一种布局的技术手段。<br>我们大可这样理解：<br>布局的设计方式有 固定设计方式、弹性设计方式、流式设计方式、响应式设计方式;<br>布局的技术方法(手段)有 定位、浮动、flexbox、百分比；</p><h2 id="布局的技术手段"><a href="#布局的技术手段" class="headerlink" title="布局的技术手段"></a>布局的技术手段</h2><h3 id="优先使用flexbox，减少使用定位和浮动布局"><a href="#优先使用flexbox，减少使用定位和浮动布局" class="headerlink" title="优先使用flexbox，减少使用定位和浮动布局"></a>优先使用flexbox，减少使用定位和浮动布局</h3><p>布局的技术手段有：定位(绝对定位、固定定位)、浮动、flexbox。<br>在这些技术手段中，绝对定位、浮动这些已经是比较老的技术手段了，而且flexbox能够轻松实现浮动或绝对定位。<br>因为遇到布局时推荐优先使用新的布局方法 flexbox。</p><h3 id="display：gird"><a href="#display：gird" class="headerlink" title="display：gird"></a>display：gird</h3><p>gird是最新的一种布局方式，可能在未来对目前的布局带来非常大的影响。</p><h2 id="布局设计方式"><a href="#布局设计方式" class="headerlink" title="布局设计方式"></a>布局设计方式</h2><h3 id="布局方式介绍"><a href="#布局方式介绍" class="headerlink" title="布局方式介绍"></a>布局方式介绍</h3><p>参考《精通css》P177<br><strong>固定布局</strong> 使用px布局；<br><strong>弹性布局</strong> 使用em作为布局元素的尺寸。(不是用em来作为font-size或margin、padding哦)<br><strong>流式布局</strong> 使用百分比布局，浏览器默认布局方式，也是主流布局方式。为什么说是主体布局方式了，因为响应式布局基本上基于流式布局。<br><strong>响应式布局</strong> 基于流式布局，利用媒体查询等手段进行响应自适应，本质上响应式布局也是流式布局。《精通css》P207中，直接将响应式布局描述为：可以适配不同视口大小的流式布局。</p><p>有人说只要使用了em或者rem的就是一种弹性布局，这可能不太准确，笔记使用em来定义font-size或margin、padding等等是常识，使用rem来定义font-size等等，这些都是常识，可以说就是应该这样做的。所以如果使用rem或em做以上事情，就不应该是弹性布局。<br>只有使用em作为元素的宽高尺寸了，那才说明用了弹性布局。</p><h3 id="响应式布局是当前最推荐方式"><a href="#响应式布局是当前最推荐方式" class="headerlink" title="响应式布局是当前最推荐方式"></a>响应式布局是当前最推荐方式</h3><p>上面几种布局中，当有最推荐和最重要的是响应式布局，(又称为 响应式web布局设计)。</p><h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3><p>响应式布局主体用的还是流式布局，在此基础上，主要使用媒体查询进行响应设计，另外也使用了flexbox进行响应设计。</p><h4 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h4><p>自行网上查看。</p><h4 id="flexbox"><a href="#flexbox" class="headerlink" title="flexbox"></a>flexbox</h4><p>flexbox也是css中具有某种响应式特质的规范，无须使用媒体查询，flexbox本身就可以创建出能够有效利用空间的适配布局。<br>为什么说flexbox具备某种响应式特质呢，比如父级定义为flex，自己都会随着父级的变大而变大，缩小而缩小，这跟子级定义百分比，随父级增大而增大，缩小而缩小一样。说明了flexbox有浓烈的流式特性，流式特性是响应式布局的重要体现。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>媒体查询虽然是基于视口的创建响应式布局的主打方式，但它也有弊端，响应式布局同时要结合flexbox一起使用，才能做出更好的响应式布局。参考《精通css》P227。</p><p>另外，要做出一个好的响应式设计布局，其实是结合了固定、弹性、流式布局，以流式布局为主体，辅以弹性布局常用的em和rem来设计margin\font-size\padding等等，再辅以固定布局常用到的px来定义必要的元素。(这一段是个人见解，可能不太准确，笔记只有利用em来定义元素的宽高而非margin\font-size\padding才算弹性布局，只有利用px来定义布局元素的宽高才算固定范畴，因此这里所说的可能并非结合了固定和弹性布局，而是使用了固定、弹性布局常用的手段–px和em，即固定常用px，弹性常用em)</p><h2 id="flexbox-1"><a href="#flexbox-1" class="headerlink" title="flexbox"></a>flexbox</h2><p>参看《flex布局不是布局设计模式》《响应式布局是当前最推荐方式 —flexbox》《布局的技术手段》</p><h3 id="flex布局不是布局设计模式"><a href="#flex布局不是布局设计模式" class="headerlink" title="flex布局不是布局设计模式"></a>flex布局不是布局设计模式</h3><p>参考文首开头的分析，flex布局或flexbox并不是一种布局的设计模式，它不隶属任何一种布局设计方式，它只是一种布局技术手段而已。<br>它可以被运用于 固定、弹性、响应式布局当中。</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 布局的技术手段 </tag>
            
            <tag> 响应式布局(设计) </tag>
            
            <tag> 固定布局(设计) </tag>
            
            <tag> 弹性布局(设计) </tag>
            
            <tag> 流动布局(设计) </tag>
            
            <tag> 媒体查询 </tag>
            
            <tag> flex </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo笔记</title>
      <link href="/2019/05/21/hexo/"/>
      <url>/2019/05/21/hexo/</url>
      
        <content type="html"><![CDATA[<h2 id="hexo-常用知识"><a href="#hexo-常用知识" class="headerlink" title="hexo 常用知识"></a>hexo 常用知识</h2><h3 id="public目录"><a href="#public目录" class="headerlink" title="public目录"></a>public目录</h3><p>根目录执行hexo g 命令，会在根目录下生成一个public/ 文件夹，<br>hexo g是一个编译源码的命令，编译后的源码，可以直接供GitHub网址生成博客。<br>因此public/ 文件夹是用来将源码上传到github上，供github生成博客的。</p><h3 id="常用hexo命令"><a href="#常用hexo命令" class="headerlink" title="常用hexo命令"></a>常用hexo命令</h3><h4 id="启动本地服务，看博客效果"><a href="#启动本地服务，看博客效果" class="headerlink" title="启动本地服务，看博客效果"></a>启动本地服务，看博客效果</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><h4 id="发布到GitHub"><a href="#发布到GitHub" class="headerlink" title="发布到GitHub"></a>发布到GitHub</h4><p>将git仓库放在public中，每次需要发布时，根目录下执行hexo g，然后在public目录下 git push;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure></p><h4 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h4><p>hexo d 并不会删除publc目录的.git文件夹，只会增量叠加。 –目前没有用过；<br>注意，不要执行hexo clean，它会删除public目录</p><h3 id="写的文章放在哪里与-posts目录"><a href="#写的文章放在哪里与-posts目录" class="headerlink" title="写的文章放在哪里与_posts目录"></a>写的文章放在哪里与_posts目录</h3><p>YeWills.github.io/source/_posts/<br>所有的文章都放置于_posts目录下。</p><h3 id="创建tag与categories相关事情"><a href="#创建tag与categories相关事情" class="headerlink" title="创建tag与categories相关事情"></a>创建tag与categories相关事情</h3><p>二者配置一样，以categories为例：<br>hexo new page categories<br>生成目录和文件：<br>YeWills.github.io/source/categories/index.md<br>修改index.md元数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">layout: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>同时修改<br>YeWills.github.io/scaffolds/draft.md<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">tags: &#123;&#123; tags &#125;&#125;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>YeWills.github.io/scaffolds/page.md<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>YeWills.github.io/scaffolds/post.md<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags: &#123;&#123; tags &#125;&#125;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>如此便可以配置出categories的all或全部 的选项卡内容，如果没有以上步骤，也可以生成categories，但无法生产categories的all或全部 的选项卡内容；<br>且点击本主题左侧菜单栏categories会报404错误。</p><p>这一步的配置内容，可看commit 哈希值 cbb06710ce7a40ade93</p><h3 id="categories、tags两种配置方式"><a href="#categories、tags两种配置方式" class="headerlink" title="categories、tags两种配置方式"></a>categories、tags两种配置方式</h3><p>categories:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 推荐使用方法 method one,双横杠方式，可以配置多级，</span><br><span class="line">categories: </span><br><span class="line">- react</span><br><span class="line">- react读书笔记</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// method two,只能配置一个值</span><br><span class="line">categories: &quot;react&quot;</span><br></pre></td></tr></table></figure><p>tags:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// method one</span><br><span class="line">tags:[react, react读书笔记]</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// method two,只能配置一个值</span><br><span class="line">tags: react</span><br></pre></td></tr></table></figure><h3 id="博客菜单栏左侧内容修改"><a href="#博客菜单栏左侧内容修改" class="headerlink" title="博客菜单栏左侧内容修改"></a>博客菜单栏左侧内容修改</h3><p>比如修改qq号码，名字，git地址，都可在这里修改YeWills.github.io/themes/mellow/_config.yml</p><h3 id="博客菜单栏左侧菜单增减"><a href="#博客菜单栏左侧菜单增减" class="headerlink" title="博客菜单栏左侧菜单增减"></a>博客菜单栏左侧菜单增减</h3><p>比如修改qq号码，名字，git地址，都可在这里修改YeWills.github.io/themes/mellow/_config.yml<br>修改改文件的menu部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home:</span><br><span class="line">    text: HOME</span><br><span class="line">    url: /</span><br><span class="line">    icon: home</span><br><span class="line">  th-list:</span><br><span class="line">    text: CATEGORIES</span><br><span class="line">    url: /categories</span><br><span class="line">    icon: th-list</span><br><span class="line">  tags:</span><br><span class="line">    text: TAGS</span><br><span class="line">    url: /tags</span><br><span class="line">    icon: tags</span><br><span class="line">  archives:</span><br><span class="line">    text: ARCHIVES</span><br><span class="line">    url: /archives</span><br><span class="line">    icon: archives</span><br></pre></td></tr></table></figure></p><p>如上，menu.th-list配置的是categories目录</p><h2 id="hexo-黑知识"><a href="#hexo-黑知识" class="headerlink" title="hexo 黑知识"></a>hexo 黑知识</h2><h3 id="loading三级标题的编译异常"><a href="#loading三级标题的编译异常" class="headerlink" title="loading三级标题的编译异常"></a>loading三级标题的编译异常</h3><p>给三级标题名只有单独的 一个 loading 字时，hexo编译出来的目录可能会异常：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//这个会异常</span><br><span class="line">### loading</span><br></pre></td></tr></table></figure></p><p>解决之道是在标题不定义为单独的loading，加点字就行如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//这个正常</span><br><span class="line">### 有关loading</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>html笔记</title>
      <link href="/2019/05/21/html/"/>
      <url>/2019/05/21/html/</url>
      
        <content type="html"><![CDATA[<h2 id="html知识"><a href="#html知识" class="headerlink" title="html知识"></a>html知识</h2><h3 id="html语义化"><a href="#html语义化" class="headerlink" title="html语义化"></a>html语义化</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>js有语义化，html也有语义化，<br>HTML的语义化强调不要都使用div，建议使用header\footer\nav\section\input num\input email…..</p><h4 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h4><h5 id="利于阅读；"><a href="#利于阅读；" class="headerlink" title="利于阅读；"></a>利于阅读；</h5><h5 id="利于seo"><a href="#利于seo" class="headerlink" title="利于seo"></a>利于seo</h5><h5 id="响应不同移动端弹框键盘"><a href="#响应不同移动端弹框键盘" class="headerlink" title="响应不同移动端弹框键盘"></a>响应不同移动端弹框键盘</h5><p>移动设备会根据不同的input 如何number、email、text、password；弹出不同的键盘，这是很多移动开发使用input语义化编写的重要原因。</p><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><h3 id="input与form"><a href="#input与form" class="headerlink" title="input与form"></a>input与form</h3><h4 id="name-与-form-结合"><a href="#name-与-form-结合" class="headerlink" title="name 与 form 结合"></a>name 与 form 结合</h4><p>name配合submit，再结合form的action使用。<br>点击下面的submit后，浏览器跳转url到 /submit.action?firstname=Mickey&amp;lastname=Mouse<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;/submit.action&quot;&gt;</span><br><span class="line">     &lt;input type=&quot;text&quot; name=&quot;firstname&quot; value=&quot;Mickey&quot;&gt;</span><br><span class="line">     &lt;input type=&quot;text&quot; name=&quot;lastname&quot; value=&quot;Mouse&quot;&gt;</span><br><span class="line">     &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;</span><br><span class="line"> &lt;/form&gt;</span><br></pre></td></tr></table></figure></p><h2 id="HTML5属性"><a href="#HTML5属性" class="headerlink" title="HTML5属性"></a>HTML5属性</h2><h3 id="tabindex"><a href="#tabindex" class="headerlink" title="tabindex"></a>tabindex</h3><p>tabindex 是html5属性 ，非常好用， 指示其元素是否可以聚焦,<br>在html4中，不是每个标签都拥有focus属性，在html5中，通过tabindex，每个标签都可以定义focus属性。<br>比如input text，可直接在input元素定义onfocus，在任意的div中，要想使用onfocus等，定义tabindex就可使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div tabindex=&quot;0&quot;&gt;Tabbable due to tabindex.&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h3 id="FormData-与-FileReader"><a href="#FormData-与-FileReader" class="headerlink" title="FormData 与 FileReader"></a>FormData 与 FileReader</h3><p>FormData 将数据表单序列化以便得到可以作为请求的参数;<br>FileReader 读取文件，比如实现图片预览；<br>详细参考《文件上传-file和drap拖拽两种方式》</p><h3 id="blob"><a href="#blob" class="headerlink" title="blob"></a>blob</h3><p>blob想象起来复制，其实也简单，目前对于blob无非就是文件下载或者是图片展示两种运用。<br><a href="https://github.com/YeWills/koa-demo/tree/response-file" target="_blank" rel="noopener">参考demo</a></p><h4 id="blob-与-FileReader"><a href="#blob-与-FileReader" class="headerlink" title="blob 与 FileReader"></a>blob 与 FileReader</h4><p>FileReader是能够操作blob的两种方式之一</p><h4 id="blob-与-window-URL-createObjectURL"><a href="#blob-与-window-URL-createObjectURL" class="headerlink" title="blob 与 window.URL.createObjectURL"></a>blob 与 window.URL.createObjectURL</h4><p>window.URL是能够操作blob的两种方式之一</p><h2 id="应用demo"><a href="#应用demo" class="headerlink" title="应用demo"></a>应用demo</h2><h3 id="文件上传-file和drap拖拽两种方式"><a href="#文件上传-file和drap拖拽两种方式" class="headerlink" title="文件上传-file和drap拖拽两种方式"></a>文件上传-file和drap拖拽两种方式</h3><p><a href="https://github.com/YeWills/file-upload" target="_blank" rel="noopener">详细参考demo</a></p><h4 id="type-text-input-获取file的三种方式："><a href="#type-text-input-获取file的三种方式：" class="headerlink" title="type=text input 获取file的三种方式："></a>type=text input 获取file的三种方式：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//dom元素直接获取</span><br><span class="line"> document.getElementById(&quot;chooseFile&quot;).files[0];</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//change事件</span><br><span class="line">  var file = document.querySelector(&apos;#file&apos;);</span><br><span class="line">  file.addEventListener(&apos;change&apos;, previewImage, false);</span><br><span class="line">  function previewImage(event) &#123;</span><br><span class="line">      event.target.files[0]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//formData 方式</span><br><span class="line">&lt;form enctype=&quot;multipart/form-data&quot; method=&quot;post&quot; name=&quot;fileinfo&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;file&quot; name=&quot;fileName&quot; required /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">var form = document.forms.namedItem(&quot;fileinfo&quot;);</span><br><span class="line">var oData = new FormData(form);</span><br><span class="line">var file = oData.get(&apos;fileName&apos;)</span><br></pre></td></tr></table></figure><h4 id="drag-获取file方式："><a href="#drag-获取file方式：" class="headerlink" title="drag 获取file方式："></a>drag 获取file方式：</h4><p>参考：drap_file\dragInfo.html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">evt.dataTransfer.files</span><br></pre></td></tr></table></figure></p><h4 id="上传过程："><a href="#上传过程：" class="headerlink" title="上传过程："></a>上传过程：</h4><p>选择文件、预览、上传到服务器、服务器上传进度、服务器上传成功</p><h4 id="FormData与文件上传"><a href="#FormData与文件上传" class="headerlink" title="FormData与文件上传"></a>FormData与文件上传</h4><p>文件上传必须要使用FormData对文件流进行表单序列化，这样才可以被服务器端解析。<br>下面是三种服务器端上传图片的示例，每种示例都使用了formData进行文件流表格序列化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var formData = new FormData();</span><br><span class="line">formData.append(&apos;test-upload&apos;, file.files[0]);</span><br><span class="line">xhr.upload.onprogress = setProgress;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let file = document.getElementById(&quot;chooseFile&quot;).files[0];</span><br><span class="line">let formData = new FormData();</span><br><span class="line">formData.append(&quot;avatar&quot;, file);</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    type: &apos;POST&apos;,</span><br><span class="line">    url: &apos;/profile&apos;,</span><br><span class="line">    data: formData,</span><br><span class="line">    async: false,</span><br><span class="line">    cache: false,</span><br><span class="line">    contentType: false,</span><br><span class="line">    processData: false,</span><br><span class="line">    success: function (data) &#123;</span><br><span class="line">        $(&quot;.newImg&quot;).attr(&quot;src&quot;, data.filePath);</span><br><span class="line">    &#125;,</span><br><span class="line">    error: function (err) &#123;</span><br><span class="line">        console.log(err.message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method=&apos;post&apos; action=&apos;/profile&apos; enctype=&apos;multipart/form-data&apos;&gt;</span><br><span class="line">   选择图片：&lt;input name=&quot;avatar&quot; id=&apos;upfile&apos; type=&apos;file&apos;/&gt;</span><br><span class="line">   &lt;input type=&apos;submit&apos; value=&apos;提交&apos;/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><h4 id="multer与文件上传"><a href="#multer与文件上传" class="headerlink" title="multer与文件上传"></a>multer与文件上传</h4><p>express，收到前台的上传请求后，因为上传文件的请求时一个多类型文件数据(multipart/form-data)请求，<br>必须通过require(‘multer’)才能正常处理这样的请求。<br>multer就是为了 处理多文件接口而生。</p><h4 id="上传技术说明"><a href="#上传技术说明" class="headerlink" title="上传技术说明"></a>上传技术说明</h4><p>FileReader 实现图片预览<br>通过FormData将file表格序列化，这样才能被post框架接收为参数，传给后台，并被后台识别；<br>上传的进度条和成功处理通过post框架的相关事件做：<br>以原生为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xhr.onload = uploadSuccess; //成功处理</span><br><span class="line">xhr.upload.onprogress = setProgress;  //进度处理</span><br></pre></td></tr></table></figure></p><p>后台express，收到前台的上传请求后，通过中间件multer处理后，通过fs读取数据，并将上传的文件存到指定文件夹(/uploads)，整个上传过程结束。</p><h4 id="其他技术点"><a href="#其他技术点" class="headerlink" title="其他技术点"></a>其他技术点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dragenter</span><br><span class="line">dragover</span><br><span class="line">dragleave</span><br><span class="line">drop</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> html </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html5 </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js笔记</title>
      <link href="/2019/05/21/js/"/>
      <url>/2019/05/21/js/</url>
      
        <content type="html"><![CDATA[<h2 id="js-常用知识"><a href="#js-常用知识" class="headerlink" title="js 常用知识"></a>js 常用知识</h2><h3 id="自运行函数"><a href="#自运行函数" class="headerlink" title="自运行函数"></a>自运行函数</h3><h4 id="自运行函数的17种写法"><a href="#自运行函数的17种写法" class="headerlink" title="自运行函数的17种写法"></a>自运行函数的17种写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">( function() &#123;&#125;() );</span><br><span class="line">( function() &#123;&#125; )();</span><br><span class="line">[ function() &#123;&#125;() ];</span><br><span class="line"></span><br><span class="line">~ function() &#123;&#125;();</span><br><span class="line">! function() &#123;&#125;();</span><br><span class="line">+ function() &#123;&#125;();</span><br><span class="line">- function() &#123;&#125;();</span><br><span class="line"></span><br><span class="line">delete function() &#123;&#125;();</span><br><span class="line">typeof function() &#123;&#125;();</span><br><span class="line">void function() &#123;&#125;();</span><br><span class="line">new function() &#123;&#125;();</span><br><span class="line">new function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">var f = function() &#123;&#125;();</span><br><span class="line"></span><br><span class="line">1, function() &#123;&#125;();</span><br><span class="line">1 ^ function() &#123;&#125;();</span><br><span class="line">1 &gt; function() &#123;&#125;();</span><br><span class="line"></span><br><span class="line">;( function() &#123;&#125;() );</span><br></pre></td></tr></table></figure><h4 id="函数表达式-和-函数声明"><a href="#函数表达式-和-函数声明" class="headerlink" title="函数表达式 和 函数声明"></a>函数表达式 和 函数声明</h4><p>要弄懂自运行函数的原理，需弄懂函数表达式 和 函数声明概念；<br>函数声明，也叫函数定义；<br><a href="https://www.cnblogs.com/lenther2002/p/5894964.html" target="_blank" rel="noopener">参考</a><br>Javascript中有2个语法都与function关键字有关，分别是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">函数声明：function FunctionName(FormalParameterList) &#123; FunctionBody &#125;</span><br><span class="line">函数表达式：function [FunctionName](FormalParameterList) &#123; FunctionBody &#125;</span><br></pre></td></tr></table></figure></p><p>从语法的定义上看，这两者几乎是一模一样的（唯一的区别是函数表达式可以省略函数名称），那么就解释器而言，当遇到这个结构的语句时，判定为函数表达式还是函数定义呢？<br>就javascript的语法而言，如果一条语句是以function关键字开始，那么这段会被判定为函数定义(声明)；<br>如果不是以function关键字开始，那么就是函数表达式；</p><p><strong>为什么要分清 函数表达式和函数声明呢?</strong><br>因为<a href="https://www.zhihu.com/question/20249179" target="_blank" rel="noopener">函数表达式是不能拿来直接用的</a>，必须在<strong>左侧</strong>有字符或表达式与这个函数表达式共同构成一句可执行的函数语句；<br>（之所以在左侧，不是右侧，是因为在不要行函数语句以关键字function开始，避免被识别为函数声明，导致报错）<br>函数声明是可以拿过来直接用；<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function fn()&#123;&#125;</span><br><span class="line">fn()//不报错；</span><br><span class="line">function ()&#123;&#125;() //报错</span><br><span class="line">-function ()&#123;console.log(5)&#125;() //不报错 因为在funtion左侧有表达式-</span><br></pre></td></tr></table></figure></p><h4 id="16种含函数表达式的不报错的函数语句"><a href="#16种含函数表达式的不报错的函数语句" class="headerlink" title="16种含函数表达式的不报错的函数语句"></a>16种含函数表达式的不报错的函数语句</h4><p>结合上节的知识，将《自运行函数的17种写法》整理下，以下17种包含了函数表达式的函数语句不报错,注意的是，<br>以下函数表达式内的函数体都将不会执行，至于如何执行，下面会讲。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">( function() &#123;&#125; );</span><br><span class="line">( function() &#123;&#125; );</span><br><span class="line">[ function() &#123;&#125; ];</span><br><span class="line"></span><br><span class="line">~ function() &#123;&#125;;</span><br><span class="line">! function() &#123;&#125;;</span><br><span class="line">+ function() &#123;&#125;;</span><br><span class="line">- function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">delete function() &#123;&#125;;</span><br><span class="line">typeof function() &#123;&#125;;</span><br><span class="line">void function() &#123;&#125;;</span><br><span class="line">new function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">var f = function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">1, function() &#123;&#125;;</span><br><span class="line">1 ^ function() &#123;&#125;;</span><br><span class="line">1 &gt; function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">;( function() &#123;&#125; );</span><br></pre></td></tr></table></figure><h4 id="是否以function开始对js解释器很重要"><a href="#是否以function开始对js解释器很重要" class="headerlink" title="是否以function开始对js解释器很重要"></a>是否以function开始对js解释器很重要</h4><p><a href="https://www.zhihu.com/question/20249179" target="_blank" rel="noopener">参考</a><br>以下两种报错形式的原因分析：</p><ul><li>function (){ }()<br>期望是立即调用一个匿名函数表达式，结果是进行了函数声明，函数声明必须要有标识符做为函数名称。</li><li>function g(){ }()<br>期望是立即调用一个具名函数表达式，结果是声明了函数 g。末尾的括号作为分组运算符，<strong>必须要提供表达式做为参数</strong>，这个表达式可以是一个值或一个语句，例如改成下面的就不会报错：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function g()&#123; &#125;(1) //不报错，因为末尾的小括号有值作为表达式</span><br><span class="line">function g()&#123; &#125;(1,2) //不报错</span><br></pre></td></tr></table></figure></li></ul><p>以上说明了，是否以function开始对js解释器很重要;<br>如果以function开始，js解释器会认为它是一个函数声明，此时就要符合函数声明的标准，否则报错；<br>如果function左侧还有表达式，js解释器会认为它是一个函数表达式，此时该函数表达式配合左右两侧的表达式就构成了一个函数语句,要符合函数语句标准；<br>（例如 var a = function(){} 这就是一条函数语句）</p><h4 id="1种立即执行的函数声明形式"><a href="#1种立即执行的函数声明形式" class="headerlink" title="1种立即执行的函数声明形式"></a>1种立即执行的函数声明形式</h4><p>目前知道的，可以让函数声明内的函数体立即执行的只有这种方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function g(a)&#123;console.log(a) &#125;(1) //不报错</span><br></pre></td></tr></table></figure></p><p>注意，末尾小括号一定要有 表达式，原因查看《是否以function开始对js解释器很重要》<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function g(a)&#123;console.log(a) &#125;() //报错</span><br></pre></td></tr></table></figure></p><h4 id="如何让函数表达式、声明内的函数体立即执行"><a href="#如何让函数表达式、声明内的函数体立即执行" class="headerlink" title="如何让函数表达式、声明内的函数体立即执行"></a>如何让函数表达式、声明内的函数体立即执行</h4><p>如何让 函数表达式和函数声明 内的函数体立即执行呢；<br><strong>只能</strong>通过小括号();<br>例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = function()&#123;console.log(&apos;work&apos;)&#125; //不打印</span><br><span class="line">var a = function()&#123;console.log(&apos;work&apos;)&#125;() //打印work</span><br></pre></td></tr></table></figure></p><p>因此可以认为()是一个让立即执行的运算符，可以让函数表达式或函数声明内的函数体立即执行；</p><h4 id="函数表达式、声明-与-立即执行-关系"><a href="#函数表达式、声明-与-立即执行-关系" class="headerlink" title="函数表达式、声明 与 立即执行 关系"></a>函数表达式、声明 与 立即执行 关系</h4><p>参看上面的《如何让函数表达式、声明内的函数体立即执行》</p><h4 id="与-立即执行"><a href="#与-立即执行" class="headerlink" title="() 与 立即执行"></a>() 与 立即执行</h4><p>参看上面的《如何让函数表达式、声明内的函数体立即执行》</p><h4 id="放在哪些位置可以让函数体立即执行"><a href="#放在哪些位置可以让函数体立即执行" class="headerlink" title="()放在哪些位置可以让函数体立即执行"></a>()放在哪些位置可以让函数体立即执行</h4><p>一般而言，() 紧跟在 function(){} 的花括号后面的位置，通过这样的方式让函数表达式或函数声明 内的函数体立刻执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = function()&#123;console.log(&apos;work&apos;)&#125;()</span><br><span class="line">~ function() &#123;&#125;()</span><br><span class="line">( function() &#123;&#125;() )</span><br><span class="line">function fn(t)&#123;console.log(t)&#125;(&apos;work&apos;)</span><br></pre></td></tr></table></figure></p><p>不过有个例外，请看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">( function() &#123;&#125;() ); //可以立即执行函数体</span><br><span class="line">( function() &#123;&#125; )(); //()放在了左侧(  )的右侧，不过也可以立即执行函数体</span><br></pre></td></tr></table></figure></p><p>()紧跟在中括号后就不行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ function() &#123;&#125;()]; //不报错，这个函数语句其实就是一个数组</span><br><span class="line">[ function() &#123;&#125;](); //报错，因为[]是一个数组，数组不是方法，类似这种写法，都错：[]()</span><br></pre></td></tr></table></figure></p><p><strong>小结，从目前看，小括号一般紧跟如上的花括号，也可跟在如上的 (  )后面。</strong>现在再回过头，看这《自运行函数的17种写法》应该就明白了吧</p><h4 id="与-函数传参"><a href="#与-函数传参" class="headerlink" title="() 与 函数传参"></a>() 与 函数传参</h4><p>这个简单，不多介绍，一般自运行传参的方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( function(a) &#123;console.log(a)&#125; )(888) //888</span><br></pre></td></tr></table></figure></p><p>注意的是，将()写在里面也是可以传参的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( function(a) &#123;console.log(a)&#125;(888) ) //888</span><br></pre></td></tr></table></figure></p><h4 id="分号-与-立即执行"><a href="#分号-与-立即执行" class="headerlink" title="分号 ; 与 立即执行"></a>分号 ; 与 立即执行</h4><p>有些人喜欢用分号;来配合函数表达式写一个自运行，;分号本来是用来给函数语句断句的；<br>所以用这个的好处就是自带断句功能，避免不必要的错误；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//会报错</span><br><span class="line">var f = function() &#123;&#125;;</span><br><span class="line">f()</span><br><span class="line">( function() &#123;&#125; )();</span><br></pre></td></tr></table></figure></p><p>加分号;后不报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//会报错</span><br><span class="line">var f = function() &#123;&#125;;</span><br><span class="line">f()</span><br><span class="line">;( function() &#123;&#125; )();</span><br></pre></td></tr></table></figure></p><h4 id="，-，！比（-）立即执行方式少一个字符"><a href="#，-，！比（-）立即执行方式少一个字符" class="headerlink" title="+，-，！比（ ）立即执行方式少一个字符"></a>+，-，！比（ ）立即执行方式少一个字符</h4><p>通过+，-，！这三个符号运行的匿名函数比（）运行的匿名函数可以减少一个字符的使用<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">( function() &#123;&#125; );</span><br><span class="line">~ function() &#123;&#125;;</span><br></pre></td></tr></table></figure></p><p>不过这不影响使用(  )还是+，-，！ 配合使用函数表达式，这里只是提取这个现象出来。</p><h4 id="难点立即执行的demo分析"><a href="#难点立即执行的demo分析" class="headerlink" title="难点立即执行的demo分析"></a>难点立即执行的demo分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new(function P()&#123;console.log(1)&#125;)()</span><br></pre></td></tr></table></figure><p>以上相当于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new (function P()&#123;console.log(1)&#125;)()</span><br></pre></td></tr></table></figure></p><p>左侧是new表达式，右侧是一个立即执行的函数；<br>右侧立即执行的函数其实就是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function P()&#123;console.log(1)&#125;</span><br><span class="line">P()</span><br></pre></td></tr></table></figure></p><p>所以以上相当于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function P()&#123;console.log(1)&#125;</span><br><span class="line">new P()</span><br></pre></td></tr></table></figure></p><p>问题：为什么new(function() {})()，new可以与()紧挨着，不用空格；<br>因为(function() {})()是一个函数表达式语句，可以挨着，也可以不挨着，都不会报错<br>你把new当成+ - ！ ~来看，就好理解了；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ function() &#123;&#125;; //不紧挨着，不报错</span><br><span class="line">~function() &#123;&#125;; //紧挨着，不报错</span><br></pre></td></tr></table></figure></p><h4 id="重要运用之一"><a href="#重要运用之一" class="headerlink" title="重要运用之一"></a>重要运用之一</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var map = document.querySelector(&apos;#id&apos;)</span><br><span class="line">map.style.height=&apos;600px&apos;;</span><br></pre></td></tr></table></figure><p>相比之下，下面的写法，map变成块级变量，不再污染全局作用域。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">;(function()&#123;</span><br><span class="line">    var map = document.querySelector(&apos;#id&apos;)</span><br><span class="line">    map.style.height=&apos;600px&apos;;</span><br><span class="line">     &#125;())</span><br></pre></td></tr></table></figure></p><h4 id="自运行-参考资料"><a href="#自运行-参考资料" class="headerlink" title="自运行 参考资料"></a>自运行 参考资料</h4><p><a href="http://www.softwhy.com/article-2022-1.html" target="_blank" rel="noopener">JavaScript 小括号()分组运算符</a><br><a href="https://www.cnblogs.com/lenther2002/p/5894964.html" target="_blank" rel="noopener">JS中函数定义和函数表达式的区别</a><br><a href="https://www.zhihu.com/question/20249179" target="_blank" rel="noopener">JavaScript 匿名函数有哪几种执行方式?</a></p><h3 id="js规范写法"><a href="#js规范写法" class="headerlink" title="js规范写法"></a>js规范写法</h3><h4 id="给常量起个名"><a href="#给常量起个名" class="headerlink" title="给常量起个名"></a>给常量起个名</h4><p>必要的时候，给常量起个名，可读性更强<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">car.handle(&apos;seller&apos;,&apos;sell&apos;,5,true);</span><br></pre></td></tr></table></figure></p><p>修改后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var carType = &apos;seller&apos;;</span><br><span class="line">var carName = &apos;sell&apos;;</span><br><span class="line">var sellNum = 5;</span><br><span class="line">var isNeedLoan = true;</span><br><span class="line">car.handle(carType,carName,sellNum,isNeedLoan);</span><br></pre></td></tr></table></figure></p><h2 id="页面优化"><a href="#页面优化" class="headerlink" title="页面优化"></a>页面优化</h2><h3 id="把css写成内联"><a href="#把css写成内联" class="headerlink" title="把css写成内联"></a>把css写成内联</h3><p>css只有10或20k时，写成内联，谷歌和百度和淘宝pc版都是这样干的。<br>放在内联上，最大的好处是节省了一次cdn请求,从而加快页面响应。<br>注意只适合css不是非常大的情况。</p><h3 id="压缩与缓存"><a href="#压缩与缓存" class="headerlink" title="压缩与缓存"></a>压缩与缓存</h3><p>gzip压缩\cache-control\last-modified\if-Modified-Since\etag\if-None-Match<br>参考《高效前端》P72</p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自运行函数写法形式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>css笔记</title>
      <link href="/2019/05/21/css/"/>
      <url>/2019/05/21/css/</url>
      
        <content type="html"><![CDATA[<p>最近对从业以来的css知识从新梳理，整理成四篇博客，除本篇博客外，还有：<br><a href="http://127.0.0.1:4000/2019/04/06/css_vertical_align/" target="_blank" rel="noopener">《vertical-align、行盒子、baseline》</a><br><a href="http://127.0.0.1:4000/2019/04/13/css_mobile/" target="_blank" rel="noopener">《css之移动开发》</a><br><a href="http://127.0.0.1:4000/2019/04/14/css_layout/" target="_blank" rel="noopener">《css之布局》</a></p><h2 id="css需求方案"><a href="#css需求方案" class="headerlink" title="css需求方案"></a>css需求方案</h2><h3 id="三角"><a href="#三角" class="headerlink" title="三角"></a>三角</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;triangle&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.triangle&#123;</span><br><span class="line">  height: 0;</span><br><span class="line">  width: 0;</span><br><span class="line">  border: 40px solid;</span><br><span class="line">  border-color: red #00ff37 #1b00ff #673AB7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下,边框的四边并非我们想象的四个矩形，而是四个三角形：<br><figure class="image-box">                <img src="/image/css/block.jpg" alt="" title="" class="">                <p></p>            </figure></p><p>border-color可以接受透明色：transparent</p><p>将上面代码的border-color改成如下，即可得到一个三角：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border-color: transparent transparent #1b00ff transparent;</span><br></pre></td></tr></table></figure></p><figure class="image-box">                <img src="/image/css/triangle.jpg" alt="" title="" class="">                <p></p>            </figure><h3 id="阴影box-shadow"><a href="#阴影box-shadow" class="headerlink" title="阴影box-shadow"></a>阴影box-shadow</h3><h4 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h4><p>box-shadow: none|h-offset v-offset blur spread color |inset|initial|inherit;<br>            是否需要阴影|竖直偏移 水平偏移 模糊度 扩展度 颜色|方向|基本不用|基本不用<br>模糊度 其实就是对阴影的边缘进行模糊处理，让阴影与外界颜色过渡自然；<br>扩展度 在阴影的基础上，对阴影进行等长度加长，如图。<br><figure class="image-box">                <img src="/image/css/shadow6.jpg" alt="" title="" class="">                <p></p>            </figure></p><p>方向 阴影默认向外扩散，可以设置向内；<br>下面通过一组图片展示每项参数意义：<br><figure class="image-box">                <img src="/image/css/shadow1.jpg" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/css/shadow2.jpg" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/css/shadow3.jpg" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/css/shadow4.jpg" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/css/shadow5.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="竖直、水平偏移都设置为0"><a href="#竖直、水平偏移都设置为0" class="headerlink" title="竖直、水平偏移都设置为0"></a>竖直、水平偏移都设置为0</h4><p>二者都设置为0，可以达到outline的效果，并且还有模糊度<br><figure class="image-box">                <img src="/image/css/shadow7.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="多个阴影"><a href="#多个阴影" class="headerlink" title="多个阴影"></a>多个阴影</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">height: 80px;</span><br><span class="line">width: 180px;</span><br><span class="line">background: gainsboro;</span><br><span class="line">box-shadow: 5px 5px blue, 10px 10px red, 15px 15px green;</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="/image/css/shadow8.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="box-shadow脱离文档流"><a href="#box-shadow脱离文档流" class="headerlink" title="box-shadow脱离文档流"></a>box-shadow脱离文档流</h4><p>box-shadow 是脱离文档流的，给元素设置box-shadow，无论数值多少，都不会让元素移动，这点很好</p><h4 id="box-shadow-与-filter"><a href="#box-shadow-与-filter" class="headerlink" title="box-shadow 与 filter"></a>box-shadow 与 filter</h4><p>filter也可以用来写一个阴影效果。filter还有其他很多功能。<br>以下两个写法，都可以达到元素阴影的效果，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">filter: drop-shadow(0px 0px 10px gray);</span><br><span class="line">box-shadow:0px 0px 10px gray;</span><br></pre></td></tr></table></figure></p><h3 id="outline-轮廊线"><a href="#outline-轮廊线" class="headerlink" title="outline 轮廊线"></a>outline 轮廊线</h3><h4 id="outline能做到的效果："><a href="#outline能做到的效果：" class="headerlink" title="outline能做到的效果："></a>outline能做到的效果：</h4><figure class="image-box">                <img src="/image/css/outline.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="outline-相关属性："><a href="#outline-相关属性：" class="headerlink" title="outline 相关属性："></a>outline 相关属性：</h4><p>outline-width/outline-style/outline-color/outline-offse;</p><h4 id="outline-style的相反值："><a href="#outline-style的相反值：" class="headerlink" title="outline-style的相反值："></a>outline-style的相反值：</h4><ul><li><p>ridge groove</p></li><li><p>inset outset</p></li></ul><h4 id="outline-写法"><a href="#outline-写法" class="headerlink" title="outline 写法"></a>outline 写法</h4><p>outline 是 outline-width outline-style outline-color 的简写，如：<br>outline: 15px solid grey;<br>也可简写：outline: solid;</p><h4 id="outline-offse"><a href="#outline-offse" class="headerlink" title="outline-offse"></a>outline-offse</h4><p>outline-offse 是 outline相关的另外一个样式，但不包含在outline的简写当中。</p><h4 id="outline与box-shadow区别"><a href="#outline与box-shadow区别" class="headerlink" title="outline与box-shadow区别"></a>outline与box-shadow区别</h4><p>outline 与 box-shadow有时候可以达到相同效果，不同的是，当元素有border-redius，outline会有缝隙，box-shadow不会。</p><h3 id="充满父级或屏幕"><a href="#充满父级或屏幕" class="headerlink" title="充满父级或屏幕"></a>充满父级或屏幕</h3><h4 id="充满父级："><a href="#充满父级：" class="headerlink" title="充满父级："></a>充满父级：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  left: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  top: 0;</span><br><span class="line">  bottom: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="充满屏幕："><a href="#充满屏幕：" class="headerlink" title="充满屏幕："></a>充满屏幕：</h4><p>在css中position: fixed是由position: absolute发展而来，相对于屏幕定位<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">position: fixed;</span><br><span class="line">left: 0;</span><br><span class="line">right: 0;</span><br><span class="line">top: 0;</span><br><span class="line">bottom: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="0-5px的下边框"><a href="#0-5px的下边框" class="headerlink" title="0.5px的下边框"></a>0.5px的下边框</h3><h4 id="0-5px的元素"><a href="#0-5px的元素" class="headerlink" title="0.5px的元素"></a>0.5px的元素</h4><p>定义高度为1px，然后缩小高度一半，得到0.5px;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> .small&#123;</span><br><span class="line">     width: 200px;</span><br><span class="line">     background: blue;</span><br><span class="line">     height: 1px;</span><br><span class="line">     transform: scaleY(0.5);</span><br><span class="line"> &#125;</span><br><span class="line">&lt;div class=&quot;small&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h4 id="0-5px的下边框-1"><a href="#0-5px的下边框-1" class="headerlink" title="0.5px的下边框"></a>0.5px的下边框</h4><p>给要定义下边框的元素定义一个伪类，这样的好处是不用另外写html；<br>伪类相当于一个元素，在伪类中，写一个0.5px的元素;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.item::after &#123;</span><br><span class="line">    content: &apos;&apos;;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    background: blue;</span><br><span class="line">    height: 1px;</span><br><span class="line">    transform: scaleY(0.5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;item&quot;&gt;1&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h3 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h3><p>关于渐变的东西太多，这里只写点东西，留个印象。</p><h4 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h4><p>线性渐变由linear-gradient定义，linear-gradient是一个css函数,</p><h5 id="同位置定义两个颜色"><a href="#同位置定义两个颜色" class="headerlink" title="同位置定义两个颜色"></a>同位置定义两个颜色</h5><p>同位置定义两个颜色会形成一个分割线：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-image: linear-gradient(blue, green 30%, red 50%);</span><br></pre></td></tr></table></figure><p>从上到下，蓝色开始，到30%的位置时是绿色开始，到50%是红色开始，以后都是红色，效果：<br><figure class="image-box">                <img src="/image/css/linear1.jpg" alt="" title="" class="">                <p></p>            </figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-image: linear-gradient(blue, green 50%, red 50%);</span><br></pre></td></tr></table></figure><p>同位置定义了绿色和红色 50%；发现绿色和红色重合了，这个也是一个小技巧，效果：<br><figure class="image-box">                <img src="/image/css/linear2.jpg" alt="" title="" class="">                <p></p>            </figure></p><h5 id="其他值"><a href="#其他值" class="headerlink" title="其他值"></a>其他值</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* 渐变轴为45度，从蓝色渐变到红色 */</span><br><span class="line">linear-gradient(45deg, blue, red);</span><br><span class="line">/* 从右下到左上、从蓝色渐变到红色 */</span><br><span class="line">linear-gradient(to left top, blue, red);</span><br></pre></td></tr></table></figure><h4 id="线性渐变-1"><a href="#线性渐变-1" class="headerlink" title="线性渐变"></a>线性渐变</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-image: radial-gradient(circle, red, yellow, green);</span><br></pre></td></tr></table></figure><h4 id="渐变的应用场景"><a href="#渐变的应用场景" class="headerlink" title="渐变的应用场景"></a>渐变的应用场景</h4><p>渐变的应用场景非常广泛，很多css技巧，很多图形，如四边形，菱形，梯形，多边形，格子背景，背景图案 等等，都可以有渐变完成；<br>在《css 揭秘》这边书中，有很多技巧都基于渐变完成</p><h3 id="伪元素做边框"><a href="#伪元素做边框" class="headerlink" title="伪元素做边框"></a>伪元素做边框</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">        height: 100px;</span><br><span class="line">        width: 100px;</span><br><span class="line">        position: relative;</span><br><span class="line">    &#125;</span><br><span class="line">    .text::after&#123;</span><br><span class="line">        content: &apos;&apos;;</span><br><span class="line">        position: absolute;</span><br><span class="line">        top: 0;</span><br><span class="line">        bottom: 0;</span><br><span class="line">        left: 0;</span><br><span class="line">        right: 0;</span><br><span class="line">        border: 1px solid;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;item&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;text&quot;&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这其实利用了经常使用的遮罩方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//以此达到百分之百撑满body，这比width：100%要少很多想不到的问题</span><br><span class="line">.mask&#123;</span><br><span class="line">    position: fixed;</span><br><span class="line">    top: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    left: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    background: grey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="cursor-光标图标"><a href="#cursor-光标图标" class="headerlink" title="cursor 光标图标"></a>cursor 光标图标</h3><p>设置光标图形，几乎你页面上看到的所有光标图样，都可以设置，参考MDN，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cursor: wait;</span><br></pre></td></tr></table></figure></p><figure class="image-box">                <img src="/image/css/cursor.jpg" alt="" title="" class="">                <p></p>            </figure><h3 id="跟随神器"><a href="#跟随神器" class="headerlink" title="跟随神器"></a>跟随神器</h3><p>js 函数，自适应方向上下左右浮动</p><h3 id="文字效果"><a href="#文字效果" class="headerlink" title="文字效果"></a>文字效果</h3><p>E:\css-mastery-16-master\chapter-04\04-33-experimenting-with-shadows.html</p><h3 id="平移和动画"><a href="#平移和动画" class="headerlink" title="平移和动画"></a>平移和动画</h3><p>可查看<a href="https://github.com/YeWills/css_demo" target="_blank" rel="noopener">GitHub上的demo</a></p><h3 id="四种居中方式"><a href="#四种居中方式" class="headerlink" title="四种居中方式"></a>四种居中方式</h3><h4 id="flex居中"><a href="#flex居中" class="headerlink" title="flex居中"></a>flex居中</h4><p> flex为水平和垂直居中而生，是当代居中最佳方案，这里是展示相对屏幕居中，如果是元素居中更加简单。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center;</span><br><span class="line">    position: fixed;</span><br><span class="line">    left: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    top: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">   &#125;</span><br><span class="line">.wrap &#123;</span><br><span class="line">width: 18em;</span><br><span class="line">height: 18em;</span><br><span class="line">box-sizing: border-box;</span><br><span class="line">background: #00BCD4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;wrap&quot;&gt; &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><h4 id="translate居中"><a href="#translate居中" class="headerlink" title="translate居中"></a>translate居中</h4><p> flex没有出来之前，该方法最好，因为不需要知道元素宽度；<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//除flex外，最好的居中最好方法</span><br><span class="line"> .wrap &#123;</span><br><span class="line">          position: absolute;</span><br><span class="line">          top: 50%;</span><br><span class="line">          left: 50%;</span><br><span class="line">          transform: translate(-50%, -50%)</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><h4 id="margin负数"><a href="#margin负数" class="headerlink" title="margin负数"></a>margin负数</h4><p> 该方法有点，兼容性最强，弊端，需要知道元素宽度；<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//居中最好方法</span><br><span class="line"> .wrap &#123;</span><br><span class="line">          position: absolute;</span><br><span class="line">          top: 50%;</span><br><span class="line">          left: 50%;</span><br><span class="line">          margin-top: -3em;</span><br><span class="line">          margin-left: -9em;</span><br><span class="line">          width:18em;</span><br><span class="line">          height:6eml</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><h4 id="视口vh方法"><a href="#视口vh方法" class="headerlink" title="视口vh方法"></a>视口vh方法</h4><p> 该方法局限性很大，只能相对于视口，也就是相对于屏幕居中，无法相对元素居中；<a href="http://dabblet.com/gist/bf12b39d8f5da2b6e5b6" target="_blank" rel="noopener">demo</a><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.wrap &#123;</span><br><span class="line">width: 18em;</span><br><span class="line">height: 18em;</span><br><span class="line">margin: 50vh auto 0;</span><br><span class="line">transform: translateY(-50%);</span><br><span class="line">box-sizing: border-box;</span><br><span class="line">background: #00BCD4;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=&quot;wrap&quot;&gt; &lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h3 id="自定义CheckBox"><a href="#自定义CheckBox" class="headerlink" title="自定义CheckBox"></a>自定义CheckBox</h3><p>主要是定义好这几个状态的样式： focus hover  同时focus和hover；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">input[type=&quot;checkbox&quot;] &#123;</span><br><span class="line">      position: absolute;</span><br><span class="line">      overflow: hidden;</span><br><span class="line">      width: 1px;</span><br><span class="line">      height: 1px;</span><br><span class="line">      clip: rect(0 0 0 0);</span><br><span class="line">    &#125;</span><br><span class="line">input[type=&quot;checkbox&quot;] + label &#123;</span><br><span class="line">  line-height: 1.5;</span><br><span class="line">  color: #333;</span><br><span class="line">  padding-left: 1.5em;</span><br><span class="line">  background-position: .125em 36%;</span><br><span class="line">  background-repeat: no-repeat;</span><br><span class="line">  background-size: 18px 18px;</span><br><span class="line">&#125;</span><br><span class="line">input[type=&quot;checkbox&quot;] + label &#123;</span><br><span class="line">  background-image: url(images/checkbox-unchecked.png);</span><br><span class="line">&#125;</span><br><span class="line">input[type=&quot;checkbox&quot;]:checked + label &#123;</span><br><span class="line">  background-image: url(images/checkbox-checked.png);</span><br><span class="line">&#125;</span><br><span class="line">input[type=&quot;checkbox&quot;]:focus + label &#123;</span><br><span class="line">  background-image: url(images/checkbox-unchecked-focus.png);</span><br><span class="line">&#125;</span><br><span class="line">input[type=&quot;checkbox&quot;]:focus:checked + label &#123;</span><br><span class="line">  background-image: url(images/checkbox-checked-focus.png);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;input type=&quot;checkbox&quot; name=&quot;lang-as&quot; id=&quot;lang-as&quot;&gt;</span><br><span class="line">  &lt;label for=&quot;lang-as&quot;&gt;ActionScript&lt;/label&gt;</span><br><span class="line"> &lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/YeWills/css_demo/blob/master/chapter-09/09-checkbox.html" target="_blank" rel="noopener">demo</a></p><h2 id="css知识"><a href="#css知识" class="headerlink" title="css知识"></a>css知识</h2><h3 id="行内盒子-匿名盒子"><a href="#行内盒子-匿名盒子" class="headerlink" title="行内盒子 匿名盒子"></a>行内盒子 匿名盒子</h3><p>具体参考 另外一篇博客《vertical-align、行盒子、baseline》<br>匿名盒子说的是没有任何标签的文本，如下， prity girl 这两个文本就是一个匿名盒子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">     prity girl</span><br><span class="line">     &lt;p&gt;can you liu one qq&lt;/p&gt;</span><br><span class="line"> &lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h3 id="float浮动定位"><a href="#float浮动定位" class="headerlink" title="float浮动定位"></a>float浮动定位</h3><p>浮动定位有以下特点：</p><h4 id="收缩为最小宽度"><a href="#收缩为最小宽度" class="headerlink" title="收缩为最小宽度"></a>收缩为最小宽度</h4><p>除非已经定义了浮动元素的宽度，否则浮动元素收缩为适应元素内容的最小宽度。</p><h4 id="遇到块级元素将停止"><a href="#遇到块级元素将停止" class="headerlink" title="遇到块级元素将停止"></a>遇到块级元素将停止</h4><p>对于自身而言，浮动元素脱离文档流后，遇到块级元素将停止，</p><h4 id="脱离文档流"><a href="#脱离文档流" class="headerlink" title="脱离文档流"></a>脱离文档流</h4><p>当一个元素变为浮动元素时，对不同类型的相邻元素影响如下：</p><h5 id="与行内元素相邻"><a href="#与行内元素相邻" class="headerlink" title="与行内元素相邻"></a>与行内元素相邻</h5><p>会让行内元素紧贴浮动元素，典型的场景–图片文字环绕<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img&#123;</span><br><span class="line">  float: left;</span><br><span class="line">&#125;</span><br><span class="line">&lt;img src=&quot;./aa.jpg&quot; alt=&quot;aa&quot;&gt;</span><br><span class="line">&lt;span&gt;行内元素文字行内元素文字&lt;/span&gt;</span><br></pre></td></tr></table></figure></p><h5 id="与块级元素相邻"><a href="#与块级元素相邻" class="headerlink" title="与块级元素相邻"></a>与块级元素相邻</h5><p>浮动元素脱离文档流，此时效果类似position：absolute，相当于浮动元素不存在，与之相邻的块级元素将占领浮动元素位置；<br><strong>但是块级元素内的行内元素，将环绕浮动元素</strong><br>浮动之前：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    .float &#123;</span><br><span class="line">        height: 60px;</span><br><span class="line">        background: rebeccapurple;</span><br><span class="line">    &#125;</span><br><span class="line">    .test &#123;</span><br><span class="line">        border: 45px solid #00BCD4;</span><br><span class="line">        background: blue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;float&quot;&gt;浮动之前&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;test&quot;&gt;相邻块级元素&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><figure class="image-box">                <img src="/image/css/float-before.jpg" alt="" title="" class="">                <p></p>            </figure><p>浮动之后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    .float &#123;</span><br><span class="line">      /* 其他代码省略 */</span><br><span class="line">        float: left;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;div class=&quot;float&quot;&gt;浮动之后&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;test&quot;&gt;相邻块级元素相邻块级元素相邻块级元素...&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><figure class="image-box">                <img src="/image/css/float-after.jpg" alt="" title="" class="">                <p></p>            </figure><h5 id="与浮动元素相邻"><a href="#与浮动元素相邻" class="headerlink" title="与浮动元素相邻"></a>与浮动元素相邻</h5><p>浮动元素与浮动元素 将并列并排；<br>注意的是，如果浮动元素的高度不同，当浮动元素被挤到第二行时，将会卡住：<br><figure class="image-box">                <img src="/image/css/float-pading.jpg" alt="" title="" class="">                <p></p>            </figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.triangle&#123;</span><br><span class="line">     float: left;</span><br><span class="line">     width: 150px;</span><br><span class="line">     height: 60px;</span><br><span class="line"> &#125;</span><br><span class="line"> .it1&#123;</span><br><span class="line">     height: 80px;</span><br><span class="line">     background:rebeccapurple;</span><br><span class="line"> &#125;</span><br><span class="line"> .it2&#123;</span><br><span class="line">     background:blue;</span><br><span class="line"> &#125;</span><br><span class="line"> .it3&#123;</span><br><span class="line">     background:#00BCD4;</span><br><span class="line"> &#125;</span><br><span class="line"> &lt;div class=&quot;triangle it1&quot;&gt;浮动元素&lt;/div&gt;</span><br><span class="line"> &lt;div class=&quot;triangle it2&quot;&gt;浮动元素&lt;/div&gt;</span><br><span class="line"> &lt;div class=&quot;triangle it3&quot;&gt;浮动元素&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h4 id="消除与相邻元素的间隙"><a href="#消除与相邻元素的间隙" class="headerlink" title="消除与相邻元素的间隙"></a>消除与相邻元素的间隙</h4><p>当被定义为浮动元素时，它跟原来相邻元素可能由于系统中自带的缝隙，一旦变成浮动元素，此缝隙将没有了，参加《疑难点》；<br>消除间隙这个特性，在开发中经常被运用.</p><h4 id="与绝对定位区别"><a href="#与绝对定位区别" class="headerlink" title="与绝对定位区别"></a>与绝对定位区别</h4><p>浮动定位于绝对定位都会脱离文档流，但二者表现不一样；<br>绝对定位是完全脱离文档流，相当于文档中不存在此元素了，而浮动定位脱离文档流要区别行内元素，原因如上。</p><h4 id="float清空格的原因"><a href="#float清空格的原因" class="headerlink" title="float清空格的原因"></a>float清空格的原因</h4><p>根本原因是由于float会导致节点脱离文档流结构。它都不属于文档流结构了，那么它身边的什么换行、空格就都和它没关系的，它就尽量的往一边去靠拢，能靠多近就靠多近，这就是清空格的本质。</p><h3 id="有关em"><a href="#有关em" class="headerlink" title="有关em"></a>有关em</h3><h4 id="font-size的em叠加"><a href="#font-size的em叠加" class="headerlink" title="font-size的em叠加"></a>font-size的em叠加</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.it1&#123;</span><br><span class="line">  font-size:1.314em;</span><br><span class="line">&#125;</span><br><span class="line">.it2&#123;</span><br><span class="line">  font-size:1.314em;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=&quot;it1&quot;&gt;</span><br><span class="line">  &lt;!-- 元素1  font-size 将为16px*1.314 =21px --&gt;</span><br><span class="line">  元素1</span><br><span class="line">  &lt;!-- 元素2  font-size 将为16px*1.314*1.314 =28px --&gt;</span><br><span class="line">  &lt;div class=&quot;it2&quot;&gt;元素2&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h4 id="font-size-1-314em-与-height-1-314em-区别"><a href="#font-size-1-314em-与-height-1-314em-区别" class="headerlink" title="font-size:1.314em 与 height: 1.314em 区别"></a>font-size:1.314em 与 height: 1.314em 区别</h4><p>由下面代码可知，font-size 与 height\margin\padding这些属性不一样；<br>font-size的em的基准是父font-size;<br>height\margin\padding等的em基准是自身的font-size；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.it1&#123;</span><br><span class="line">  font-size:1.314em;</span><br><span class="line">&#125;</span><br><span class="line">.it2&#123;</span><br><span class="line">  font-size:1.314em;</span><br><span class="line">  height: 1.314em;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=&quot;it1&quot;&gt;</span><br><span class="line">  &lt;!-- 元素1  font-size 将为16px*1.314 =21px --&gt;</span><br><span class="line">  元素1</span><br><span class="line">  &lt;!-- 元素2  font-size 将为16px*1.314*1.314 =28px --&gt;</span><br><span class="line">  &lt;!-- 元素2  height  将为自己的font-size*1.314 =36px --&gt;</span><br><span class="line">  &lt;div class=&quot;it2&quot;&gt;元素2&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h4 id="em的使用场景"><a href="#em的使用场景" class="headerlink" title="em的使用场景"></a>em的使用场景</h4><p>font-size<br>padding<br>border-radius (不包含border-with)<br>margin</p><h4 id="为什么要使用em"><a href="#为什么要使用em" class="headerlink" title="为什么要使用em"></a>为什么要使用em</h4><p>当你想要当前元素的 padding\padding\border-radius\box-shadow\text-shadow\margin\line-height 等值，与当前字体大小成比例的时候，使用 em 单位。</p><h3 id="rem的使用场景"><a href="#rem的使用场景" class="headerlink" title="rem的使用场景"></a>rem的使用场景</h3><p>rem 主要用于移动端适配，pc端用得少.</p><h3 id="display-none与visibility-hidden"><a href="#display-none与visibility-hidden" class="headerlink" title="display:none与visibility:hidden"></a>display:none与visibility:hidden</h3><p>display:none 不为被隐藏的对象保留其物理空间<br>visibility：hidden 为被隐藏的对象保留其物理空间</p><h3 id="伪类与伪元素"><a href="#伪类与伪元素" class="headerlink" title="伪类与伪元素"></a>伪类与伪元素</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">::before  //伪元素</span><br><span class="line">:focus  //伪类</span><br></pre></td></tr></table></figure><h4 id="content-attr-url-counter"><a href="#content-attr-url-counter" class="headerlink" title="content - attr\url\counter"></a>content - attr\url\counter</h4><h5 id="配合attr使用"><a href="#配合attr使用" class="headerlink" title="配合attr使用"></a>配合attr使用</h5><p>attr是css3的一个属性。<br>attr是用来content与元素进行通信的一个接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.text&#123;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.text:hover::before&#123;</span><br><span class="line">    content: attr(show-tip);</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: -150%;</span><br><span class="line">    left: 50%;</span><br><span class="line">    transform: translateX(-50%);</span><br><span class="line">    white-space: nowrap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;span class=&quot;text&quot; show-tip=&quot;6666&quot;&gt; prity girl&lt;/span&gt;</span><br></pre></td></tr></table></figure></p><h5 id="配合url使用"><a href="#配合url使用" class="headerlink" title="配合url使用"></a>配合url使用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h1:after &#123;content:url(/i/w3school_logo_white.gif)&#125;</span><br></pre></td></tr></table></figure><h5 id="配合counter使用"><a href="#配合counter使用" class="headerlink" title="配合counter使用"></a>配合counter使用</h5><p>用得较少，用来计数，更多请-&gt;Google<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.conter p:before&#123;</span><br><span class="line">                   content: counter(count,decimal) &quot;.&quot; /*调用计数器 并在数字后添加.*/</span><br><span class="line">                   counter-increment: count;</span><br><span class="line">              &#125;</span><br></pre></td></tr></table></figure></p><h4 id="伪元素相当于父级内的内联span元素"><a href="#伪元素相当于父级内的内联span元素" class="headerlink" title="伪元素相当于父级内的内联span元素"></a>伪元素相当于父级内的内联span元素</h4><p>伪类其实相当于定义在父级元素内的内联span元素或匿名行内元素，可以通过display改变其属性。<br>把伪类当成父级元素内的元素看即可，没有什么不同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   .father::after&#123;</span><br><span class="line">            content: &apos;after伪类 content&apos;</span><br><span class="line">        &#125;</span><br><span class="line">        .father::before&#123;</span><br><span class="line">            content: &apos;before伪类 content&apos;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;father&quot;&gt;父元素的text&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>相当于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;father&quot;&gt;</span><br><span class="line">    &lt;span&gt;before伪类 content&lt;/span&gt;</span><br><span class="line">    父元素的text</span><br><span class="line">    &lt;span&gt;after伪类 content&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>由上得出：</p><ul><li>before 相当于 紧跟父元素之前的行内块；</li><li>after 相当于 紧跟父元素之后的行内块</li></ul><h4 id="hover-before"><a href="#hover-before" class="headerlink" title=":hover::before"></a>:hover::before</h4><p>伪类结合伪元素一起使用<br>参考《content几种用法》<br>参考《自定义CheckBox》</p><h4 id="hover-active-focus-onblur-经典应用"><a href="#hover-active-focus-onblur-经典应用" class="headerlink" title="hover active focus onblur 经典应用"></a>hover active focus onblur 经典应用</h4><p>一个按钮的hover active focus onblur这三个状态触发时候先后顺序的<br>hover  鼠标悬浮按钮上；<br>active  左键按住按钮；<br>focus  左键松开后，激活按钮状态为focus；<br>onblur 左键点击任意位置，变为非focus状态</p><p>理解上面四个状态非常关键，很多基本的样式都是基于上面开发的，一个前端不早弄懂上面四个状态，哭都没地方去。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.btn:hover&#123;</span><br><span class="line">    background: blueviolet;</span><br><span class="line">&#125;</span><br><span class="line">.btn:active:focus&#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line">.btn:focus&#123;</span><br><span class="line">    color: blue;</span><br><span class="line">    outline: 2px solid yellow</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> &lt;button class=&quot;btn&quot;&gt;9999999&lt;/button&gt;</span><br></pre></td></tr></table></figure></p><h4 id="focus-与-tabindex"><a href="#focus-与-tabindex" class="headerlink" title="focus 与 tabindex"></a>focus 与 tabindex</h4><p>tabindex 是html5属性 ，非常好用， 指示其元素是否可以聚焦<br>在html4中，不是每个标签都拥有focus属性，在html5中，通过tabindex，每个标签都可以定义focus属性。<br>参考《博客—html笔记—tabindex》</p><h4 id="伪元素做边框-1"><a href="#伪元素做边框-1" class="headerlink" title="伪元素做边框"></a>伪元素做边框</h4><p>参考《伪元素做边框》</p><h3 id="大汇集"><a href="#大汇集" class="headerlink" title="大汇集"></a>大汇集</h3><p>font-weight 默认为normal，normal对应数值为400，可以使用关键字 normal、bold等等，也可以使用数数值，都是100的整数：100、200、300、400等等<br>text-transform 可以使英文单词首字母大写或者所有字母大写，或者所有字符小写的功能；<br>word-spacing: 0.1em; 英文单词间距<br>letter-spacing: 0.1em; 英文字母间距<br>text-shadow ： 字体阴影效果<br>text-overflow: ellipsis或clip<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clip : 不显示省略标记（...），而是简单的裁切</span><br><span class="line">ellipsis : 当对象内文本溢出时显示省略标记（...）</span><br></pre></td></tr></table></figure></p><p>columns 可用来文本分多栏显示；<br>pointer-events 可用来打开的禁止元素的事件响应，设置为none的时候，不会触发该元素的hover和click事件；</p><h3 id="font-face写法"><a href="#font-face写法" class="headerlink" title="@font-face写法"></a>@font-face写法</h3><p>format 给浏览器提示，src内的文件类型是什么，方便浏览器阅读；<br>font-face用的是后备机制写法，如下src写了很多，就是给不同设备的浏览器解析，增加兼容性；<br>font-weight和font-style作为可选配置，如果配置了，那么在使用此字体时，必须设置与<strong>这里一样的font-weight和font-style值时才起作用,这点很容易让人忽视</strong><br>见P84《精通css 高级web标准解决方案》<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  @font-face &#123;</span><br><span class="line">font-family: &apos;YourWebFontName&apos;;</span><br><span class="line">   font-weight: &apos;400&apos;;</span><br><span class="line">src: url(&apos;YourWebFontName.eot&apos;); /* IE9 Compat Modes */</span><br><span class="line">src: url(&apos;YourWebFontName.eot?#iefix&apos;) format(&apos;embedded-opentype&apos;), /* IE6-IE8 */</span><br><span class="line">            url(&apos;YourWebFontName.woff&apos;) format(&apos;woff&apos;), /* Modern Browsers */</span><br><span class="line">            url(&apos;YourWebFontName.ttf&apos;)  format(&apos;truetype&apos;), /* Safari, Android, iOS */</span><br><span class="line">            url(&apos;YourWebFontName.svg#YourWebFontName&apos;) format(&apos;svg&apos;); /* Legacy iOS */</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="position定位相关"><a href="#position定位相关" class="headerlink" title="position定位相关"></a>position定位相关</h3><p>position:relactive:<br>相对定位：相对于自身原位置偏移；<br>仍处于标准文档流中；<br>随即拥有偏移属性和z-index属性；</p><p>position:absolute:<br>绝对定位：<br>完全脱离了标准文档流；<br>随即拥有偏移属性和z-index属性；<br>元素具有了包裹性，与float类似；</p><h3 id="颜色值函数-rgb-rgba-hsla"><a href="#颜色值函数-rgb-rgba-hsla" class="headerlink" title="颜色值函数-rgb/rgba/hsla"></a>颜色值函数-rgb/rgba/hsla</h3><p>rgba是rgb的进化版，带有透明度；</p><p>#ffffff 六位数是没有透明度的；</p><p>#00000000 八位数的是有透明度的；<br>hsla是hsl的进化版，带有透明度；<br>hsla其实没什么特别的，也就跟rgba一样是个颜色单位，貌似它与rgba区别的是，hsla写法更加简洁。</p><h3 id="background"><a href="#background" class="headerlink" title="background"></a>background</h3><h4 id="关于background本身"><a href="#关于background本身" class="headerlink" title="关于background本身"></a>关于background本身</h4><p>background是个简写属性，会重置以前定义的很多background属性，因此定义的时候，把它放在最上面，然后使用background-color等等属性叠加定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//不推荐，background会重置background-repeat属性，达不到no-repeat效果</span><br><span class="line">background-repeat: no-repeat;</span><br><span class="line">background: url(../image/css/vertical-align/column.png);</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//推荐这种写法</span><br><span class="line">  background: url(../image/css/vertical-align/column.png);</span><br><span class="line">  background-repeat: no-repeat;</span><br></pre></td></tr></table></figure><h4 id="background多重背景"><a href="#background多重背景" class="headerlink" title="background多重背景"></a>background多重背景</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">background: url(./column.png), url(./column1.png), url(./column2.png), url(./column3.png);</span><br><span class="line">background-position: left top, right top, left bottom, right bottom;</span><br><span class="line">background-repeat: no-repeat, no-repeat, no-repeat, no-repeat;</span><br><span class="line">background-color: pink;</span><br></pre></td></tr></table></figure><h4 id="带颜色-图片-定位的背景"><a href="#带颜色-图片-定位的背景" class="headerlink" title="带颜色\图片\定位的背景"></a>带颜色\图片\定位的背景</h4><p>蓝色背景、背景图片、背景图片距离父级右边19px底部向上10px.<a href="http://dabblet.com/gist/0f226e63595d1bef88cb" target="_blank" rel="noopener">demo</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.wrap &#123;</span><br><span class="line">           background: url(../image/css/outLine.jpg)  no-repeat  blue;</span><br><span class="line">         background-position: right 19px bottom 10px;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><h4 id="background-size"><a href="#background-size" class="headerlink" title="background-size"></a>background-size</h4><p>如果要让背景图片充满整个元素，则基本上要用到这个属性<br>background-size: 100% 100%  背景图片的宽度为元素宽度100%，高度为元素高度100% （此种写法会让图片充满元素，但会失真）<br>background-size: 100% auto  背景图片的宽度为元素宽度100%，高度由浏览器自动计算一个值，保持不失真(推荐)<br>其他可取值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">background-size:auto;</span><br><span class="line">background-size:cover;</span><br><span class="line">background-size:contain;</span><br><span class="line">background-size:auto;</span><br><span class="line">background-size:50px;</span><br><span class="line">background-size:50%;</span><br></pre></td></tr></table></figure></p><h4 id="background相关属性"><a href="#background相关属性" class="headerlink" title="background相关属性"></a>background相关属性</h4><p><a href="https://www.jianshu.com/p/e377c0bebfd0" target="_blank" rel="noopener">background-origin：background-origin 属性规定 background-position 属性相对于什么位置来定位。</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-origin: padding-box|border-box|content-box;</span><br></pre></td></tr></table></figure></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-clip" target="_blank" rel="noopener">background-clip 规定背景的绘制区域;</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-clip: padding-box|border-box|content-box;</span><br></pre></td></tr></table></figure><h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。<br>两个概念：主轴、辅轴(交叉轴)；</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>以下6个属性设置在容器上</p><ul><li>flex-direction</li><li>flex-wrap  —是否换行</li><li><strong>flex-flow 上面二者缩写</strong></li><li>justify-content</li><li>align-items</li><li>align-content 多行（多轴）如何对齐，与align-items意义一样，前者是单行，后者多行；</li></ul><ul><li>order 定义项目的排列顺序，实际中用得少；</li><li>flex-grow 放大</li><li>flex-shrink 收缩</li><li>flex-basis 属性定义了在<strong>分配多余空间之前</strong>，项目占据的主轴空间，容器根据这个属性，计算主轴是否有多余空间，然后决定如何执行- flex-grow或flex-shrink，这个属性是flex中比较难理解的，同时设置width和flex-basic时，flex-basic覆盖width，在flex子项中，建议使用flex-basic，少用width，有些人说，flex-basic是用来代替width的。</li><li><strong>flex 上面三者的简写</strong>  flex: none | [ &lt;’flex-grow’&gt; &lt;’flex-shrink’&gt;? || &lt;’flex-basis’&gt; ]</li><li>align-self  单独垂直对齐，可覆盖align-items属性</li></ul><h4 id="运用技巧"><a href="#运用技巧" class="headerlink" title="运用技巧"></a>运用技巧</h4><h5 id="行内自适应宽度"><a href="#行内自适应宽度" class="headerlink" title="行内自适应宽度"></a>行内自适应宽度</h5><p>一行当中，某几个行元素固定高度，给剩下一个元素随意定义一个flex值，比如1、2、3…都可以，让这个元素自适应。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">         display: flex;</span><br><span class="line">     &#125;</span><br><span class="line">     .box-item1&#123;</span><br><span class="line">         width: 80px;</span><br><span class="line">         background: rebeccapurple;</span><br><span class="line">     &#125;</span><br><span class="line">     .box-item2&#123;</span><br><span class="line">         flex: 1;</span><br><span class="line">         background: red;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     &lt;div class=&quot;box box-2&quot;&gt;</span><br><span class="line">             &lt;div class=&quot;box-item1&quot;&gt;2&lt;/div&gt;</span><br><span class="line">             &lt;div class=&quot;box-item2&quot;&gt;3&lt;/div&gt;</span><br><span class="line">         &lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>效果：<br><figure class="image-box">                <img src="/image/css/flex1.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="flex-shrink-IE与谷歌差异"><a href="#flex-shrink-IE与谷歌差异" class="headerlink" title="flex-shrink IE与谷歌差异"></a>flex-shrink IE与谷歌差异</h4><p>flexbox的规范是 当空间小是，元素宽度随之减少，当减少到元素的width时，将不再减少。<br>目前谷歌和火狐以及Op浏览器忽略上面这个规范，也就是说在这些浏览器中，元素可以减少到0px宽度；<br>IE遵守以上规范，当元素减少到width时，将不再减少。</p><h3 id="媒体查询-与-响应式布局"><a href="#媒体查询-与-响应式布局" class="headerlink" title="媒体查询 与 响应式布局"></a>媒体查询 与 响应式布局</h3><h4 id="媒体查询能查的特性"><a href="#媒体查询能查的特性" class="headerlink" title="媒体查询能查的特性"></a>媒体查询能查的特性</h4><p>可以尺度查询，如max-width；<br>可以宽高比查询：<br>可以横竖屏方向查询；<br>可以设备像素比查询 min-resolution<br>见P220</p><h4 id="媒体查询的技巧"><a href="#媒体查询的技巧" class="headerlink" title="媒体查询的技巧"></a>媒体查询的技巧</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/* 这种媒体查询的写法，很妙，由上到下进行层叠，下面的覆盖上面的，达到不用写 这种形式：30em&lt;width&lt;56em ,使用一个min-width就达到效果*/</span><br><span class="line"></span><br><span class="line">    @media only screen and (min-width: 35em) &#123;</span><br><span class="line">      .row-quartet &gt; * &#123;</span><br><span class="line">        width: 50%;</span><br><span class="line">      &#125;</span><br><span class="line">      .subcategory-featured &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @media only screen and (min-width: 50em) &#123;</span><br><span class="line">      .row-quartet &gt; * &#123;</span><br><span class="line">        width: 25%;</span><br><span class="line">      &#125;</span><br><span class="line">      .subcategory-featured &#123;</span><br><span class="line">        width: 50%;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    @media only screen and (min-width: 70em) &#123;</span><br><span class="line">      .subcategory-header &#123;</span><br><span class="line">        width: 20%;</span><br><span class="line">      &#125;</span><br><span class="line">      .subcategory-content &#123;</span><br><span class="line">        width: 80%;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="很妙的响应式布局简单范例"><a href="#很妙的响应式布局简单范例" class="headerlink" title="很妙的响应式布局简单范例"></a>很妙的响应式布局简单范例</h4><p>GitHub 08-05-responsive-news.html</p><h4 id="感受下最简单的响应式设计demo"><a href="#感受下最简单的响应式设计demo" class="headerlink" title="感受下最简单的响应式设计demo"></a>感受下最简单的响应式设计demo</h4><p>E:\css-mastery-16-master\chapter-08\08-05-responsive-news.html</p><h4 id="响应式设计-的一些应用"><a href="#响应式设计-的一些应用" class="headerlink" title="响应式设计 的一些应用"></a>响应式设计 的一些应用</h4><p>对字体的设计：<br>  body {<br>      font-family: ‘Open Sans’, ‘Helvetica Neue’, Arial, sans-serif;<br>      line-height: 1.5;<br>    }<br>    @media only screen and (max-width: 37.5em) {<br>      h1,h2,h3,h4,h5,h6 {<br>        font-family: ‘Open Sans Condensed’, ‘Arial Narrow’, Arial, sans-serif;<br>      }<br>    }<br>高清图或多倍图或大小图查询：<br> .profile-box {<br>      position: relative;<br>      height: 300px;<br>      background-size: cover;<br>      background-position: 50% 50%;<br>      background-image: url(img/small-cat.jpg);<br>    }<br>    @media only screen and (min-width: 600px) {<br>      .profile-box {<br>        height: 600px;<br>        background-image: url(img/big-cat.jpg);<br>      }<br>    }</p><h4 id="更多响应布局知识"><a href="#更多响应布局知识" class="headerlink" title="更多响应布局知识"></a>更多响应布局知识</h4><p>参考博客《css之布局》</p><h3 id="calc"><a href="#calc" class="headerlink" title="calc"></a>calc</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>calc能识别 px、百分比、em，且可以混写，如下有效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">width: calc(50% + 20px*4 - 1em);</span><br></pre></td></tr></table></figure></p><p>注意，calc值内，运算符两边需要空格，否则无效。</p><h4 id="calc居中-50-xx"><a href="#calc居中-50-xx" class="headerlink" title="calc居中__50%-xx"></a>calc居中__50%-xx</h4><p>以下是常规利用margin auto让img图片居中的方法，弊端是需要给图片设置display: block;,原因参考《margin:0 auto在inline-block失效》<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.wrap &#123;</span><br><span class="line">        background: rebeccapurple;</span><br><span class="line">    &#125;</span><br><span class="line">img&#123;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">    display: block;</span><br><span class="line">&#125;</span><br><span class="line"> &lt;div class=&quot;wrap&quot;&gt;</span><br><span class="line">        &lt;img class=&quot;dd&quot; src=&quot;http://csssecrets.io/images/adamcatlace.jpg&quot; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>可以使用calc来实现，可以让代码更简洁，利用的是数学原理，假设图片长度已知为400px；<br>那么 100%- (50%-200px)*2 = 400px ;这个400px就是图片长度，100%是父级宽度50%-200px是内边距或外边距。<br>记住 50%-xx 是calc居中的套路。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//方法一</span><br><span class="line"> .wrap &#123;</span><br><span class="line">        background: rebeccapurple;</span><br><span class="line">        padding: 0 calc(50% - 200px);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//方法一</span><br><span class="line">img&#123;</span><br><span class="line">    margin: 0 calc(50% - 200px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="css3较好特性"><a href="#css3较好特性" class="headerlink" title="css3较好特性"></a>css3较好特性</h3><h4 id="max-width-min-content"><a href="#max-width-min-content" class="headerlink" title="max-width: min-content"></a>max-width: min-content</h4><p> min-content是css3关键字，<br> 众所周知，如果不给元素一个具体的height,它就会自动适应内容的高度。假如我们希望width也具有同样的类似行为，如何达到，此时可以使用min-content。<br> min-content 这个关键字将解析为这个容器内部最大的不可短行元素高度（即最宽的单词、图片或具有固定宽度的盒元素）<br><a href="https://www.jianshu.com/p/b7c929fce368" target="_blank" rel="noopener">直接参考这里</a><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> .wrap &#123;</span><br><span class="line">max-width: min-content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  &lt;div class=&quot;wrap&quot;&gt;</span><br><span class="line">      &lt;img src=&quot;http://csssecrets.io/images/adamcatlace.jpg&quot; /&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">          The great Sir Adam Catlace was named after Countess Ada Lovelace, the first programmer ever.</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h2 id="css黑知识"><a href="#css黑知识" class="headerlink" title="css黑知识"></a>css黑知识</h2><h3 id="css-覆盖原则"><a href="#css-覆盖原则" class="headerlink" title="css 覆盖原则"></a>css 覆盖原则</h3><p>简写的方式，最容易覆盖原来定义好的规则，修改已有代码时，不覆盖以前样式的方式就是不要写简写。<br>例如outline，background的等等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">outline-width: 15px;</span><br><span class="line">outline-color: #00BCD4;</span><br><span class="line">outline: solid; //覆盖了以上两句css样式，实际展示的轮廊线将为 默认的size，和黑色</span><br></pre></td></tr></table></figure></p><h3 id="font-family-多值写法"><a href="#font-family-多值写法" class="headerlink" title="font-family 多值写法"></a>font-family 多值写法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Times new Roman 使用了引号，因为它有空格，当有空格时，最好加上引号，也可以不加</span><br><span class="line">font-family: Georgia, Times, &quot;Times new Roman&quot;, sefif;</span><br></pre></td></tr></table></figure><p>后备机制是font-family的重要特性。<br>以上是一种后备写法，从左到右，优先级左边最高，当此值在浏览器中无法识别时，往右顺延。</p><h3 id="参照的是父级的什么属性"><a href="#参照的是父级的什么属性" class="headerlink" title="% 参照的是父级的什么属性"></a>% 参照的是父级的什么属性</h3><h4 id="position"><a href="#position" class="headerlink" title="position"></a>position</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 10%;</span><br><span class="line">    left: 10%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>left 参照父级的 width；<br>top 参照父级的 height；</p><h4 id="margin-参照父width"><a href="#margin-参照父width" class="headerlink" title="margin 参照父width"></a>margin 参照父width</h4><p>margin 百分比只参照父级的宽度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    margin-left: 10%;//父级的宽度</span><br><span class="line">    margin-top: 10%;//父级的宽度</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="margin-0-auto在inline-block失效"><a href="#margin-0-auto在inline-block失效" class="headerlink" title="margin:0 auto在inline-block失效"></a>margin:0 auto在inline-block失效</h3><p>如下，child将不居中；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    .wrap&#123;</span><br><span class="line">            background: #00bcd4b5;</span><br><span class="line">            height: 90px;</span><br><span class="line">        &#125;</span><br><span class="line">        .child&#123;</span><br><span class="line">            display: inline-block;</span><br><span class="line">            height: 50px; </span><br><span class="line">            width: 100px;</span><br><span class="line">            background: rebeccapurple;</span><br><span class="line">            margin: 0 auto;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;wrap&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><p>解决的方法就是从新设置 child 的display: block;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.child&#123;</span><br><span class="line">    &lt;!-- 其他不变 --&gt;</span><br><span class="line">     display: block;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><p>为什么margin: 0 auto对inline-block无效呢，对于margin来说，auto是一个特殊关键字，在<a href="https://www.w3schools.com/css/css_margin.asp" target="_blank" rel="noopener">以下是w3c关于margin的auto关键字执行机制的解释</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">You can set the margin property to auto to horizontally center the element within its container.</span><br><span class="line">The element will then take up the specified width, and the remaining space will be split equally between the left and right margins:</span><br><span class="line">可以将Margin属性设置为Auto，使元素在其容器内水平居中。</span><br><span class="line">元素将占用指定的宽度(就是自己的width)，剩余的空间将在左右页边距之间平均分配：</span><br></pre></td></tr></table></figure></p><p>从上面的话中，我们知道，要想auto有效，必须提供如下条件—</p><ul><li>必须给元素设置宽度<br>浏览器要将元素所处的行的宽度减去元素宽度，获得剩余宽度，然后平均分配；</li><li>必须是块级元素<br>必须是block元素，因为在block元素中，这一行只有这一个元素，如果不是block，例如是inline-block时，就算浏览器可以让元素居中，但是该行中还有其他行内元素，那么这个居中元素是覆盖还是将其他行内元素一起居中呢。<br>所以非block元素，auto关键字无效。<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4></li><li>这里说的是auto关键字无效，而不是margin这个属性失效，auto无效，你也可以给定一个具体值，margin都是有效的；</li><li>对于img，button这些元素本身是有宽度的，可以不用设置宽度，只需指定display: block;就可以使用 margin:0 auto居中；</li><li>对于行内元素，含inline-block，要让他们居中的最好方法是text-align,毕竟text-align是针对行内元素居中而创造的，这个故事告诉我们，对于不同类型的居中，虽然很多种方法都可以居中，但要选对规范的犯法;<br>简单点就是，块级元素 使用 margin: 0 auto居中，行内元素使用text-align居中； <h4 id="敲黑板"><a href="#敲黑板" class="headerlink" title="敲黑板"></a>敲黑板</h4>在现代浏览器中，如果要把一些东西水平居中，使用 display:flex; 对于不兼容flex的浏览器如IE8-9 才建议使用 margin: 0 auto;</li></ul><h3 id="外边距折叠"><a href="#外边距折叠" class="headerlink" title="外边距折叠"></a>外边距折叠</h3><p>外边距折叠只发生在margin垂直方向，水平方向没有此现象，所以外边距折叠，指的就是margin-top与margin-bottom两个方向。</p><h4 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  .wrap&#123;</span><br><span class="line">            background: red;</span><br><span class="line">            height: 150px;</span><br><span class="line">        &#125;</span><br><span class="line">        .chilid&#123;</span><br><span class="line">            margin-top: 80px;</span><br><span class="line">            height: 50px; </span><br><span class="line">            background: blue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;wrap&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;chilid&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>效果如下：<br><figure class="image-box">                <img src="/image/css/margin1.jpg" alt="" title="" class="">                <p></p>            </figure></p><p>这里的效果并没有达到我们的预期，我们对chilid做了margin-top，那么child理应是相对父wrap进行margin，而实际中，child却相对浏览器边缘进行了margin-top；<br>这就是外边距折叠的现象之一。</p><p>解决方案，就是在wrap中写一个border或者写一个padding，就可以达到预期效果了；</p><h4 id="其他外边距折叠现象："><a href="#其他外边距折叠现象：" class="headerlink" title="其他外边距折叠现象："></a>其他外边距折叠现象：</h4><figure class="image-box">                <img src="/image/css/margin2.png" alt="" title="" class="">                <p></p>            </figure><h4 id="出现外边距折叠的条件"><a href="#出现外边距折叠的条件" class="headerlink" title="出现外边距折叠的条件"></a>出现外边距折叠的条件</h4><p>外边距折贴<strong>只发生在正常文档流中的块级元素的 margin 垂直方向上；</strong><br>margin水平方向无此现象；<br>行内盒子，浮动盒子，绝对定位无此现象；<br>而且块级元素发生此现象的另外重要条件是，父元素<strong>既没有border又没有padding才会发生此现象</strong>。参考上面的例子。<br>所以我们在实际开发中，往往要对header进行margin-top处理时，不要使用margin-top，使用padding-top代替，因为可能会发生折叠现象；<br>外边距折叠现象其实是有很多好处的，可以避免很多多余的margin，可参考 《精通css》P45页，<a href="https://www.w3schools.com/css/css_margin.asp" target="_blank" rel="noopener">外网w3c也提到了margin 垂直方向上的折叠现象</a>;</p><h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><p>块格式化上下文，全称Block Formatting Context，你也可以叫它肯德基；相关概念去mdn或w3c查。</p><h4 id="BFC特征"><a href="#BFC特征" class="headerlink" title="BFC特征"></a>BFC特征</h4><p>BFC有以下特征：</p><ul><li>内部的Box会在垂直方向，一个接一个地放置。</li><li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</li><li>每个元素的左外边缘（margin-left)， 与包含块的左边（contain box left）相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。除非这个元素自己形成了一个新的BFC。</li><li>BFC的区域不会与float box重叠（可阻止因浮动元素引发的文字环绕现象）。</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 (利用此特性，解决外边距折叠问题)</li><li>计算BFC的高度时，浮动元素也参与计算 （利用这一特性，使用overflow消除浮动）<br><a href="https://segmentfault.com/a/1190000009545742" target="_blank" rel="noopener">参考1</a><br><a href="https://www.jianshu.com/p/11e764268c0d" target="_blank" rel="noopener">参考2</a></li></ul><h4 id="创建一个BFC"><a href="#创建一个BFC" class="headerlink" title="创建一个BFC"></a>创建一个BFC</h4><p>根元素或其它包含它的元素<br>浮动 (元素的 float 不是 none)<br>绝对定位的元素 (元素具有 position 为 absolute 或 fixed)<br>块级元素具有overflow ，且值不是 visible<br>非块级元素具有 display: inline-block，table-cell, table-caption, flex, inline-flex<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context" target="_blank" rel="noopener">更多创建方式</a></p><h4 id="为什么要创建BFC"><a href="#为什么要创建BFC" class="headerlink" title="为什么要创建BFC"></a>为什么要创建BFC</h4><p>在MDN中单独讲了BFC的两个作用：消除浮动与避免外边距折叠；<br>所以，在正常编程中，我们不用刻意去关心什么是BFC，不过当遇到消除浮动，消除浮动环绕，消除外边距折叠问题时，为了解决这个问题，<br>我们可以创建一个BFC来解决，为什么BFC能解决？<br>因为BFC有自己的特征，一旦元素变成了一个BFC，它就具备了BFC赋给它的特征，而这些特征可以解决上面说的问题。</p><h4 id="消除浮动"><a href="#消除浮动" class="headerlink" title="消除浮动"></a>消除浮动</h4><p>子元素定义float后，父元素的高度变成很小或者0了，这个时候，我们可以将父元素变成一个BFC，而利用BFC上面的特征6，计算BFC的高度时，浮动元素也参与计算 ，这个时候父元素的高度将包含浮动的子元素高度，解决浮动了。<br>由上面可知，将元素定义一个overflow，可以将该元素编程BFC。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.wrap&#123;</span><br><span class="line">    background: red;</span><br><span class="line">    width: 100%;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">.chilid&#123;</span><br><span class="line">    float: left;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 50px; </span><br><span class="line">    background: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;wrap&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;chilid&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h4 id="自适应两栏布局"><a href="#自适应两栏布局" class="headerlink" title="自适应两栏布局"></a>自适应两栏布局</h4><p><a href="https://segmentfault.com/a/1190000009545742" target="_blank" rel="noopener">不多写了，直接参考这里的—&lt;2. 布局：自适应两栏布局&gt;</a>，效果如下：<br><figure class="image-box">                <img src="/image/css/margin3.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="消除外边距折叠"><a href="#消除外边距折叠" class="headerlink" title="消除外边距折叠"></a>消除外边距折叠</h4><p>这里有两个例子<br><a href="https://segmentfault.com/a/1190000009545742" target="_blank" rel="noopener">一个例子，见文中的–防止垂直margin合并</a><br>第二个例子，我们改写下 《外边距折叠》章节的《现象》例子，给wrap添加一个float属性，将.wrap变成一个BFC，利用BFC特征5：BFC就是页面上的一个隔离的独立容器，margin是wrap的一部分，所以margin不受外部影响。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.wrap&#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    float: right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="推荐使用伪类来消除浮动"><a href="#推荐使用伪类来消除浮动" class="headerlink" title="推荐使用伪类来消除浮动"></a>推荐使用伪类来消除浮动</h3><p>参考《精通css》P181，<br>对于小的元素，使用overflow是比较方便，可以使用overflow；<br>对于大的元素，可能元素需要显示滚动条，或者有些定位元素需要放在这个大的元素之外，这时候使用overflow可能产生不利影响，所以大的元素，推荐使用伪元素来实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.row&#123;</span><br><span class="line">    content:&apos;&apos;,</span><br><span class="line">    display:block,</span><br><span class="line">    clear:both,</span><br><span class="line">    height:0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="兼容写法-后退机制"><a href="#兼容写法-后退机制" class="headerlink" title="兼容写法(后退机制)"></a>兼容写法(后退机制)</h3><p>background-image写两遍，是为了兼容后退机制写法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.item&#123;</span><br><span class="line">    background-image:url(./column.png); </span><br><span class="line">    background-image:url(./column.png), url(./column1.png), url(./column2.png); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="z-index只用于定位元素"><a href="#z-index只用于定位元素" class="headerlink" title="z-index只用于定位元素"></a>z-index只用于定位元素</h3><p>Z-index 仅能在定位元素上奏效（例如 position:absolute;）！<br>很多人将它用于普通元素，没毛病，属于经典地犯错。</p><h3 id="为什么line-height被默认成元素的height了"><a href="#为什么line-height被默认成元素的height了" class="headerlink" title="为什么line-height被默认成元素的height了"></a>为什么line-height被默认成元素的height了</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;title&gt;wills-react-pro&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    .wrap&#123;</span><br><span class="line">      height: 30px;</span><br><span class="line">      background: blue;</span><br><span class="line">    &#125;</span><br><span class="line">    .test&#123;</span><br><span class="line">      line-height: 60px;</span><br><span class="line">      display: inline-block;</span><br><span class="line">      background: red;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;wrap&quot;&gt; </span><br><span class="line">      &lt;span style=&quot;line-height:20px;&quot;&gt;</span><br><span class="line">        test&lt;span class=&quot;test&quot;&gt;最高1&lt;/span&gt;的值</span><br><span class="line">      &lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="/image/css/line-height1.jpg" alt="" title="" class="">                <p></p>            </figure><figure class="image-box">                <img src="/image/css/line-height2.jpg" alt="" title="" class="">                <p></p>            </figure><p>可以看到.test 的span的高度完全被其line-height所确定了，变成60px；<br>其他实验结果有，当给.test 的span设置display: inline;span为行内元素，span没有高度，其高度变成父层高度30px,但是span依然会撑开60px的空间：<br><figure class="image-box">                <img src="/image/css/line-height3.jpg" alt="" title="" class="">                <p></p>            </figure></p><p>小结：对inline还是inline-block，在没有定义它对height时，line-height会被默认为元素高度；<br>此时可以通过给元素定义height达到指定高度的目的，但是line-height比height高的情况下，依然会让元素占满line-height的高度。</p><p>所以在开发时，遇到很多奇葩的元素高度从何而来时，不要指想着height，认为在谷歌浏览器上找不到height就很奇怪这个高度是怎么来的，你还需查看是否是其line-height生成的height。<br>另外，不要随意定义line-height，可能会导致意想不到问题。</p><h3 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>参考 博客《css布局》<br>视口的独有尺寸，vh，vw，</p><h4 id="vh-vw-运用"><a href="#vh-vw-运用" class="headerlink" title="vh/vw 运用"></a>vh/vw 运用</h4><p>vh其实很简单，就是相对视口的1%的长度意思。<br>参考《四种居中方式 — 视口vh方法》<br>参考《分辨率\像素\视口 与 移动开发》</p><h3 id="css编写的建议"><a href="#css编写的建议" class="headerlink" title="css编写的建议"></a>css编写的建议</h3><h4 id="关于媒体查询的使用"><a href="#关于媒体查询的使用" class="headerlink" title="关于媒体查询的使用"></a>关于媒体查询的使用</h4><p>将媒体查询当做最后选择，如果你页面布局足够灵活，可能只需要少量的媒体查询即可，所以解决问题时，优先灵活解决，然后再考虑媒体查询。</p><h4 id="css-书写原则"><a href="#css-书写原则" class="headerlink" title="css 书写原则"></a>css 书写原则</h4><p>尽量不要使用id</p><h3 id="流转块的三种方式"><a href="#流转块的三种方式" class="headerlink" title="流转块的三种方式"></a>流转块的三种方式</h3><ul><li>设置：display:block；</li><li>对inline元素设置float；</li><li>对inline元素设置position:absolute/fixed；<br>大家对第一种熟悉，但没想到后面两种也可以流转块；</li></ul><h3 id="vertical-align、行盒子、baseline"><a href="#vertical-align、行盒子、baseline" class="headerlink" title="vertical-align、行盒子、baseline"></a>vertical-align、行盒子、baseline</h3><p>参考博客《vertical-align、行盒子、baseline》</p><h3 id="分辨率-像素-视口-与-移动开发"><a href="#分辨率-像素-视口-与-移动开发" class="headerlink" title="分辨率\像素\视口 与 移动开发"></a>分辨率\像素\视口 与 移动开发</h3><p>参考博客《css之移动开发》</p><h3 id="css之布局"><a href="#css之布局" class="headerlink" title="css之布局"></a>css之布局</h3><p>参考博客《css之布局》</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mac和linux笔记</title>
      <link href="/2019/05/21/mac_linux/"/>
      <url>/2019/05/21/mac_linux/</url>
      
        <content type="html"><![CDATA[<h3 id="显示用户目录"><a href="#显示用户目录" class="headerlink" title="显示用户目录"></a>显示用户目录</h3><p>MAC电脑默认隐藏了你的用户目录，所以才找不到。<br>在finder的偏好设置中选择“边栏”选中个人收藏下“房子的图标”，这样就用户目录，然后在边栏就可以看到用户目录，然后就可以找到目录了</p><h3 id="切换大写"><a href="#切换大写" class="headerlink" title="切换大写"></a>切换大写</h3><p>长按 caps lock 直至灯亮就是大写，短按变小写。</p><h3 id="有关echo"><a href="#有关echo" class="headerlink" title="有关echo"></a>有关echo</h3><p>echo类似console.log，日志打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $ PATH</span><br></pre></td></tr></table></figure></p><h3 id="linux下关键字"><a href="#linux下关键字" class="headerlink" title="linux下关键字"></a>linux下关键字</h3><h4 id="whoami"><a href="#whoami" class="headerlink" title="whoami"></a>whoami</h4><p>我是谁</p><h4 id="date"><a href="#date" class="headerlink" title="date"></a>date</h4><p>系统日期<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jsdeiMac:~ xhkj$ date</span><br><span class="line">2019年 5月19日 星期日 23时50分00秒 CST</span><br><span class="line">jsdeiMac:~ xhkj$ whoami</span><br><span class="line">xhkj</span><br></pre></td></tr></table></figure></p><h4 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h4><p>sudo是linux下的一个使用最高权限执行命令的关键字，<br>此命令需要输入用户密码</p>]]></content>
      
      
      <categories>
          
          <category> mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>node模块</title>
      <link href="/2019/05/21/node_module/"/>
      <url>/2019/05/21/node_module/</url>
      
        <content type="html"><![CDATA[<h2 id="node好用模块"><a href="#node好用模块" class="headerlink" title="node好用模块"></a>node好用模块</h2><h3 id="nodemon"><a href="#nodemon" class="headerlink" title="nodemon"></a>nodemon</h3><p>一款用于 使用node启动的项目，监听当项目文件变动时，自动启动类似npm start命令的模块。<br><a href="https://github.com/YeWills/koa-demo/tree/master" target="_blank" rel="noopener">demo示例</a></p><h4 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h4><p>使用非常简单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//package.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;koa-book-pro&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;server/index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;nodemon ./start.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;author&quot;: &quot;YeWills&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;MIT&quot;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;koa&quot;: &quot;^2.4.1&quot;,</span><br><span class="line">    &quot;koa-bodyparser&quot;: &quot;^4.2.1&quot;,</span><br><span class="line">    &quot;koa-router&quot;: &quot;^7.4.0&quot;,</span><br><span class="line">    &quot;koa-static&quot;: &quot;^5.0.0&quot;,</span><br><span class="line">    &quot;koa2-cors&quot;: &quot;^2.0.6&quot;,</span><br><span class="line">    &quot;nodemon&quot;: &quot;^1.18.10&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>package.json 同级目录下 配置 nodemon.json<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//nodemon.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;restartable&quot;: &quot;rs&quot;,</span><br><span class="line">  &quot;ignore&quot;: [</span><br><span class="line">    &quot;.git&quot;,</span><br><span class="line">    &quot;node_modules/**/node_modules&quot;,</span><br><span class="line">    &quot;README.md&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;verbose&quot;: true,</span><br><span class="line">  &quot;execMap&quot;: &#123;</span><br><span class="line">    &quot;js&quot;: &quot;node --harmony&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;watch&quot;: [</span><br><span class="line">    &quot;server/&quot;,</span><br><span class="line">    &quot;src/&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;ext&quot;: &quot;js json&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后用npm start 启动项目，files改变时，会自动npm start，非常好用。<br><a href="http://www.cnblogs.com/JuFoFu/p/5140302.html" target="_blank" rel="noopener">关于上面代码的解释</a><br>或自行查询GitHub官网</p><h4 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h4><p>以上代码注意的是:<br>nodemon.json 中 js属性配置了 node –harmony 命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;execMap&quot;: &#123;</span><br><span class="line">   &quot;js&quot;: &quot;node --harmony&quot;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure></p><p>那么请在 package.json中 start中，把node关键字去掉<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//正确配置</span><br><span class="line"> &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;nodemon ./start.js&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//错误配置 ，配置了多余的node</span><br><span class="line"> &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;nodemon node ./start.js&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> nodemon </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js设计模式上(面向对象、闭包、命名空间)</title>
      <link href="/2019/05/21/js_design_start/"/>
      <url>/2019/05/21/js_design_start/</url>
      
        <content type="html"><![CDATA[<p>js设计模式分两篇来写，此为上篇。下篇为《js设计模式下》。<br>js设计模式之前需要了解js的面向对象编程、闭包、命名空间编程模式的概念。</p><h1 id="js的面向对象编程"><a href="#js的面向对象编程" class="headerlink" title="js的面向对象编程"></a>js的面向对象编程</h1><p>注意，这里说的是js的面向对象编程，非java面向对象编程。js的面向对象编程与java是有区别的。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>js面向对象编程的核心概念是 类 和 实例(对象)。<br>类 在es6上就是 class类，在es5中就是构造函数中定义一系列的propoty原型<br>实例 就是 new class类，或者 new 构造函数。实例就是对象。<br>而定义类，最后实例化这个类，都是为了得到这个实例对象。重点最终是对象。这就是面向对象的编程。</p><p>简单说，js面向对象编程，就是熟悉使用 class类 来进行js编程。<br>由于react框架的流行，组件都是通过class类编程，因此熟练使用 js的面向对象编程变得更加重要。</p><p>注意的是，js的面向对象编程与java是有区别的。</p><h2 id="new-的理解"><a href="#new-的理解" class="headerlink" title="new 的理解"></a>new 的理解</h2><h3 id="关于new"><a href="#关于new" class="headerlink" title="关于new"></a>关于new</h3><p><a href="https://blog.csdn.net/zhouziyu2011/article/details/60143385" target="_blank" rel="noopener">关于new 的理解</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var baseObj = new Base();</span><br><span class="line">//new操作符具体干了什么呢?其实很简单，就干了三件事情：</span><br><span class="line">var obj  = &#123;&#125;;</span><br><span class="line">var result = Base.call(obj);</span><br><span class="line">obj.__proto__ = Base.prototype;</span><br><span class="line"></span><br><span class="line">if (typeof(result) === &quot;object&quot;)&#123;</span><br><span class="line">  baseObj = result;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">  baseObj = obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是两个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var Test = function()&#123;</span><br><span class="line">            this.html = 1111;</span><br><span class="line">            // return &#123;a:123&#125;;</span><br><span class="line">          &#125;</span><br><span class="line">          var obj = new Test()</span><br><span class="line">          console.log(obj) //&#123;html: 1111&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var Test = function()&#123;</span><br><span class="line">            this.html = 1111;</span><br><span class="line">            return &#123;a:123&#125;;</span><br><span class="line">          &#125;</span><br><span class="line">          var obj = new Test()</span><br><span class="line">          console.log(obj) //&#123;a: 123&#125;</span><br></pre></td></tr></table></figure><h3 id="new-Fn-与-new-Fn的区别"><a href="#new-Fn-与-new-Fn的区别" class="headerlink" title="new Fn() 与 new Fn的区别"></a>new Fn() 与 new Fn的区别</h3><p>function Fn(){<br>    this.name=’weide’;<br>}<br>console.log(new Fn) //Fn {name: “weide”}<br>console.log(new Fn()) //Fn {name: “weide”}<br>看起来二者没有区别，在构造函数Fn不用传参的时候，他们确实没有区别，只有当构造函数需要传参的时候，<br>才必须使用小括号：new Fn()</p><p>下面将讲 面向对象编程三大特征 多态，继承，封装</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>js的多态与java的面向对象多态不同。</p><p>js的多态定义：对同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。<br>以上通俗点的定义就是：对同一个函数作用于不同对象时（也就是同一个函数，接受不同的对象作为参数时），函数执行的结果不同。</p><p>列举多态的几个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//最简单的：</span><br><span class="line">var  a  =  5;</span><br><span class="line">console.log(a);</span><br><span class="line">a=&quot;str&quot;;</span><br><span class="line">console.log(a)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//最经典的：</span><br><span class="line">var makeSound = function(animal) &#123; // 把不变的部分隔离出来</span><br><span class="line">    animal.sound();</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">var Duck = function() &#123;&#125;;</span><br><span class="line">Duck.prototype.sound = function() &#123;</span><br><span class="line">    console.log(&quot;嘎嘎嘎&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">var Chicken = function() &#123;&#125;;</span><br><span class="line">Chicken.prototype.sound = function() &#123;</span><br><span class="line">    console.log(&quot;咯咯咯&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">makeSound( new Duck() ); // 嘎嘎嘎</span><br><span class="line">makeSound( new Chicken() ); // 咯咯咯</span><br></pre></td></tr></table></figure><p>多态的思想实际上是把“做什么”和“谁去做”分离开来，达到 开放-封闭的设计原则。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="原型浅拷贝的痛点"><a href="#原型浅拷贝的痛点" class="headerlink" title="原型浅拷贝的痛点"></a>原型浅拷贝的痛点</h3><p>所有new实例将指向构造函数原型上的引用类型，造成浅拷贝问题，一个实例修改了此引用类型，其他所有实例受此影响。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> function Super()&#123;</span><br><span class="line">    this.colors = [&apos;red&apos;,&apos;blue&apos;,&apos;green&apos;];</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.apples = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">function newF(o, constructor)&#123;</span><br><span class="line">    o.__proto__ = constructor.prototype;</span><br><span class="line">    constructor.call(o); </span><br><span class="line">&#125;</span><br><span class="line">var aa = &#123;&#125;;</span><br><span class="line">var bb = &#123;&#125;;</span><br><span class="line">newF(aa, Super);</span><br><span class="line">newF(bb, Super);</span><br><span class="line">console.log(aa.apples === bb.apples)//true</span><br><span class="line">console.log(aa.colors === bb.colors)//false</span><br></pre></td></tr></table></figure></p><p>以上过程代码等效于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> function Super()&#123;</span><br><span class="line">    this.colors = [&apos;red&apos;,&apos;blue&apos;,&apos;green&apos;];</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.apples = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">var aa = new Super();</span><br><span class="line">var bb = new Super();</span><br><span class="line">console.log(aa.apples === bb.apples)//true</span><br><span class="line">console.log(aa.colors === bb.colors)//false</span><br></pre></td></tr></table></figure></p><p>以上说明了，构造函数 new出来的所有实例，他们会针对同一个构造函数prototype对象被赋值，如果prototype对象里面有引用类型，那么将相互影响，结合上面代码，这情况等同于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> Super.prototype = &#123;apples:&#123;&#125;&#125;;</span><br><span class="line">aa.__proto__ = Super.prototype </span><br><span class="line">//等同于</span><br><span class="line">aa.apples = Super.prototype.apples</span><br></pre></td></tr></table></figure></p><h3 id="es5继承"><a href="#es5继承" class="headerlink" title="es5继承"></a>es5继承</h3><h4 id="套路"><a href="#套路" class="headerlink" title="套路"></a>套路</h4><p>es5继承方法有类继承和原型继承，我们不用去管他们叫什么名字和概念是什么，他们的套路无非三种：<br>1、代理函数(proxy)的构造函数内让父构造函数call一次，就会重写覆盖父构造函数内属性，以此来避免浅拷贝问题。<br>2、将父函数的new 实例对象 赋值给代理函数的prototype。<br>3、将父函数的prototype 赋值给代理函数的prototype。</p><h4 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h4><p>通过以上套路，大致有以下两种方式实现继承：<br>方式一<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//方式一，将父函数的new 实例对象 赋值给代理函数的prototype，弊端 会执行两次父函数</span><br><span class="line"> function Super()&#123;</span><br><span class="line">    this.colors = [&apos;red&apos;,&apos;blue&apos;,&apos;green&apos;];</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.apples = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">function proxy()&#123;</span><br><span class="line">    //执行一次父函数Super</span><br><span class="line">     Super.call(this);</span><br><span class="line">&#125;</span><br><span class="line">//方式一 proxy.prototype直接赋值 new 构造函数</span><br><span class="line">proxy.prototype = new Super();//执行第二次父函数Super</span><br><span class="line">var aa = new proxy();//次步代码 会 重写覆盖父构造函数内属性</span><br><span class="line">var bb = new proxy();</span><br><span class="line">console.log(aa.colors === bb.colors)//true</span><br></pre></td></tr></table></figure></p><p>方式二、此方式与方式一一样，其他代码与方式一都一样，只有一句不同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//方式二，相比方式二的好处在于 父函数 只执行一遍</span><br><span class="line"> ...</span><br><span class="line">proxy.prototype = Super.prototype</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><h4 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h4><p>以上方式都无法解决 prototype 对象的 浅拷贝问题。原因见 《所有new实例将浅拷贝原型上的引用类型 》</p><h4 id="es5最佳继承方式一：与深拷贝函数结合"><a href="#es5最佳继承方式一：与深拷贝函数结合" class="headerlink" title="es5最佳继承方式一：与深拷贝函数结合"></a>es5最佳继承方式一：与深拷贝函数结合</h4><p>传统的继承方式都无法解决prototype的浅拷贝问题，只能引入深拷贝函数，如下代码的deepcopy深拷贝方法，网上有很多，可以去找。<br>所以es5方法写继承最佳方式：父函数.call + proxy.prototype = deepcopy(Super.prototype).<br>简言之 call + 原型赋原型 + 深拷贝<br>作用：<br>call 拷贝 构造函数内属性<br>原型赋原型 拷贝原型方法，避免执行一次父函数<br>深拷贝 避免原型浅拷贝问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Super(name)&#123;</span><br><span class="line">    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.apples = &#123;&#125;;</span><br><span class="line">function Sub(name)&#123;</span><br><span class="line">    Super.call(this);</span><br><span class="line">&#125;</span><br><span class="line">Sub.prototype = deepcopy(Super.prototype);</span><br></pre></td></tr></table></figure><h4 id="es5最佳继承方式二：引用对象不写入父原型上"><a href="#es5最佳继承方式二：引用对象不写入父原型上" class="headerlink" title="es5最佳继承方式二：引用对象不写入父原型上"></a>es5最佳继承方式二：引用对象不写入父原型上</h4><p>es5继承的痛点是无法原型浅拷贝问题，如果能引用对象不写入父原型上，则可放心继承。</p><h3 id="最终极方式：es6-class"><a href="#最终极方式：es6-class" class="headerlink" title="最终极方式：es6 class"></a>最终极方式：es6 class</h3><p>class是es6 的api，是一个语法糖，使用class进行继承，能够轻松进行继承，且无浅拷贝问题。<br>因此推荐使用es6的class类继承方式，代码优雅而简洁，不推荐使用es5。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Super &#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    this.colors = [];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Sub extends Super&#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var instance1 = new Sub();</span><br><span class="line">var instance2 = new Sub();</span><br><span class="line">console.log(instance1.colors === instance2.colors);//false</span><br></pre></td></tr></table></figure><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装这个最好理解，直白的说就是：<br>封装说的就类。类由一系列的方法和属性组成，将一系列的方法和属性封装起来，封装成一个类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class People &#123;</span><br><span class="line">    constructor(name, age) &#123;</span><br><span class="line">        this.name = name</span><br><span class="line">        this.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    eat() &#123;</span><br><span class="line">        alert(`$&#123;this.name&#125; eat something`)</span><br><span class="line">    &#125;</span><br><span class="line">    speak() &#123;</span><br><span class="line">        alert(`My name is $&#123;this.name&#125;, age $&#123;this.age&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p><a href="https://blog.csdn.net/ybdt1201/article/details/53366613" target="_blank" rel="noopener">关于闭包详细知识，可参考我在几年前写的一篇博客，这里只摘取一些必要知识</a>，以下内容基本摘至这篇博客，如有疑问，点击进入了解。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>官方对闭包的定义：所谓“闭包”，指的是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。</p><p>还有一种对闭包更直接明了的说法：<a href="https://www.cnblogs.com/tinkbell/p/3173293.html" target="_blank" rel="noopener">闭包就是有权访问另一个函数作用域中变量的函数。</a><br>分析这句话:<br>　　1.闭包是定义在函数中的函数.<br>　　2.闭包能访问函数内的私有变量.<br>　　3.即使包含函数执行完了, 被闭包引用的变量也得不到释放.</p><p>满足以上定义的，都可称之为闭包。</p><h2 id="三种定义方式"><a href="#三种定义方式" class="headerlink" title="三种定义方式"></a>三种定义方式</h2><p>闭包有三种定义方式，一种就是经典的return方式，一种就是new的方式，一种就是对象方式。<br>我目前看到的闭包就这三种，基本这三种满足了工作中绝大部分需求了。<br>网上有很多人列举了很多闭包方式，其实本质上都是对这三种方式的发展延伸而已。</p><h3 id="return方式"><a href="#return方式" class="headerlink" title="return方式"></a>return方式</h3><p>这种方式最经典，也最为常用，推荐这种写法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function a() &#123;</span><br><span class="line">    var num = 1;</span><br><span class="line">    return function ()&#123;</span><br><span class="line">        num++;</span><br><span class="line">        console.log(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="new-方式"><a href="#new-方式" class="headerlink" title="new 方式"></a>new 方式</h3><p>这种方式之所以被认定为闭包，是因为以下两点理由，下面代码中：<br>1、a是母函数<br>2、inc是a执行后返回，相当于return的函数，此函数绑定了a的私有变量n， 这是决定inc是否为闭包的重要依据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function a()&#123;</span><br><span class="line">  var n = 0;</span><br><span class="line">  this.inc = function () &#123;</span><br><span class="line">    n++;</span><br><span class="line">    console.log(n);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var cc = new a();</span><br><span class="line">cc.inc()//1</span><br><span class="line">cc.inc()//2</span><br></pre></td></tr></table></figure></p><h3 id="对象方式"><a href="#对象方式" class="headerlink" title="对象方式"></a>对象方式</h3><p>下面两个闭包例子，套路都一样，外层定义个对象，然后在母函数内部给这个对象定义一个函数，此函数绑定了私有变量，即为闭包函数。<br>我们姑且称这种定义闭包的方式为对象方式吧。<br>以下方式之所以被认定为闭包，是因为以下两点理由，下面代码中：<br>1、有母函数（下面两个例子母函数是匿名函数，当然也可以定义为非匿名函数）<br>2、母函数执行后，给函数绑定了母函数的私有变量n， 这是决定内部函数是否为闭包的重要依据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">(function() &#123;</span><br><span class="line">    var n = 1;</span><br><span class="line">    obj.count = function () &#123;</span><br><span class="line">                    n++;</span><br><span class="line">                    console.log(n);</span><br><span class="line">                 &#125;;</span><br><span class="line">    </span><br><span class="line">&#125;)()</span><br><span class="line">obj.count();//2</span><br><span class="line">obj.count();//3</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var divDom = $(&apos;#name&apos;);</span><br><span class="line">(function() &#123;</span><br><span class="line">    var n = 1;</span><br><span class="line">    divDom.onclick = function () &#123;</span><br><span class="line">                    n++;</span><br><span class="line">                    console.log(n);</span><br><span class="line">                 &#125;;</span><br><span class="line">    </span><br><span class="line">&#125;)()</span><br><span class="line">divDom.onclick();//2</span><br><span class="line">divDom.onclick();//3</span><br></pre></td></tr></table></figure><h2 id="不是闭包的设计"><a href="#不是闭包的设计" class="headerlink" title="不是闭包的设计"></a>不是闭包的设计</h2><p>列举一下非闭包的设计方式，以此加深对闭包的理解<br>很多人认为自运行匿名函数、命名空间设计模式和原型定义方式都是闭包，我觉得是不对的。</p><h3 id="自运行匿名函数："><a href="#自运行匿名函数：" class="headerlink" title="自运行匿名函数："></a>自运行匿名函数：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//这不是闭包</span><br><span class="line">(function fn()&#123;</span><br><span class="line">          var n = 8;</span><br><span class="line">           console.log(n) ;</span><br><span class="line">      &#125;)();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//这一种是闭包的设计，但并不是因为它是自运行匿名函数的原因，而是因为匿名函数内部return了一个函数的原因，</span><br><span class="line">//这其实就是上面讲的两种闭包设计模式的第一种 return方式</span><br><span class="line">(function fn()&#123;</span><br><span class="line">      var n = 8;</span><br><span class="line">      return function()&#123;</span><br><span class="line">          console.log(n) ;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)();</span><br></pre></td></tr></table></figure><h3 id="js的命名空间写法"><a href="#js的命名空间写法" class="headerlink" title="js的命名空间写法"></a>js的命名空间写法</h3><p>js的命名空间写法不能称之为闭包，它最多是使用了js关于引用对象一处改变，都受改变的特性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//这是命名空间的写法，但不是闭包</span><br><span class="line">var obj = &#123;</span><br><span class="line">  n:8,</span><br><span class="line">  count:function()&#123;</span><br><span class="line">    this.n++;</span><br><span class="line">    console.log(this.n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.count()//9</span><br><span class="line">obj.count()//10</span><br></pre></td></tr></table></figure></p><h3 id="原型定义方式"><a href="#原型定义方式" class="headerlink" title="原型定义方式"></a>原型定义方式</h3><p>还有一些把函数定义在原型上，这本质上也是运用了引用对象的特性，不是闭包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//这不是闭包，是运用了引用对象的特性，才有对象元素值叠加的效果</span><br><span class="line">function a()&#123;</span><br><span class="line">  this.n = 8;</span><br><span class="line">&#125;</span><br><span class="line">a.prototype.count=function()&#123;</span><br><span class="line">  this.n++;</span><br><span class="line">  console.log(this.n);</span><br><span class="line">&#125;</span><br><span class="line">var obj = new a();</span><br><span class="line">obj.count()//9</span><br><span class="line">obj.count()//10</span><br></pre></td></tr></table></figure></p><p> 如果稍微换一下，就行不通了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//这不是闭包</span><br><span class="line">function a()&#123;</span><br><span class="line">  this.n = 8;</span><br><span class="line">&#125;</span><br><span class="line">a.prototype.count=function()&#123;</span><br><span class="line">  this.n++;</span><br><span class="line">  console.log(this.n);</span><br><span class="line">&#125;</span><br><span class="line">var newCount = (new a()).count;</span><br><span class="line">newCount()//NaN</span><br><span class="line">newCount()//NaN</span><br></pre></td></tr></table></figure></p><h2 id="闭包的用处"><a href="#闭包的用处" class="headerlink" title="闭包的用处"></a>闭包的用处</h2><h3 id="定义私有变量"><a href="#定义私有变量" class="headerlink" title="定义私有变量"></a>定义私有变量</h3><p>若不想某些变量被其他函数访问，就可以写一个闭包设计，将变量定义为私有变量，只有闭包函数可以访问，达到其他函数无法访问的目的。</p><h3 id="保存变量值"><a href="#保存变量值" class="headerlink" title="保存变量值"></a>保存变量值</h3><p>这是闭包最经典和关键意义所在，也是闭包函数存在的意义。闭包函数绑定了母函数的变量，每次执行完，此变量不销毁，达到保存变量值的目的。</p><h2 id="运用场景"><a href="#运用场景" class="headerlink" title="运用场景"></a>运用场景</h2><h3 id="保存变量值。"><a href="#保存变量值。" class="headerlink" title="保存变量值。"></a>保存变量值。</h3><h3 id="进行前后两次执行时的比较。"><a href="#进行前后两次执行时的比较。" class="headerlink" title="进行前后两次执行时的比较。"></a>进行前后两次执行时的比较。</h3><h4 id="react-redux的props状态比较"><a href="#react-redux的props状态比较" class="headerlink" title="react-redux的props状态比较"></a>react-redux的props状态比较</h4><p>比如react-redux就是通过闭包的这个特性，保存prop上一次状态，然后跟当前props比较。</p><h4 id="节流和防抖"><a href="#节流和防抖" class="headerlink" title="节流和防抖"></a>节流和防抖</h4><p>这是性能优化经常使用的手段，可以网上查阅，都是用闭包来进行。</p><h4 id="for循环的使用"><a href="#for循环的使用" class="headerlink" title="for循环的使用"></a>for循环的使用</h4><p>错误写法，这种for达不到预期<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//错误写法</span><br><span class="line">function foo()&#123;</span><br><span class="line">    var arr = [];</span><br><span class="line">    for(var i = 0; i &lt; 2; i++)&#123;</span><br><span class="line">        arr[i] = function()&#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">var bar = foo();</span><br><span class="line">console.log(bar[0]());//2</span><br></pre></td></tr></table></figure></p><p>正确写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//正确写法</span><br><span class="line">//为什么能记住当时值，是因为是自运行的函数，每次都会执行一次</span><br><span class="line">function foo()&#123;</span><br><span class="line">    var arr = [];</span><br><span class="line">    for(var i = 0; i &lt; 2; i++)&#123;</span><br><span class="line">        arr[i] = (function fn(j)&#123;</span><br><span class="line">            return function test()&#123;</span><br><span class="line">                return j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">var bar = foo();</span><br><span class="line">console.log(bar[0]());//0</span><br></pre></td></tr></table></figure></p><p>换一种写法，可能更容易理解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//正确写法</span><br><span class="line">function foo()&#123;</span><br><span class="line">    var arr = [];</span><br><span class="line">    for(var i = 0; i &lt; 2; i++)&#123;</span><br><span class="line">        arr[i] = (function fn(j)&#123;</span><br><span class="line">            var _j = j;//定义一个变量，更容易理解</span><br><span class="line">            return function test()&#123;</span><br><span class="line">                return _j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">var bar = foo();</span><br><span class="line">console.log(bar[0]());//0</span><br></pre></td></tr></table></figure></p><h2 id="对闭包的误解"><a href="#对闭包的误解" class="headerlink" title="对闭包的误解"></a>对闭包的误解</h2><p>很多人认为闭包会增加内存，导致内存泄漏，这是错误的，是对闭包的误解。<br>如果你不把变量定义为闭包访问的私有变量，你也一定会把这些变量定义在全局作用域上，全局作用上下文也是不销毁的，一样也是增加了内存。<br>所以闭包并没有增加内存，更没有内存泄漏。<br>如果增加了内存和内存泄漏，其实都是编码水平有待提高导致。</p><h1 id="命名空间模式"><a href="#命名空间模式" class="headerlink" title="命名空间模式"></a>命名空间模式</h1><p>js使用命名空间模式设计，主要是为了避免命名冲突。<br>命名空间设计模式有很多，工作中最常用的是 对象字面量表示法 的设计模式。其他命名空间模式，我觉得应该用的不多，知道一下即可，这里不展开，可以网上查，<a href="https://www.cnblogs.com/syfwhu/p/4885628.html" target="_blank" rel="noopener">也可参考此篇文章</a>。</p><h2 id="对象字面量表示法"><a href="#对象字面量表示法" class="headerlink" title="对象字面量表示法"></a>对象字面量表示法</h2><p>对象字面量表示法是命名空间设计模式的一种，用得最广，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//对象字面量表示法 的命名空间设计模式</span><br><span class="line">var myApplication = &#123;</span><br><span class="line">    // 可以很容易的为对象字面量定义功能</span><br><span class="line">    getInfo:function() &#123;</span><br><span class="line">        // ***</span><br><span class="line">    &#125;,</span><br><span class="line">    // 可以进一步支撑对象命名空间</span><br><span class="line">    models:&#123;&#125;,</span><br><span class="line">    views:&#123;</span><br><span class="line">        pages:&#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    collections:&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="命名空间与设计模式区别"><a href="#命名空间与设计模式区别" class="headerlink" title="命名空间与设计模式区别"></a>命名空间与设计模式区别</h2><p>很多人命名空间的设计模式，是js 单例的设计模式，其实二者完全是两样东西。<br>命名空间偏向于是一种编程规范的设计；<br>js的一些设计模式，例如单例、观察者模式，更多的偏向功能实现方案的js设计模式。如设计绑定和监听时，选择观察者设计模式。<br>所以说，命名空间是一种编程规范，设计模式(如单例，以下设计模式都为这种含义)是一种功能实现的设计方案。</p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js设计模式 </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> 闭包 </tag>
            
            <tag> 命名空间 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>koa2笔记</title>
      <link href="/2019/05/21/koa2/"/>
      <url>/2019/05/21/koa2/</url>
      
        <content type="html"><![CDATA[<h2 id="koa2常用知识"><a href="#koa2常用知识" class="headerlink" title="koa2常用知识"></a>koa2常用知识</h2><h3 id="context的别名"><a href="#context的别名" class="headerlink" title="context的别名"></a>context的别名</h3><p><a href="https://koajs.com/#introduction" target="_blank" rel="noopener">更多参看 官网 Request aliases Response aliases</a><br>摘录部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//Request aliases 下面的简写，都指的是Request</span><br><span class="line">ctx.url  -- ctx.request.url 的别名</span><br><span class="line">ctx.method  -- ctx.request.method 的别名</span><br><span class="line">ctx.header</span><br><span class="line">ctx.path</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//Response aliases 下面的简写，都指的是Request</span><br><span class="line">ctx.body  -- ctx.response.body 的别名</span><br><span class="line">ctx.status  -- ctx.response.status 的别名</span><br></pre></td></tr></table></figure><p>另外 ctx.req 是 ctx.request 的别名；<br>另外 ctx.res 是 ctx.response 的别名；</p><h3 id="POST请求参数的获取"><a href="#POST请求参数的获取" class="headerlink" title="POST请求参数的获取"></a>POST请求参数的获取</h3><p>koa 没有封装获取post请求参数的方法，要么通过ctx.req.on原生方式，要么通过koa-bodyparser</p><h4 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h4><p>使用ctx.req.on原生方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">app.use(async (ctx)=&gt;&#123;</span><br><span class="line">  let postdata=&apos;&apos;;</span><br><span class="line">  ctx.req.on(&apos;data&apos;, (data)=&gt;&#123;</span><br><span class="line">    postdata +=data;</span><br><span class="line">  &#125;)</span><br><span class="line">  ctx.req.on(&apos;end&apos;, ()=&gt;&#123;</span><br><span class="line">    console.log(postdata);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 另起一个git bash 窗口执行以下命令，注意，</span><br><span class="line">//一定用git bash， 因为cmd 没有curl命令</span><br><span class="line">curl -d &quot;param1=abc&amp;param2=qqw&quot; http://localhost:3000/</span><br><span class="line"></span><br><span class="line">// 在npm start 所在的cmd或git bash窗口，会出现 打印：</span><br><span class="line">//param1=abc&amp;param2=qqw</span><br></pre></td></tr></table></figure></p><h4 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h4><p>使用koa-bodyparser方式。koa-bodyparser的底层也是使用ctx.req.on实现的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;)</span><br><span class="line">const bodyparser = require(&apos;koa-bodyparser&apos;)</span><br><span class="line">const app = new Koa()</span><br><span class="line">app.use(bodyparser())</span><br><span class="line">app.use(async (ctx, next)=&gt;&#123;</span><br><span class="line">  let postData = ctx.request.body;</span><br><span class="line">  console.log(postData);</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(3000)</span><br><span class="line"></span><br><span class="line">// 另起一个git bash 窗口执行以下命令，</span><br><span class="line">curl -d &quot;param1=abc&amp;param2=qqw&quot; http://localhost:3000/</span><br><span class="line"></span><br><span class="line">// 在npm start 所在的cmd或git bash窗口，会出现 打印：</span><br><span class="line">//&#123; param1: &apos;abc&apos;, param2: &apos;qqw&apos; &#125;</span><br></pre></td></tr></table></figure></p><h3 id="有关content-type"><a href="#有关content-type" class="headerlink" title="有关content-type"></a>有关content-type</h3><h4 id="先来看一个实例demo，感受下："><a href="#先来看一个实例demo，感受下：" class="headerlink" title="先来看一个实例demo，感受下："></a>先来看一个实例demo，感受下：</h4><p>前端代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fetch(&apos;http://127.0.0.1:3000/test&apos;, &#123;</span><br><span class="line">    method: &apos;GET&apos;, // or &apos;PUT&apos;</span><br><span class="line">    headers: new Headers(&#123;</span><br><span class="line">      &apos;Content-Type&apos;: &apos;image/png&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(res =&gt; res.text())</span><br><span class="line">  .catch(error =&gt; console.error(&apos;Error:&apos;, error))</span><br><span class="line">  .then(response =&gt; console.log(&apos;Success:&apos;, response));</span><br></pre></td></tr></table></figure></p><p>后台代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;)</span><br><span class="line">const bodyparser = require(&apos;koa-bodyparser&apos;)</span><br><span class="line">var cors = require(&apos;koa2-cors&apos;);</span><br><span class="line"></span><br><span class="line">const app = new Koa()</span><br><span class="line">app.use(cors());</span><br><span class="line">app.use(bodyparser())</span><br><span class="line">app.use(async (ctx, next)=&gt;&#123;</span><br><span class="line">  ctx.response.type=&apos;text&apos;;</span><br><span class="line">  ctx.response.body=&apos;&lt;p/&gt;999&lt;p/&gt;&apos;;</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(3000)</span><br></pre></td></tr></table></figure></p><p>页面响应：<br><figure class="image-box">                <img src="/image/koa2/content-type.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/koa2/content-res.png" alt="" title="" class="">                <p></p>            </figure></p><p>后续操作：</p><ul><li>当切换设置不同的ctx.response.type=’text’;对应的Response Header 的 Content-type随之改变</li></ul><h4 id="另外一个实验："><a href="#另外一个实验：" class="headerlink" title="另外一个实验："></a>另外一个实验：</h4><p>前端代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fetch(&apos;http://127.0.0.1:3000/test&apos;, &#123;</span><br><span class="line">  method: &apos;GET&apos;,</span><br><span class="line">  headers: new Headers(&#123;</span><br><span class="line">    &apos;Content-Type&apos;: &apos;image/png&apos;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">.then(res =&gt; res.json())</span><br><span class="line">.catch(error =&gt; console.error(&apos;Error:&apos;, error))</span><br><span class="line">.then(response =&gt; console.log(&apos;Success:&apos;, response));</span><br></pre></td></tr></table></figure></p><p>后台代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;)</span><br><span class="line">const bodyparser = require(&apos;koa-bodyparser&apos;)</span><br><span class="line">var cors = require(&apos;koa2-cors&apos;);</span><br><span class="line"></span><br><span class="line">const app = new Koa()</span><br><span class="line">app.use(cors());</span><br><span class="line">app.use(bodyparser())</span><br><span class="line">app.use(async (ctx, next)=&gt;&#123;</span><br><span class="line">  ctx.response.type=&apos;html&apos;;</span><br><span class="line">  ctx.response.body=&#123;data:&apos;Hello World&apos;&#125;;</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(3000)</span><br></pre></td></tr></table></figure></p><p>发现的现象：</p><ul><li>设置不同的ctx.response.type=’html’时，Response Header 的 Content-type没有随之改变，还是显示为application/json</li><li>后台ctx.response.body={data:’Hello World’};改成  ctx.response.body=’<html>‘;<br>前台代码不变，发现res.json()解析报错，Unexpected token &lt; in JSON at position 0，<br>将res.json改成res.text就好了</html></li><li>后端实际的数据是json数据(ctx.response.body={data:’Hello World’})，但设置 ctx.response.type=’html’;然而并不影响前台通过res.json()正常解析到正确数据；</li><li>后端实际的数据是json数据(ctx.response.body={data:’Hello World’})，虽然前端设置了自定义Header content-type为image/png，但不影响前端正常解析，前端一样能正常获取数据。</li></ul><h4 id="得出结论："><a href="#得出结论：" class="headerlink" title="得出结论："></a>得出结论：</h4><p>结合上面页面响应的图片中：</p><ul><li>一个请求，有两个content-type,分别是Response Header 和 Request Header上的。</li><li>小区别是 Response Header 的是首字母大写的 Content-type ，Request Header 的是首字母小写的 content-type;</li><li>fetch 的 headers: new Headers({‘Content-Type’: ‘image/png’}) 设置的是 Request Header 的 content-type；</li><li>Response Header 的 Content-type 是 原则上是ctx.response.type控制设置的，但如上例，有时Response Header 的 Content-type 是 浏览器或koa自动识别ctx.response.body数据类型设置的。</li><li>fetch要想正确解析数据，需要根据后台实际数据，使用对应的解析方式，如 res.json() 、res.text()等等，如果解析方式不对，就报错。</li><li>另外注意的是，前端fetch的时候，如果自定义header，而且请求是跨域的，每发一次fetch，可能会产生两次请求，具体分析参见《koa2黑知识 – 跨域请求有时会发两次请求》：</li></ul><h4 id="常见的-content-type值–对应的ctx-response-type："><a href="#常见的-content-type值–对应的ctx-response-type：" class="headerlink" title="常见的 content-type值–对应的ctx.response.type："></a>常见的 content-type值–对应的ctx.response.type：</h4><p>application/json  – ctx.response.type=’json’<br>text/html  – ctx.response.type=’html’<br>image/png  – ctx.response.type=’image/png’<br>text/plain  – ctx.response.type=’text’  浏览器默认text/plain</p><h3 id="设置响应状态码"><a href="#设置响应状态码" class="headerlink" title="设置响应状态码"></a>设置响应状态码</h3><p>通过ctx.status设置，ctx.status是ctx.response.status的别名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;)</span><br><span class="line">const bodyparser = require(&apos;koa-bodyparser&apos;)</span><br><span class="line">var cors = require(&apos;koa2-cors&apos;);</span><br><span class="line"></span><br><span class="line">const app = new Koa()</span><br><span class="line">app.use(cors());</span><br><span class="line">app.use(bodyparser())</span><br><span class="line">app.use(async (ctx, next)=&gt;&#123;</span><br><span class="line">  ctx.response.type=&apos;text&apos;;</span><br><span class="line">  ctx.status=562;</span><br><span class="line">  ctx.response.body=&apos;&lt;p/&gt;999&lt;p/&gt;&apos;;</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(3000)</span><br></pre></td></tr></table></figure></p><p>页面响应：<br><figure class="image-box">                <img src="/image/koa2/status.png" alt="" title="" class="">                <p></p>            </figure></p><h4 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h4><p>koa-bodyparser的底层也是使用ctx.req.on实现的，所以不能同时使用 koa-bodyparser与ctx.req.on，否则，可能报错，<br>详见《koa2黑知识 – koa-bodyparser导致ctx.req.on事件失效》</p><h3 id="如何在koa使用中间件"><a href="#如何在koa使用中间件" class="headerlink" title="如何在koa使用中间件"></a>如何在koa使用中间件</h3><h4 id="中间件是由app-use加载的"><a href="#中间件是由app-use加载的" class="headerlink" title="中间件是由app.use加载的"></a>中间件是由app.use加载的</h4><p>中间件一般都通过 app.use 函数来加载中间件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const app = new Koa()</span><br><span class="line">app.use(cors());</span><br><span class="line">app.use(bodyparser())</span><br><span class="line">app.use(async (ctx, next)=&gt;&#123;</span><br><span class="line">  ctx.response.type=&apos;text&apos;;</span><br><span class="line">  ctx.response.body=&apos;&lt;p/&gt;999&lt;p/&gt;&apos;;</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(3000)</span><br></pre></td></tr></table></figure></p><h4 id="中间件执行顺序"><a href="#中间件执行顺序" class="headerlink" title="中间件执行顺序"></a>中间件执行顺序</h4><p>中间件在 koa中执行顺序，遵循洋葱模型方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](/image/koa2/middle.jpg)</span><br></pre></td></tr></table></figure></p><p>代码展示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">app.use(async (ctx, next)=&gt;&#123;</span><br><span class="line">  console.log(&apos;one start&apos;);</span><br><span class="line">  await next();</span><br><span class="line">  console.log(&apos;one end&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">app.use(async (ctx, next)=&gt;&#123;</span><br><span class="line">  console.log(&apos;two start&apos;);</span><br><span class="line">  await next();</span><br><span class="line">  console.log(&apos;two end&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">app.use(async (ctx, next)=&gt;&#123;</span><br><span class="line">  console.log(&apos;three start&apos;);</span><br><span class="line">  await next();</span><br><span class="line">  console.log(&apos;three end&apos;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// one start</span><br><span class="line">// two start</span><br><span class="line">// three start</span><br><span class="line">// three end</span><br><span class="line">// two end</span><br><span class="line">// one end</span><br></pre></td></tr></table></figure></p><h4 id="next"><a href="#next" class="headerlink" title="next()"></a>next()</h4><p>next()返回一个Promise对象，配合await使用，可以达到阻塞后面程序执行，等待 next() 返回类似reject()才最终执行nex()后面的程序。<br>每个中间件必须使用next()，否则异常。</p><h3 id="写一个中间件"><a href="#写一个中间件" class="headerlink" title="写一个中间件"></a>写一个中间件</h3><p>这里动手写一个logger中间件小demo，用来打印日志：<br>原代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.use(async (ctx, next)=&gt;&#123;</span><br><span class="line">  console.log(ctx.method,ctx.host + ctx.url)</span><br><span class="line">  await next();</span><br><span class="line">  ctx.body = &apos;hellow world&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>动手写一个logger中间件，用于打印日志，改造后如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;)</span><br><span class="line">const app = new Koa()</span><br><span class="line">const logger = async function(ctx, next)&#123;</span><br><span class="line">  console.log(ctx.method,ctx.host + ctx.url)</span><br><span class="line">  await next();</span><br><span class="line">&#125;</span><br><span class="line">app.use(logger)</span><br><span class="line">app.use(async (ctx, next)=&gt;&#123;</span><br><span class="line">  ctx.body = &apos;hellow world&apos;</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(3000)</span><br></pre></td></tr></table></figure></p><h3 id="两种鉴权方式"><a href="#两种鉴权方式" class="headerlink" title="两种鉴权方式"></a>两种鉴权方式</h3><p>一种是广泛使用的Cookie认证模式；<br>一种是基于Token的认证模式, koa中可以结合jsonwebtoken 与 koa-jwt实现Token鉴权.异步到这里了解更多《jsonwebtoken 与 koa-jwt》.<br><a href="https://github.com/YeWills/koa-demo/tree/router-Token" target="_blank" rel="noopener">这里是一个基于Token的鉴权demo</a></p><h3 id="写一个返回文件的接口"><a href="#写一个返回文件的接口" class="headerlink" title="写一个返回文件的接口"></a>写一个返回文件的接口</h3><h4 id="使用fs实现的方式"><a href="#使用fs实现的方式" class="headerlink" title="使用fs实现的方式"></a>使用fs实现的方式</h4><p>写一个接口，可以将本地的文件，返回给客户端,主要使用fs开完成，核心代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const extname = path.extname;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const fpath = path.join(__dirname, &apos;./files/test.xlsx&apos;);</span><br><span class="line">const fstat = await stat(fpath);</span><br><span class="line">if (fstat.isFile()) &#123;</span><br><span class="line">  ctx.type = extname(fpath);</span><br><span class="line">  ctx.body = fs.createReadStream(fpath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function stat(file) &#123;</span><br><span class="line">  return new Promise(function(resolve, reject) &#123;</span><br><span class="line">    fs.stat(file, function(err, stat) &#123;</span><br><span class="line">      if (err) &#123;</span><br><span class="line">        reject(err);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        resolve(stat);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/YeWills/koa-demo/tree/response-file" target="_blank" rel="noopener">完整demo</a>;<br>本demo 参考了 <a href="https://github.com/YeWills/examples" target="_blank" rel="noopener">koa 官网example</a>，koa 官网example挺好，展示了很多功能，如果有需求，可先到这里找示例实现。</p><h4 id="使用koa-static实现的方式"><a href="#使用koa-static实现的方式" class="headerlink" title="使用koa-static实现的方式"></a>使用koa-static实现的方式</h4><p>此方法参见《koa-static》，弊端是，无法自定义路由名称，只能以文件名称为接口url。</p><h3 id="让html在浏览器中访问的四种方法"><a href="#让html在浏览器中访问的四种方法" class="headerlink" title="让html在浏览器中访问的四种方法"></a>让html在浏览器中访问的四种方法</h3><p>本方法同样适用于 jpg、txt、docx等等文件。</p><h4 id="浏览器访问html的前身"><a href="#浏览器访问html的前身" class="headerlink" title="浏览器访问html的前身"></a>浏览器访问html的前身</h4><p>这是一种原始的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">app.use(async (ctx) =&gt; &#123;</span><br><span class="line">    let html = `</span><br><span class="line">  &lt;h1&gt;登录&lt;\h1&gt;</span><br><span class="line">  &lt;form method = &quot;POST&quot; action= &quot;/&quot;&gt;</span><br><span class="line">  &lt;p&gt;用户名&lt;/p&gt;</span><br><span class="line">  &lt;input name=&quot;userName&quot; /&gt;&lt;br/&gt;</span><br><span class="line">  &lt;p&gt;密码&lt;/p&gt;</span><br><span class="line">  &lt;input name=&quot;password&quot; type=&quot;password&quot; /&gt;&lt;br/&gt;</span><br><span class="line">  &lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">  `;</span><br><span class="line">  ctx.body=html;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="koa-view方法一"><a href="#koa-view方法一" class="headerlink" title="koa-view方法一"></a>koa-view方法一</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const views = require(&apos;koa-views&apos;)</span><br><span class="line">const &#123; resolve &#125; = require(&apos;path&apos;)</span><br><span class="line">const handlePath = path =&gt; resolve(__dirname, path)</span><br><span class="line">app.use(views(handlePath(&apos;../pages&apos;)), &#123;</span><br><span class="line">  extension: &apos;html&apos;</span><br><span class="line">&#125;)</span><br><span class="line">router.get(&apos;/gethtml&apos;, async (ctx, next) =&gt; &#123;</span><br><span class="line">    await ctx.render(&apos;/static/test.html&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="koa-view方法二"><a href="#koa-view方法二" class="headerlink" title="koa-view方法二"></a>koa-view方法二</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const views = require(&apos;koa-views&apos;)</span><br><span class="line">const &#123; resolve &#125; = require(&apos;path&apos;)</span><br><span class="line">const handlePath = path =&gt; resolve(__dirname, path)</span><br><span class="line">app.use(views(handlePath(&apos;../pages&apos;)), &#123;</span><br><span class="line">  extension: &apos;html&apos;</span><br><span class="line">&#125;)</span><br><span class="line">app.use(async (ctx) =&gt; &#123;</span><br><span class="line">    await ctx.render(&apos;/static/test.html&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">// 缺点在于无法访问到 http://localhost:3000/abc 此路由，都会被截获转发上面的/static/test.html</span><br><span class="line">router.get(&apos;/abc&apos;, async (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.body=&apos;888999&apos;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="koa-static方法一"><a href="#koa-static方法一" class="headerlink" title="koa-static方法一"></a>koa-static方法一</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const serve = require(&apos;koa-static&apos;)</span><br><span class="line">const &#123; resolve &#125; = require(&apos;path&apos;)</span><br><span class="line">const handlePath = path =&gt; resolve(__dirname, path)</span><br><span class="line">// http://localhost:3000/redis.html</span><br><span class="line">app.use(serve(handlePath(&apos;../pages/static/test_redirect&apos;)))</span><br><span class="line">// http://localhost:3000</span><br><span class="line">app.use(async (ctx) =&gt; &#123;</span><br><span class="line">  ctx.redirect(&apos;/redis.html&apos;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="最佳方法-koa-static方法二"><a href="#最佳方法-koa-static方法二" class="headerlink" title="最佳方法(koa-static方法二)"></a>最佳方法(koa-static方法二)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const serve = require(&apos;koa-static&apos;)</span><br><span class="line">const &#123; resolve &#125; = require(&apos;path&apos;)</span><br><span class="line">const handlePath = path =&gt; resolve(__dirname, path)</span><br><span class="line">// 在static内定义一个index.html，利用服务器默认找index.html特性</span><br><span class="line">app.use(serve(handlePath(&apos;../pages/static&apos;)))</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>在浏览器中输入<a href="http://localhost:3000，然后显示自己的index.html文件，一般使用的是koa-static或者是koa-views来实现。" target="_blank" rel="noopener">http://localhost:3000，然后显示自己的index.html文件，一般使用的是koa-static或者是koa-views来实现。</a><br>最好的方法是使用koa-static来做，好处多多,窍门在于给在static内定义一个index.html，利用服务器默认找index.html特性，这样在浏览器中只干干净净显示url <a href="http://localhost:3000，非常好，而且koa-static自己封装路由处理很好，不会影响你在koa中定义的其他路由。" target="_blank" rel="noopener">http://localhost:3000，非常好，而且koa-static自己封装路由处理很好，不会影响你在koa中定义的其他路由。</a><br>用koa-view也能达到目的，局限性大，会让你定义的其他路由失效,如果有疑问，可以用下面的demo测试研究一番。<br><a href="https://github.com/YeWills/koa-demo/tree/show-file-in-Browser" target="_blank" rel="noopener">以上四种情况，详细的demo</a></p><h3 id="前后端一体的小demo"><a href="#前后端一体的小demo" class="headerlink" title="前后端一体的小demo"></a>前后端一体的小demo</h3><p>通过对上面两节的总结，写了一个有图片、xls、正常json的三种接口，<br>以及前端对于这三种不同类型数据如何处理。<br>本demo也可用于理解blob。<br><a href="https://github.com/YeWills/koa-demo/tree/response-file" target="_blank" rel="noopener">《写一个返回文件的接口 –为同一个demo》</a></p><h3 id="文件上传-file和drap拖拽两种方式"><a href="#文件上传-file和drap拖拽两种方式" class="headerlink" title="文件上传-file和drap拖拽两种方式"></a>文件上传-file和drap拖拽两种方式</h3><p>服务端主要运用 koa-multer。<br><a href="https://github.com/YeWills/file-upload" target="_blank" rel="noopener">详细参考demo</a><br>也可参考：<br>《html笔记–文件上传-file和drap拖拽两种方式》</p><h3 id="截取前端请求方案"><a href="#截取前端请求方案" class="headerlink" title="截取前端请求方案"></a>截取前端请求方案</h3><p>koa启动服务，使用koa-view render 整个编译好的前端工程index.html, 此时index.html自然处于koa的同域名下，index.html发的每个请求都被koa 的app.use截取，在app.use内，再使用《服务端发起请求的方法》，组装数据，修改url，向指定服务器发起请求，而服务器之间请求没有跨域限制，成功的解决跨域。<br>这种方式最理想，因为不用修改后台，因为很多公司升级改造时，后台可以给你提供测试用户账号，因为老的项目客户正在使用，不能修改放开跨域限制的代码,遇到这种场景，就必须使用以上解决跨域的方式。<br><a href="https://github.com/YeWills/koa2_films/tree/forward-cors" target="_blank" rel="noopener">服务端截取请求向另外服务器发请求的demo</a><br>参考《服务端发起请求的方法》了解更多<br>参考《跨域请求有时会发两次请求》了解更多</p><h3 id="服务端发起请求的方法"><a href="#服务端发起请求的方法" class="headerlink" title="服务端发起请求的方法"></a>服务端发起请求的方法</h3><p>服务端发起请求可以轻松实现，koa截取前端请求组装数据后 转发请求的功能。</p><h4 id="http方式"><a href="#http方式" class="headerlink" title="http方式"></a>http方式</h4><p>参考《http》</p><h4 id="request方式"><a href="#request方式" class="headerlink" title="request方式"></a>request方式</h4><p>参考《request-promise-native request》</p><h3 id="ctx-state"><a href="#ctx-state" class="headerlink" title="ctx.state"></a>ctx.state</h3><p>此属性，在做笔记为止，用的比较少，不用深究，用时再了解。<br>Koa 还约定了一个中间件的存储空间 ctx.state。通过 state 可以存储一些数据，比如用户数据，版本信息等。如果你使用 webpack 打包的话，可以使用中间件，将加载资源的方法作为 ctx.state 的属性传入到 view 层，方便获取资源路径。<a href="https://www.jianshu.com/p/d3afa36aa17a" target="_blank" rel="noopener">摘自此文</a></p><h2 id="koa2黑知识"><a href="#koa2黑知识" class="headerlink" title="koa2黑知识"></a>koa2黑知识</h2><h3 id="favicon-ico"><a href="#favicon-ico" class="headerlink" title="/favicon.ico"></a>/favicon.ico</h3><p>我们常加载dom时，会看到有一个/favicon.ico请求，这个是Dom渲染时，默认自带的静态资源。</p><h3 id="this-指向-ctx"><a href="#this-指向-ctx" class="headerlink" title="this 指向 ctx"></a>this 指向 ctx</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.use(async (ctx)=&gt;&#123;</span><br><span class="line"> this; //此this其实就是ctx，就是Context</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&apos;run in 3000&apos;)</span><br></pre></td></tr></table></figure><h3 id="koa-bodyparser导致ctx-req-on事件失效"><a href="#koa-bodyparser导致ctx-req-on事件失效" class="headerlink" title="koa-bodyparser导致ctx.req.on事件失效"></a>koa-bodyparser导致ctx.req.on事件失效</h3><p>下面代码会报错，因为koa-bodyparser的底层就是基于ctx.req.on实现的，如果使用了koa-bodyparser，它可能会劫持ctx.req.on这个事件，导致ctx.req.on事件失效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">app.use(bodyparser())</span><br><span class="line">app.use(async (ctx)=&gt;&#123;</span><br><span class="line">  let postdata=&apos;&apos;;</span><br><span class="line">  ctx.req.on(&apos;data&apos;, (data)=&gt;&#123;</span><br><span class="line">    postdata +=data;</span><br><span class="line">  &#125;)</span><br><span class="line">  ctx.req.on(&apos;end&apos;, ()=&gt;&#123;</span><br><span class="line">    console.log(postdata);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&apos;run in 3000&apos;)</span><br></pre></td></tr></table></figure></p><p>解决的方法也简单，koa-bodyparser本来是为了方便获取ctx.req.on,使用了koa-bodyparser就没必要使用ctx.req.on。<br>或者用kctx.req.on，就不要用koa-bodyparser；</p><h3 id="跨域的两种解决方式"><a href="#跨域的两种解决方式" class="headerlink" title="跨域的两种解决方式"></a>跨域的两种解决方式</h3><h4 id="koa2-cors解决跨域"><a href="#koa2-cors解决跨域" class="headerlink" title="koa2-cors解决跨域"></a>koa2-cors解决跨域</h4><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>var cors = require(‘koa2-cors’);<br>app.use(cors());</p><h5 id="将koa2-cors放在最上面"><a href="#将koa2-cors放在最上面" class="headerlink" title="将koa2-cors放在最上面"></a>将koa2-cors放在最上面</h5><p>将koa2-cors放在最上面，让koa2-cors先于其他中间件执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">app.use(cors()) // 解决跨域，跨域代码最好放在所有中间件前面</span><br><span class="line">const views = require(&apos;koa-views&apos;)</span><br><span class="line">const serve = require(&apos;koa-static&apos;)</span><br><span class="line">const &#123; resolve &#125; = require(&apos;path&apos;)</span><br><span class="line">const handlePath = path =&gt; resolve(__dirname, path)</span><br><span class="line">app.use(serve(handlePath(&apos;../pages/static&apos;)))</span><br><span class="line">app.use(views(handlePath(&apos;../pages&apos;)), &#123;</span><br><span class="line">  extension: &apos;html&apos;</span><br><span class="line">&#125;)</span><br><span class="line">app.use(async (ctx) =&gt; &#123;</span><br><span class="line">  await ctx.render(&apos;index.html&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">app.use(bodyparser())// 解析post参数</span><br><span class="line">app.use(router.routes())// 调用路由中间件</span><br><span class="line">app.use(router.allowedMethods())// 对异常状态码处理</span><br><span class="line">app.listen(3000, ()=&gt;&#123;</span><br><span class="line">  console.log(&apos;server is running at http://localhost:3000&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p>需要修改后台，需要后台放开跨域限制，如果后台已经投产，客户正在使用该后台，那么肯定不能放开跨域限制，这种跨域解决方法就满足不了需求。</p><h4 id="服务端向服务端发请求解决跨域"><a href="#服务端向服务端发请求解决跨域" class="headerlink" title="服务端向服务端发请求解决跨域"></a>服务端向服务端发请求解决跨域</h4><h5 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h5><p>参考《截取前端请求方案》<br>参考《跨域请求有时会发两次请求》<br>参考《跨域请求有时会发两次请求》<br>这里有一个服务端截取前端请求，转发给指定服务器的<a href="https://github.com/YeWills/koa2_films/tree/forward-cors" target="_blank" rel="noopener">demo</a>，不过该demo只做了一个接口的转发,看本例了解下这种模式</p><h5 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h5><p>优点是，不用修改后台，这种方法非常适合后台在使用，而要做产品升级的项目，缺点是，前端项目工程配置麻烦。</p><h3 id="home-id-name-路由对应的url"><a href="#home-id-name-路由对应的url" class="headerlink" title="/home/:id/:name 路由对应的url"></a>/home/:id/:name 路由对应的url</h3><p>router.get(‘/home’  —对应 <a href="http://localhost:3000/home?id=01&amp;name=admin" target="_blank" rel="noopener">http://localhost:3000/home?id=01&amp;name=admin</a><br>router.get(‘/home/:id/:name’  —对应 <a href="http://localhost:3000/home/01/admin" target="_blank" rel="noopener">http://localhost:3000/home/01/admin</a></p><h3 id="跨域请求有时会发两次请求"><a href="#跨域请求有时会发两次请求" class="headerlink" title="跨域请求有时会发两次请求"></a>跨域请求有时会发两次请求</h3><p>当前端fetch自定了header时，且接口跨域时，fetch一次，可能会发两次相同请求，两次请求一次是Request Method: OPTIONS的，<br>一次是Request Method: GET的，<br>原来fetch在发送真正的请求前, 会先发送一个方法为OPTIONS的预请求(preflight request), 用于试探服务端是否能接受真正的请求<a href="https://blog.csdn.net/cc1314_/article/details/78272329" target="_blank" rel="noopener">详细原因参见这里</a>；<br>解决之道就是把自定义headers字段删掉后；<br>或者不要使用require(‘koa2-cors’)的方式解决跨域，可以通过服务端请求服务器的方式解决跨域；<br>因为跨域是浏览器的限制机制，而服务器与服务器之间不存在跨域问题，具体思路：<br>在同域名下通过 koa 截取 项目的所有fetch请求，然后使用 request 模块，通过 request 给另外域名下的服务器发请求,<a href="https://github.com/YeWills/koa2_films/tree/forward-cors" target="_blank" rel="noopener">服务端截取请求向另外服务器发请求的demo</a></p><h3 id="后台报错app有错误日志，也会报跨域错误"><a href="#后台报错app有错误日志，也会报跨域错误" class="headerlink" title="后台报错app有错误日志，也会报跨域错误"></a>后台报错app有错误日志，也会报跨域错误</h3><p>如果配置了koa2-cors解决跨域，但请求时有跨域报错，可能是app.use内部程序执行报错，会导致后台响应异常，然后前台可能显示为跨域限制错误</p><h2 id="koa2模块上"><a href="#koa2模块上" class="headerlink" title="koa2模块上"></a>koa2模块上</h2><h3 id="koa-router"><a href="#koa-router" class="headerlink" title="koa-router"></a>koa-router</h3><h4 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;)</span><br><span class="line">const bodyparser = require(&apos;koa-bodyparser&apos;)</span><br><span class="line">const router = require(&apos;koa-router&apos;)()</span><br><span class="line">var cors = require(&apos;koa2-cors&apos;);</span><br><span class="line">const app = new Koa()</span><br><span class="line"> router.get(&apos;/&apos;, async (ctx, next) =&gt; &#123;</span><br><span class="line">    ctx.response.body = `&lt;h1&gt;index page&lt;/h1&gt;`</span><br><span class="line">&#125;)</span><br><span class="line">router.get(&apos;/home&apos;, async (ctx, next) =&gt; &#123;</span><br><span class="line">    ctx.response.body = &apos;&lt;h1&gt;HOME page&lt;/h1&gt;&apos;</span><br><span class="line">&#125;)</span><br><span class="line">router.get(&apos;/404&apos;, async (ctx, next) =&gt; &#123;</span><br><span class="line">    ctx.response.body = &apos;&lt;h1&gt;404 Not Found&lt;/h1&gt;&apos;</span><br><span class="line">&#125;)</span><br><span class="line">app.use(cors()) // 解决跨域</span><br><span class="line">app.use(bodyparser())// 解析post参数</span><br><span class="line">app.use(router.routes())// 注册路由中间件</span><br><span class="line">app.use(router.allowedMethods())// 对异常状态码处理</span><br><span class="line">app.listen(3000, ()=&gt;&#123;</span><br><span class="line">  console.log(&apos;server is running at http://localhost:3000&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>关键 是在最后使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.use(router.routes())// 调用路由中间件</span><br><span class="line">app.use(router.allowedMethods())// 对异常状态码处理</span><br></pre></td></tr></table></figure></p><p>当然，如果你不想处理异常状态码，完全可以不使用router.allowedMethods(),单独使用router.routes()即可。</p><h4 id="模拟路由中间件"><a href="#模拟路由中间件" class="headerlink" title="模拟路由中间件"></a>模拟路由中间件</h4><p>下面模拟路由写的中间件，可以加深对路由中间件的理解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Router&#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    this._routers = [];</span><br><span class="line">  &#125;</span><br><span class="line">  get(url, handler)&#123;</span><br><span class="line">    this._routers.push(&#123;</span><br><span class="line">      url:url,</span><br><span class="line">      method:&apos;GET&apos;,</span><br><span class="line">      handler</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  routes()&#123;</span><br><span class="line">    return async (ctx, next) =&gt; &#123;</span><br><span class="line">      const &#123;method, url&#125; = ctx;</span><br><span class="line">      const matchedRouter = this._routers.find(r =&gt; r.method === method &amp;&amp; r.url === url);</span><br><span class="line">      if( matchedRouter &amp;&amp;</span><br><span class="line">        matchedRouter.handler)&#123;</span><br><span class="line">          await matchedRouter.handler(context, next);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">          await next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="koa-static"><a href="#koa-static" class="headerlink" title="koa-static"></a>koa-static</h3><h4 id="介绍-和-demo"><a href="#介绍-和-demo" class="headerlink" title="介绍 和 demo"></a>介绍 和 demo</h4><p>koa-static是静态资源请求中间件，这里写了一个<a href="https://github.com/YeWills/koa-demo/tree/static-views" target="_blank" rel="noopener">简单的demo</a>，可启动感受下，下面以该demo源码作为示例讲解koa-static；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(serve(handlePath(&apos;../pages/static&apos;)))</span><br></pre></td></tr></table></figure></p><p>通过图片可以看出项目静态文件目录结构<br><figure class="image-box">                <img src="/image/koa2/static.jpg" alt="" title="" class="">                <p></p>            </figure></p><p>配置上面这句代码后，你讲可以在浏览器上运行可现实文件内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:3000/css/style.css</span><br><span class="line">http://127.0.0.1:3000/img/films.jpg</span><br></pre></td></tr></table></figure></p><p>注意哦，不是 <a href="http://127.0.0.1:3000/pages/static/css/style.css" target="_blank" rel="noopener">http://127.0.0.1:3000/pages/static/css/style.css</a> !!这个地址是找不到的，很多刚用koa-static时都会犯这个错，认为就是handlePath(‘../pages/static’) 定义的url，然后就拼接成了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//这个地址是访问不到的</span><br><span class="line">http://127.0.0.1:3000/pages/static/css/style.css</span><br></pre></td></tr></table></figure></p><h4 id="理解koa-static"><a href="#理解koa-static" class="headerlink" title="理解koa-static"></a>理解koa-static</h4><p>koa-static是静态资源请求中间件，不过这样说，我们并不能直观理解koa-static是什么，原理是什么。<br>我们大可将koa-static看成是一个 为提供目录下每个文件 配置路由的中间件，<br>只要你提供一个文件的具体位置给koa-static，koa-static会结合路由的功能，为每个该文件位置下的文件配置一个 url 路由；<br>这个url路由其实就是一个普通的接口url，我们将这个普通的url输入浏览器，回车就可以看到改接口url的返回内容；</p><h4 id="koa-static是个批量配置接口url的中间件"><a href="#koa-static是个批量配置接口url的中间件" class="headerlink" title="koa-static是个批量配置接口url的中间件"></a>koa-static是个批量配置接口url的中间件</h4><p>所以，koa-static其实是一个很棒批量配置接口url的中间件，可以为你提供的文件目录下的所有文件批量配置好url接口，<br>你就可以轻松通过此url接口访问此文件。</p><h3 id="koa-views"><a href="#koa-views" class="headerlink" title="koa-views"></a>koa-views</h3><h4 id="介绍-和-demo-1"><a href="#介绍-和-demo-1" class="headerlink" title="介绍 和 demo"></a>介绍 和 demo</h4><p>如果我们只需要ctx.body只需要返回一段简单的代码如下，那么就用不到koa-views。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.response.body = &apos;&lt;h1&gt;404 Not Found&lt;/h1&gt;&apos;</span><br></pre></td></tr></table></figure></p><p>如果我们要ctx.response.body直接返回一个如下复杂的html，这个时候，再去拼接字符串太麻烦，<br>koa-views就是让body返回html变得简单，你直接单独定义好一个html，然后直接引用此html即可，非常方便。<br>koa-views可以用于<strong>普通的html文件</strong>，也可以用于模板引擎，用于模板引擎的时候，可通过ctx.state传值；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let html = `</span><br><span class="line">  &lt;h1&gt;登录&lt;\h1&gt;</span><br><span class="line">  &lt;form method = &quot;POST&quot; action= &quot;/&quot;&gt;</span><br><span class="line">  &lt;p&gt;用户名&lt;/p&gt;</span><br><span class="line">  &lt;input name=&quot;userName&quot; /&gt;&lt;br/&gt;</span><br><span class="line">  &lt;p&gt;密码&lt;/p&gt;</span><br><span class="line">  &lt;input name=&quot;password&quot; type=&quot;password&quot; /&gt;&lt;br/&gt;</span><br><span class="line">  &lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">  `</span><br><span class="line">  ctx.body=html;</span><br></pre></td></tr></table></figure></p><p>这里写了一个<a href="https://github.com/YeWills/koa-demo/tree/static-views" target="_blank" rel="noopener">简单的demo</a>，可启动感受下加深理解。<br>此demo和《koa-static》demo是同一个</p><h4 id="koa-views的使用"><a href="#koa-views的使用" class="headerlink" title="koa-views的使用"></a>koa-views的使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const views = require(&apos;koa-views&apos;)</span><br><span class="line">app.use(views(handlePath(&apos;../pages&apos;)), &#123;</span><br><span class="line">  extension: &apos;html&apos;</span><br><span class="line">&#125;)</span><br><span class="line">app.use(async (ctx) =&gt; &#123;</span><br><span class="line">  await ctx.render(&apos;index.html&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="render是koa-views集成到ctx的"><a href="#render是koa-views集成到ctx的" class="headerlink" title="render是koa-views集成到ctx的"></a>render是koa-views集成到ctx的</h4><p>如上的代码，ctx本身没有render方法，只是使用koa-views中间件后，ctx才有这个方法的</p><h4 id="index-html中静态文件的路径"><a href="#index-html中静态文件的路径" class="headerlink" title="index.html中静态文件的路径"></a>index.html中静态文件的路径</h4><p>请结合上面demo源码看(此demo和《koa-static》demo是同一个)<br>项目路径和请看参看 《koa-static》的图片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(serve(handlePath(&apos;../pages/static&apos;)))</span><br></pre></td></tr></table></figure><p>我们在《koa-static》中知道css和jpg的访问接口url是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:3000/css/style.css</span><br><span class="line">http://127.0.0.1:3000/img/films.jpg</span><br></pre></td></tr></table></figure></p><p>此时，index.html的css和img的路径应该配置为如下，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;</span><br><span class="line">  &lt;title&gt;东成西就&lt;/title&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/style.css&quot;&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;films&quot;&gt;东成西就就是棒！&lt;/div&gt;</span><br><span class="line">  &lt;img src=&quot;/img/films.jpg&quot; /&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h3 id="koa-bodyparser"><a href="#koa-bodyparser" class="headerlink" title="koa-bodyparser"></a>koa-bodyparser</h3><p>此中间件的作用 是 把POST请求的参数解析到ctx.request.body中，koa-bodyparser底层就是基于ctx.req.on实现的。<br>其他信息见《koa-bodyparser导致ctx.req.on事件失效》  《POST请求参数的获取》</p><h3 id="jsonwebtoken-与-koa-jwt"><a href="#jsonwebtoken-与-koa-jwt" class="headerlink" title="jsonwebtoken 与 koa-jwt"></a>jsonwebtoken 与 koa-jwt</h3><p>jsonwebtoken 简称 JWT，用来实现Token的生成、校验和解码。<br>使用koa-jwt中间件可以将 jsonwebtoken与koa有机结合起来。<br>jsonwebtoken 与 koa-jwt 的关系，就跟 redux 与react-redux的关系。<br><a href="https://github.com/YeWills/koa-demo/tree/router-Token" target="_blank" rel="noopener">这里是一个基于Token的鉴权demo</a>。</p><p>使用方法：<br>一般方案为：登录是，koa通过jsonwebtoken给用户一个Token编码，之后客户端发送请求时，在Header上都带上此Token码，<br>后端接受请求时，验证此Token码进行鉴权。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const &#123; sign &#125; = require(&apos;jsonwebtoken&apos;);</span><br><span class="line">const secret = &apos;demo&apos;;</span><br><span class="line">const jwt = require(&apos;koa-jwt&apos;)(&#123; secret &#125;);</span><br><span class="line"></span><br><span class="line">//生成Token，secret作为密钥开发者自定义设置，expiresIn为失效时间，不要设置太久</span><br><span class="line">//登陆成功后，后台通过jsonwebtoken为该用户生成Token编码，</span><br><span class="line">//客户端拿到Token编码后，下次发请求时，在Header中带上Token码</span><br><span class="line">router.post(&apos;/api/login&apos;, async (ctx, next) =&gt; &#123;</span><br><span class="line">    const &#123; username &#125; = ctx.request.body;</span><br><span class="line">    const token = sign(&#123; username &#125;, secret, &#123; expiresIn: &apos;1h&apos; &#125;);</span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">      message: &apos;Get Token Success&apos;,</span><br><span class="line">      code: 1,</span><br><span class="line">      token</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)</span><br><span class="line">  //登录之后的接口请求，都要验证Token，所以都要在Header中将上一步登录是获得的Token传给后台</span><br><span class="line">    .get(&apos;/api/userInfo&apos;, jwt, async ctx =&gt; &#123;</span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">      username: ctx.state.user.username</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><p>http说的是 require(‘http’)模块。<br>koa利用http直接从服务端向其他服务器发起请求，<br>如下，koa服务端，接收到请求时，在路由函数体内，将请求参数重新组装，通过http，转发给对应服务器。<br>这种方法好处之一是避免跨域问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const Http = require(&apos;http&apos;);</span><br><span class="line">router.get(&apos;/&apos;, async (ctx, next) =&gt; &#123;</span><br><span class="line">    let &#123; kw &#125; = ctx.query;</span><br><span class="line">    let resData = await new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">          //http://m.maoyan.com/ajax/search?kw=捉妖记&amp;cityId=10</span><br><span class="line">            Http.request(&#123;</span><br><span class="line">                hostname: &apos;m.maoyan.com&apos;,</span><br><span class="line">                path: &apos;/ajax/search?&apos; + Querystring.stringify(&#123;</span><br><span class="line">                    kw,</span><br><span class="line">                    cityId: 10</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;, (res) =&gt; &#123;</span><br><span class="line">                res.setEncoding(&apos;utf8&apos;);</span><br><span class="line">                let data = [];</span><br><span class="line">                res.on(&apos;data&apos;, (chunk) =&gt; &#123;</span><br><span class="line">                    data.push(chunk)</span><br><span class="line">                &#125;).on(&apos;end&apos;, () =&gt; &#123;</span><br><span class="line">                    resolve(data.join(&apos;&apos;));</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;).end();</span><br><span class="line">        &#125;);</span><br><span class="line">    ctx.body = Render(JSON.parse(resData), kw);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a href="https://github.com/YeWills/koa-demo/tree/http-request" target="_blank" rel="noopener">完整http request的demo</a></p><h3 id="request-promise-native-request"><a href="#request-promise-native-request" class="headerlink" title="request-promise-native request"></a>request-promise-native request</h3><p>以下是自己对request-promise-native request的直观理解，没有深入研究，对不对待考：<br>request-promise-native 可能依赖 request，安装好request-promise-native会自动安装request，<br>所以request-promise-native 和request是一回事，request-promise-native是request的增强版，<br>他们都只做一件事，在服务器发起接口请求，与同为服务器发请求的http效果一样；<br>与浏览器端发请求的fetch axios功能一样，作用的环境不一样而已。</p><p>暂时不用过多了解，用时深究，这里有一个用到request-promise-native request的demo，<br><a href="https://github.com/YeWills/koa-demo/tree/http-request" target="_blank" rel="noopener">完整http request的demo</a>。</p><h3 id="koa-multer"><a href="#koa-multer" class="headerlink" title="koa-multer"></a>koa-multer</h3><p>express或koa，收到前台的上传请求后，因为上传文件的请求时一个多类型文件数据(multipart/form-data)请求，<br>必须通过require(‘multer’)才能正常处理这样的请求。<br>multer就是为了 处理多文件接口而生。<br>multer同koa-multer，去koa-multer的GitHub上，已经说明其文档直接参考express的multer。<br>更多参考《文件上传-file和drap拖拽两种方式》<br>koa-multer 用来做文件上传功能，需要配合 fs模块一起，比较简单，<a href="https://github.com/YeWills/koa-demo/tree/upload-file" target="_blank" rel="noopener">这是文件上传koa-multer 和fs demo</a>。</p><h3 id="fs"><a href="#fs" class="headerlink" title="fs"></a>fs</h3><p>demo和介绍，参考《koa-multer》《写一个返回文件的接口》，这两部分都有demo，使用fs做了一个文件上传和读取本地文件并返回给前台的功能</p><h2 id="koa2模块下"><a href="#koa2模块下" class="headerlink" title="koa2模块下"></a>koa2模块下</h2><h3 id="koa2-cors"><a href="#koa2-cors" class="headerlink" title="koa2-cors"></a>koa2-cors</h3><p>参考《koa2-cors解决跨域》</p><h3 id="querystring"><a href="#querystring" class="headerlink" title="querystring"></a>querystring</h3><p>querystring模块有以下作用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const Querystring = require(&apos;querystring&apos;)</span><br><span class="line">Querystring.escape(&apos;id=1&apos;) //返回 id%3D1</span><br><span class="line">Querystring.unescape(&apos;id%3D1&apos;) //返回 id=1</span><br><span class="line">querystring.parse(&apos;foo=bar&amp;abc=xyz&amp;abc=123&apos;) //返回 &#123;foo: &apos;bar&apos;,abc: [&apos;xyz&apos;, &apos;123&apos;]&#125;</span><br><span class="line">querystring.stringify(&#123; foo: &apos;bar&apos;, baz: [&apos;qux&apos;, &apos;quux&apos;], corge: &apos;&apos; &#125;) // 返回 &apos;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge=&apos;</span><br></pre></td></tr></table></figure></p><p><a href="http://nodejs.cn/api/querystring.html" target="_blank" rel="noopener">更多点击官网</a></p><p><a href="https://github.com/YeWills/koa-demo/tree/http-request" target="_blank" rel="noopener">这里有一个querystring的demo</a></p><h3 id="koa-json、log4js、ip"><a href="#koa-json、log4js、ip" class="headerlink" title="koa-json、log4js、ip"></a>koa-json、log4js、ip</h3><p><a href="https://github.com/YeWills/koa-demo/tree/pro-static" target="_blank" rel="noopener">这里只放一个demo</a>，不深入了解，用到的时候再深究，此demo包含koa-static、log4js与ip、koa-json、koa-nunjucks</p><h3 id="koa-nunjucks"><a href="#koa-nunjucks" class="headerlink" title="koa-nunjucks"></a>koa-nunjucks</h3><p>koa-nunjucks是基于nunjucks的html 模板中间件。<br>没有什么太复杂的需求，只是用koa玩玩，如果不用html模板，用koa-views就可以了，如果要用html模板，可以用koa-nunjucks，当然也可以用ejs模板，等等，有很多这方面的模板。<br>这里只放一个demo，不过多解释，用到的时候再了解。<br><a href="https://github.com/YeWills/koa-demo/tree/web-pro" target="_blank" rel="noopener">koa-nunjucks的使用demo</a></p><h3 id="ejs-pug"><a href="#ejs-pug" class="headerlink" title="ejs pug"></a>ejs pug</h3><p>暂时不用过多了解，用时深究，<a href="https://github.com/YeWills/koa2_films/tree/koa_web" target="_blank" rel="noopener">参见demo</a>。</p><h3 id="puppeteer-parcel-bundler-glob"><a href="#puppeteer-parcel-bundler-glob" class="headerlink" title="puppeteer parcel-bundler  glob"></a>puppeteer parcel-bundler  glob</h3><p>暂时不用过多了解，用时深究，<a href="https://github.com/YeWills/koa2_films/tree/koa_web" target="_blank" rel="noopener">参见demo</a>。</p><h2 id="RESTfull-和-http"><a href="#RESTfull-和-http" class="headerlink" title="RESTfull 和  http"></a>RESTfull 和  http</h2><h3 id="RESTful-规范"><a href="#RESTful-规范" class="headerlink" title="RESTful 规范"></a>RESTful 规范</h3><p>非RESTful规范定义的接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.get(/app/adduser)</span><br><span class="line">router.get(/app/edituser)</span><br><span class="line">router.get(/app/deleteuser)</span><br></pre></td></tr></table></figure></p><p>基于RESTful规范设计的API，全局只提供唯一的URI /app/user<br>设计如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.post(/app/user) //新增用户id</span><br><span class="line">router.edit(/app/user:id) 编辑名字为id的用户</span><br><span class="line">router.delete(/app/user:id) 删除名字为id的用户</span><br></pre></td></tr></table></figure></p><h3 id="URL-的7个部分组成："><a href="#URL-的7个部分组成：" class="headerlink" title="URL 的7个部分组成："></a>URL 的7个部分组成：</h3><p>scheme:[//[user[:password]@]host[:post][/path][?query][#fragemnt]<br>scheme:使用协议 如FTP、HTTP等<br>user[:password] : 表示访问资源的用户和密码，常见于FTP协议<br>host 主机<br>port 端口<br>path 访问资源路径<br>query 请求数据，以？开头<br>fragment 定位锚点，以#开头，可用于快速定位网页对应段落</p><h3 id="常用http状态码"><a href="#常用http状态码" class="headerlink" title="常用http状态码"></a>常用http状态码</h3><p>1<strong> 消息   100 继续，继续响应剩余部分，如已完成，可忽略<br>2</strong> 成功<br>3<strong> 重定向  301 永久移动； 302 临时移动； 304 未修改，请求资源对比上次没有修改<br>4</strong> 请求错误 401 未授权 ； 403 禁止； 404 未找到；<br>5<strong> 和 6</strong> 服务器错误  500 服务器内部错误； 503 服务不可用；</p><h2 id="相关demo"><a href="#相关demo" class="headerlink" title="相关demo"></a>相关demo</h2><h3 id="koa-demo"><a href="#koa-demo" class="headerlink" title="koa-demo"></a>koa-demo</h3><p>主要的示例demo:<a href="https://github.com/YeWills/koa-demo" target="_blank" rel="noopener">koa-demo</a>;</p><h3 id="koa2-films"><a href="#koa2-films" class="headerlink" title="koa2_films"></a>koa2_films</h3><p>很好的综合运行demo(含爬虫，mongodb，koa,前后端一体化编译开发):<a href="https://github.com/YeWills/koa2_films/tree/koa_web" target="_blank" rel="noopener">koa2_films/koa_web</a>,<br>此仓库其他分支还有单纯的 开发后台的分支;<br>也有单纯的爬虫demo：<a href="https://github.com/YeWills/koa2_films/tree/puppeteer" target="_blank" rel="noopener">爬虫小demo</a>；<br>还有一个分支为：<a href="https://github.com/YeWills/koa2_films/tree/event_IO_loop" target="_blank" rel="noopener">nodejs 异步io的理解 阻塞非阻塞，事件循环与驱动，单线程，子进程，进程通讯)events 框架demo</a>；<br><a href="https://github.com/YeWills/koa2_films/tree/forward-cors" target="_blank" rel="noopener">服务端截取请求向另外服务器发请求的demo</a>;</p><h3 id="films-new"><a href="#films-new" class="headerlink" title="films_new"></a>films_new</h3><p><a href="https://github.com/YeWills/react-redux-demo/tree/films_new" target="_blank" rel="noopener">films_new</a>是react-redux-demo仓库下的分支。<br>这是前端代码，用来像后台发起请求。</p><h3 id="koa-miniprogram"><a href="#koa-miniprogram" class="headerlink" title="koa-miniprogram"></a>koa-miniprogram</h3><p>此项目为微信开发，《koa与node.js开发实战》 书第九章以后的代码，在此仓库，我整理成单独几份，暂时没有微信学习，将源码整理备份，以备以后用。<br>其中<a href="https://github.com/YeWills/koa-miniprogram/tree/particle-css" target="_blank" rel="noopener">particle-css分支</a>挺好的一个css页面，同时还有超炫背景粒子-particlesJS插件的使用 效果：</p><h2 id="参考和学习资料"><a href="#参考和学习资料" class="headerlink" title="参考和学习资料"></a>参考和学习资料</h2><p><a href="">koa与node.js开发实战</a><br><a href="">Koa2框架从0开始构建预告片网站</a><br><a href="https://koajs.com/#context" target="_blank" rel="noopener">koa 官网</a><br><a href="https://github.com/koajs/koa#readme" target="_blank" rel="noopener">koa github </a><br><a href="https://github.com/YeWills/examples" target="_blank" rel="noopener">koa example，挺好的官方示例，比较全，做需求时可先在这找示例</a><br><a href="https://www.jianshu.com/p/d3afa36aa17a" target="_blank" rel="noopener">koa2入门笔记</a></p>]]></content>
      
      
      <categories>
          
          <category> koa2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> koa2 </tag>
            
            <tag> 鉴权 </tag>
            
            <tag> content-type </tag>
            
            <tag> RESTfull </tag>
            
            <tag> 解决跨域 </tag>
            
            <tag> 截取前端请求 </tag>
            
            <tag> 服务端转发请求 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mongoose 与 mongodb笔记</title>
      <link href="/2019/05/21/mongoose_mongodb/"/>
      <url>/2019/05/21/mongoose_mongodb/</url>
      
        <content type="html"><![CDATA[<p>关于 mongoose 与 mongodb笔记 暂时以问答方式叙述。</p><h2 id="mongoose-与-mongodb-基本知识"><a href="#mongoose-与-mongodb-基本知识" class="headerlink" title="mongoose 与 mongodb 基本知识"></a>mongoose 与 mongodb 基本知识</h2><h3 id="什么是mongodb服务端和客户端"><a href="#什么是mongodb服务端和客户端" class="headerlink" title="什么是mongodb服务端和客户端"></a>什么是mongodb服务端和客户端</h3><p>启动mongodb服务端，cmd命令为 mongod；这表明在电脑上启动了mongodb服务，启动了mongodb服务端；<br>启动mongodb客户端，cmd命令为 mongo；此命令执行后，cmd处于输入状态，可以对数据库进行增删改查；<br>以上两面命令 都基于mongodb安装目录(C:\Program Files\MongoDB\Server\4.0\bin)下的mongod.exe和mongo.exe；</p><h3 id="在哪些目录下执行mongo等命令才能连接数据库"><a href="#在哪些目录下执行mongo等命令才能连接数据库" class="headerlink" title="在哪些目录下执行mongo等命令才能连接数据库?"></a>在哪些目录下执行mongo等命令才能连接数据库?</h3><p>启动mongodb有两层意思，一个是启动mongodb服务器，一个是启动mongodb的客户端mongo。<br>上面两个动作没有目录限制，这个命令是全局的，在任意目录上都启动cmd都可以操作MongoDB数据库。<br>整个电脑，任何项目创建的数据库，都可以通过任意目录下，启动<br>cmd都可以查到，并且对数据库进行增删改查操作。</p><h3 id="启动mongodb-以及数据库、表格的查看"><a href="#启动mongodb-以及数据库、表格的查看" class="headerlink" title="启动mongodb 以及数据库、表格的查看"></a>启动mongodb 以及数据库、表格的查看</h3><p>主要为两个命令：<br>mongod //启动mongod 服务器，这是一切操作数据库的基础准备工作<br>mongo //启动mongodb客户端，用来连接mongodb并进行相关数据的查询<br>具体步骤如下：</p><h4 id="在任意目录下启动cmd-执行-mongod"><a href="#在任意目录下启动cmd-执行-mongod" class="headerlink" title="在任意目录下启动cmd 执行 mongod;"></a>在任意目录下启动cmd 执行 mongod;</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ mongod</span><br><span class="line">2019-03-24T11:25:33.479+0800 I CONTROL  [main] Automatically disabling TLS 1.0, to force-enable TLS 1.0 specify --sslDisabledProtocols &apos;none&apos;</span><br><span class="line">2019-03-24T11:25:33.483+0800 I CONTROL  [initandlisten] MongoDB starting : pid=8380 port=27017 dbpath=C:\data\db\ 64-bit host=UO4SB7YL9WOZ3OK</span><br><span class="line">2019-03-24T11:25:33.483+0800 I CONTROL  [initandlisten] targetMinOS: Windows 7/Windows Server 2008 R2</span><br><span class="line">2019-03-24T11:25:33.483+0800 I CONTROL  [initandlisten] db version v4.0.6</span><br><span class="line">2019-03-24T11:25:33.483+0800 I CONTROL  [initandlisten] git version: caa42a1f75a56c7643d0b68d3880444375ec42e3</span><br><span class="line">2019-03-24T11:25:33.483+0800 I CONTROL  [initandlisten] allocator: tcmalloc</span><br><span class="line">2019-03-24T11:25:33.483+0800 I CONTROL  [initandlisten] modules: none</span><br><span class="line">2019-03-24T11:25:33.484+0800 I CONTROL  [initandlisten] build environment:</span><br><span class="line">2019-03-24T11:25:33.484+0800 I CONTROL  [initandlisten]     distmod: 2008plus-ssl</span><br><span class="line">2019-03-24T11:25:33.484+0800 I CONTROL  [initandlisten]     distarch: x86_64</span><br><span class="line">2019-03-24T11:25:33.484+0800 I CONTROL  [initandlisten]     target_arch: x86_64</span><br><span class="line">2019-03-24T11:25:33.484+0800 I CONTROL  [initandlisten] options: &#123;&#125;</span><br><span class="line">2019-03-24T11:25:33.486+0800 I STORAGE  [initandlisten] exception in initAndListen: NonExistentPath: Data directory C:\data\db\ not found., terminating</span><br><span class="line">2019-03-24T11:25:33.486+0800 I NETWORK  [initandlisten] shutdown: going to close listening sockets...</span><br><span class="line">2019-03-24T11:25:33.486+0800 I CONTROL  [initandlisten] now exiting</span><br><span class="line">2019-03-24T11:25:33.486+0800 I CONTROL  [initandlisten] shutting down with code:100</span><br></pre></td></tr></table></figure><h4 id="接着执行-mongo；"><a href="#接着执行-mongo；" class="headerlink" title="接着执行 mongo；"></a>接着执行 mongo；</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ mongo</span><br><span class="line">MongoDB shell version v4.0.6</span><br><span class="line">connecting to: mongodb://127.0.0.1:27017/?gssapiServiceName=mongodb</span><br><span class="line">Implicit session: session &#123; &quot;id&quot; : UUID(&quot;4f84c125-8db8-4d3a-ad61-5c85b2817fb7&quot;) &#125;</span><br><span class="line">MongoDB server version: 4.0.6</span><br></pre></td></tr></table></figure><p>此时命令窗口处于等待输入命令的状态，就像输入node后，等待执行的情况。</p><h4 id="数据库、表格的查看；"><a href="#数据库、表格的查看；" class="headerlink" title="数据库、表格的查看；"></a>数据库、表格的查看；</h4><p>此时在此cmd窗口，接着输入以下命令，对数据库进行增删改查：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ mongo</span><br><span class="line">MongoDB shell version v4.0.6</span><br><span class="line">connecting to: mongodb://127.0.0.1:27017/?gssapiServiceName=mongodb</span><br><span class="line">Implicit session: session &#123; &quot;id&quot; : UUID(&quot;4f84c125-8db8-4d3a-ad61-5c85b2817fb7&quot;) &#125;</span><br><span class="line">MongoDB server version: 4.0.6</span><br><span class="line">show dbs  //显示MongoDB目前有多少数据库</span><br><span class="line">admin           0.000GB</span><br><span class="line">config          0.000GB</span><br><span class="line">douban-test     0.000GB</span><br><span class="line">douban-trailer  0.000GB</span><br><span class="line">local           0.000GB</span><br><span class="line">test            0.000GB</span><br><span class="line">yyy             0.000GB</span><br><span class="line">use yyy //使用yyy数据库，use 数据库name，有此name就是用此数据库，没有就是创建数据库</span><br><span class="line">switched to db yyy</span><br><span class="line">show tables //显示数据库有多少表格</span><br><span class="line">fruits</span><br><span class="line">db.fruits.find() //显示 fruits 表格的数据内容</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5c964dbe52f3fd21d06da3a0&quot;), &quot;category&quot; : &quot;apple&quot;, &quot;name&quot; : &quot;apple&quot;, &quot;__v&quot; : 0 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5c964dca541443051483e3c8&quot;), &quot;category&quot; : &quot;apple&quot;, &quot;name&quot; : &quot;apple&quot;, &quot;__v&quot; : 0 &#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/shirly77/p/6536327.html" target="_blank" rel="noopener">更多信息点击</a></p><h3 id="用mongodb原生命令还是mongoose操作数据库？"><a href="#用mongodb原生命令还是mongoose操作数据库？" class="headerlink" title="用mongodb原生命令还是mongoose操作数据库？"></a>用mongodb原生命令还是mongoose操作数据库？</h3><p>在这里只讨论node端。<br>值得注意的是，我们大多不通过mongodb原生命令操作数据库，而是通过mongoose；<br>一个是mongoose 更能优雅地进行MongoDB对象建模，<br>而且Mongoose写了很多mongodb的验证机制、类型转换与业务逻辑模板，然后提供几个简单的api给我们，简化了工作，等等。<br>因此在实际项目开发中，包括连接数据库以及之后的所有操作都是通过mongoose来操作。<br>因此建议不用太去花太多时间去看mongodb的api教程，稍微了解下即可，然后多看看mongoose的相关操作。</p><h3 id="花更多时间学mongodb还是mongoose教程？"><a href="#花更多时间学mongodb还是mongoose教程？" class="headerlink" title="花更多时间学mongodb还是mongoose教程？"></a>花更多时间学mongodb还是mongoose教程？</h3><p>请参看《用mongodb原生命令还是mongoose操作数据库？》。</p><h3 id="要不要手动建文件夹目录data-db？"><a href="#要不要手动建文件夹目录data-db？" class="headerlink" title="要不要手动建文件夹目录data\db？"></a>要不要手动建文件夹目录data\db？</h3><p>我在刚接触 mongodb时，以为启动mongodb要建文件夹目录，用来存放数据库数据，其实不必了。<br>只要在cmd上启动好mongodb服务器就好，其他的就交给项目使用mongoose来操作mongodb就好。<br>不要创建什么数据库文件夹目录。</p><h3 id="经典demo-创建数据库、表格和数据"><a href="#经典demo-创建数据库、表格和数据" class="headerlink" title="经典demo-创建数据库、表格和数据"></a>经典demo-创建数据库、表格和数据</h3><h4 id="demo-代码"><a href="#demo-代码" class="headerlink" title="demo 代码"></a>demo 代码</h4><p>启动mongodb后，在任意目录下，使用node 执行如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const mongoose = require(&apos;mongoose&apos;);</span><br><span class="line">//mongoose.connect 连接mongodb服务器中的数据库，newdbName是数据库名，有则连，无此name数据，就创建</span><br><span class="line">mongoose.connect(&apos;mongodb://localhost:27017/newdbName&apos;,&#123;</span><br><span class="line">    useNewUrlParser:true</span><br><span class="line">&#125;);</span><br><span class="line">//Schema 定义表格Field的类型和规则，这个过程称为 建数据模型</span><br><span class="line">var schema = new mongoose.Schema(&#123; name: &apos;string&apos;, size: &apos;string&apos; &#125;);</span><br><span class="line">//Model 将Schema定义的模型继承过来，生成表格tables,这里生成的名字为 Tank，在数据库中表格名是复数，见《的解释》</span><br><span class="line">var Model = mongoose.model(&apos;Tank&apos;, schema);</span><br><span class="line">//new Model()此方法用来表格数据的增删改查,</span><br><span class="line">var small = new Model(&#123; size: &apos;small&apos; &#125;);</span><br><span class="line">small.save(function (err) &#123;</span><br><span class="line">  if (err) return handleError(err);</span><br><span class="line">  console.log(&apos;创建成功&apos;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="mongodb客户端mongo检测是否生成成功"><a href="#mongodb客户端mongo检测是否生成成功" class="headerlink" title="mongodb客户端mongo检测是否生成成功"></a>mongodb客户端mongo检测是否生成成功</h4><p>将以上代码复制到js中，然后 node 该js试试，如果出现创建成功；<br>然后任意目录下 启动cmd，打开mongodb客户端，查看newdbName数据库是否生成，以下是正常生成的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Administrator@UO4SB7YL9WOZ3OK MINGW64 ~/Desktop</span><br><span class="line">$ mongo</span><br><span class="line">MongoDB shell version v4.0.6</span><br><span class="line">connecting to: mongodb://127.0.0.1:27017/?gssapiServiceName=mongodb</span><br><span class="line">Implicit session: session &#123; &quot;id&quot; : UUID(&quot;a6d3c14e-703d-44d8-851f-60dbb5ad2b9e&quot;) &#125;</span><br><span class="line">MongoDB server version: 4.0.6</span><br><span class="line">show dbs</span><br><span class="line">admin           0.000GB</span><br><span class="line">config          0.000GB</span><br><span class="line">douban-test     0.000GB</span><br><span class="line">douban-trailer  0.000GB</span><br><span class="line">local           0.000GB</span><br><span class="line">newdbName       0.000GB</span><br><span class="line">onedb           0.000GB</span><br><span class="line">test            0.000GB</span><br><span class="line">twodb           0.000GB</span><br><span class="line">yyy             0.000GB</span><br><span class="line">use newdbName</span><br><span class="line">switched to db newdbName</span><br><span class="line">show tables</span><br><span class="line">tanks</span><br><span class="line">db.tanks.find()</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5c974d5df84c0d2b9450f43c&quot;), &quot;size&quot; : &quot;small&quot;, &quot;__v&quot; : 0 &#125;</span><br></pre></td></tr></table></figure><h3 id="mongodb、mongoose概念"><a href="#mongodb、mongoose概念" class="headerlink" title="mongodb、mongoose概念"></a>mongodb、mongoose概念</h3><p>本节内容参考如下，如有疑问点击如下连接详细了解。<br><a href="https://www.cnblogs.com/chris-oil/p/9142795.html" target="_blank" rel="noopener">参考1</a><br><a href="http://www.runoob.com/mongodb/mongodb-databases-documents-collections.html" target="_blank" rel="noopener">参考2</a></p><h4 id="mongodb-与-传统数据库-概念对比"><a href="#mongodb-与-传统数据库-概念对比" class="headerlink" title="mongodb 与 传统数据库 概念对比"></a>mongodb 与 传统数据库 概念对比</h4><figure class="image-box">                <img src="/image/mongodb/db.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="mongodb-、mongoose-与-传统数据库-概念对比"><a href="#mongodb-、mongoose-与-传统数据库-概念对比" class="headerlink" title="mongodb 、mongoose 与 传统数据库 概念对比"></a>mongodb 、mongoose 与 传统数据库 概念对比</h4><p>结合 《经典创建数据库、添加表格和数据 demo》一起看<br><figure class="image-box">                <img src="/image/mongodb/mongoose.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="mongoose核心概念-与-数据库知识-对应关系"><a href="#mongoose核心概念-与-数据库知识-对应关系" class="headerlink" title="mongoose核心概念 与 数据库知识 对应关系"></a>mongoose核心概念 与 数据库知识 对应关系</h4><p>结合 《经典创建数据库、添加表格和数据 demo》一起看<br><figure class="image-box">                <img src="/image/mongodb/index.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li>mongodb中说的集合，其实就是tables，通过model生成；</li><li>mongodb中说的文档，其实就是tables的行数据，通过model实例生成；</li><li>mongoose的重点在Schema和model，其实与数据直接打交道最多的是model；</li><li>至于生成或连接数据库，就是mongoose.connect方法。</li></ul><h3 id="mongoose-model第一个参数的复数才是tables名字！！"><a href="#mongoose-model第一个参数的复数才是tables名字！！" class="headerlink" title="mongoose.model第一个参数的复数才是tables名字！！"></a>mongoose.model第一个参数的复数才是tables名字！！</h3><p>mongoose.model(abc,oneSchema)定义的第一个参数abc,abc并非tables表格名字,它的复数才是，数据库中的表格名字是abces。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let Model = mongoose.model(&quot;fruit&quot;,Schema);</span><br><span class="line">let apple = new Model(&#123;</span><br><span class="line">        category:&apos;apple&apos;,</span><br><span class="line">        name:&apos;apple&apos;</span><br><span class="line">    &#125;);</span><br><span class="line">apple.save()</span><br><span class="line"></span><br><span class="line">cmd中执行命令：</span><br><span class="line">show tables，</span><br><span class="line">名字是fruits,非 fruit。</span><br></pre></td></tr></table></figure></p><h3 id="创建或连接数据库"><a href="#创建或连接数据库" class="headerlink" title="创建或连接数据库"></a>创建或连接数据库</h3><p>创建和连接数据库一般通过mongoose，用的命令都是mongoose.connect。</p><p>在任意目录cmd，然后执行如下命令，看到mongodb服务器中有数据库twodb；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mongo</span><br><span class="line">show dbs</span><br><span class="line">admin           0.000GB</span><br><span class="line">config          0.000GB</span><br><span class="line">local           0.000GB</span><br><span class="line">newdbName       0.000GB</span><br><span class="line">onedb           0.000GB</span><br><span class="line">test            0.000GB</span><br><span class="line">twodb           0.000GB</span><br></pre></td></tr></table></figure></p><p>例如我现在要连接 数据库twodb，步骤如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(&apos;mongodb://localhost:27017/twodb&apos;,&#123;</span><br><span class="line">    useNewUrlParser:true</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如上，mongodb://localhost:27017/ 这是默认写法，twodb是数据库写法，<br>当twodb这个数据库在mongodb存在时，就连接此数据库，当不存在时，就是创建名为twodb的数据库。</p><h3 id="mongodb-localhost-27017-dbName"><a href="#mongodb-localhost-27017-dbName" class="headerlink" title="mongodb://localhost:27017/dbName"></a>mongodb://localhost:27017/dbName</h3><p>我们如果要连接dbName数据库，为什么mongoose.connect的时候，却要写成mongodb://localhost:27017/twodb;<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(&apos;mongodb://localhost:27017/twodb&apos;)</span><br></pre></td></tr></table></figure></p><p>那么为什么要这样呢。<br><strong>原来这是mongodb的标准 URI 连接语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]</span><br></pre></td></tr></table></figure><ul><li>mongodb:// 这是固定的格式，必须要指定。</li><li>username:password@ 可选项，如果设置，在连接数据库服务器之后，驱动都会尝试登陆这个数据库</li><li>host1 必须的指定至少一个host, host1 是这个URI唯一要填写的。它指定了要连接服务器的地址。如果要连接复制集，请指定多个主机地址。</li><li>portX 可选的指定端口，如果不填，默认为27017</li><li>/database 如果指定username:password@，连接并验证登陆指定数据库。若不指定，默认打开 test 数据库。</li><li>?options 是连接选项。如果不使用/database，则前面需要加上/。所有连接选项都是键值对name=value，键值对之间通过&amp;或;（分号）隔开<br>这里就不展开了，<a href="http://www.runoob.com/mongodb/mongodb-connections.html" target="_blank" rel="noopener">更详细的请点击这里了解</a>。</li></ul><p>一般使用mongoose.connect(‘mongodb://localhost:27017/twodb’)连接即可。</p><h3 id="mongodb目录"><a href="#mongodb目录" class="headerlink" title="mongodb目录"></a>mongodb目录</h3><p>C:\Program Files\MongoDB\Server\4.0\bin</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/chris-oil/p/9142795.html" target="_blank" rel="noopener">深入浅出mongoose—–包括mongoose基本所有操作,非常实用!!!!!</a><br><a href="https://www.cnblogs.com/shirly77/p/6536327.html" target="_blank" rel="noopener">mongodb 怎样检测 安装成功 以及mongodb的一些增删改查命令</a><br><a href="http://www.runoob.com/mongodb/mongodb-query.html" target="_blank" rel="noopener">MongoDB 教程</a></p>]]></content>
      
      
      <categories>
          
          <category> mongoose </category>
          
          <category> mongodb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongoose </tag>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React Router</title>
      <link href="/2019/05/21/react_router/"/>
      <url>/2019/05/21/react_router/</url>
      
        <content type="html"><![CDATA[<h2 id="React-Router常见知识"><a href="#React-Router常见知识" class="headerlink" title="React Router常见知识"></a>React Router常见知识</h2><h3 id="HashRouter-还是-BrowserRouter-以及-Router-Route-讲解"><a href="#HashRouter-还是-BrowserRouter-以及-Router-Route-讲解" class="headerlink" title="HashRouter 还是 BrowserRouter 以及 Router  Route 讲解"></a>HashRouter 还是 BrowserRouter 以及 Router  Route 讲解</h3><p>简言之如果项目服务端做了服务端渲染，可以选择BrowserRouter，否则请选择HashRouter，因此一般项目都是HashRouter，因为大多项目么有做服务端渲染。<br>详细见下面（还讲了：利用服务器解析机制，服务器不会解析路由#以后的部分）：<br>摘自《React 实战：设计模式和最佳实践》第15章；<br>react-router 的工作方式，是在组件树顶层放一个 Router 组件，然后在组件树中散落着很多 Route 组件（注意比 Router 少一个“r”），顶层的 Router 组件负责分析监听 URL 的变化，在它保护伞之下的 Route 组件可以直接读取这些信息。</p><p>很明显，Router 和 Route 的配合，就是之前我们介绍过的“提供者模式”，Router 是“提供者”，Route是“消费者”。</p><p>更进一步，Router 其实也是一层抽象，让下面的 Route 无需各种不同 URL 设计的细节，不要以为 URL 就一种设计方法，至少可以分为两种。</p><p>第一种很自然，比如 / 对应 Home 页，/about 对应 About 页，但是这样的设计需要服务器端渲染，因为用户可能直接访问任何一个 URL，服务器端必须能对 /的访问返回 HTML，也要对 /about 的访问返回 HTML。</p><p>第二种看起来不自然，但是实现更简单。<strong>只有一个路径 /，通过 URL 后面的 # 部分来决定路由，/#/ 对应 Home 页，/#/about 对应 About 页。因为 URL 中#之后的部分是不会发送给服务器的，所以，无论哪个 URL，最后都是访问服务器的 / 路径，服务器也只需要返回同样一份 HTML 就可以，然后由浏览器端解析 # 后的部分，完成浏览器端渲染。</strong></p><p>在 react-router，有 BrowserRouter 支持第一种 URL，有 HashRouter 支持第二种 URL。</p><p>因为 create-react-app 产生的应用默认不支持服务器端渲染，为了简单起见，我们在下面的例子中使用 HashRouter，在实际产品中，其实最好还是用 BrowserRouter，这样用户体验更好。</p><p>修改index.js文件，增加下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123;HashRouter&#125; from &apos;react-router-dom&apos;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;HashRouter&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;/HashRouter&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>把 Router 用在 React 组件树的最顶层，这是最佳实践。因为将来我们如果想把 HashRouter 换成 BrowserRouter，组件 App 以下几乎不用任何改变。</p><h3 id="带-与不带-的路由的区别"><a href="#带-与不带-的路由的区别" class="headerlink" title="带#与不带#的路由的区别"></a>带#与不带#的路由的区别</h3><p>利用服务器解析机制，服务器不会解析路由#以后的部分，详细见本章第《HashRouter 还是 BrowserRouter 以及 Router  Route 讲解》</p><h3 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h3><p>摘自《React 实战：设计模式和最佳实践》第15章；<br>我们来看 Content 这个组件，这里会用到 react-router 最常用的两个组件 Route 和 Switch。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const Content = () =&gt; (</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;Switch&gt;</span><br><span class="line">      &lt;Route exact path=&apos;/&apos; component=&#123;Home&#125;/&gt;</span><br><span class="line">      &lt;Route path=&apos;/about&apos; component=&#123;About&#125;/&gt;</span><br><span class="line">    &lt;/Switch&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>Route 组件的 path 属性用于匹配路径，因为我们需要匹配 / 到 Home，匹配 /about 到 About，所以肯定需要两个 Route，但是，我们不能这么写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&apos;/&apos; component=&#123;Home&#125;/&gt;</span><br><span class="line">&lt;Route path=&apos;/about&apos; component=&#123;About&#125;/&gt;</span><br></pre></td></tr></table></figure></p><p>如果按照上面这么写，当访问 /about 页面时，不光匹配 /about，也配中 /，界面上会把 Home 和 About 都渲染出来的。</p><p>解决方法，可以在想要精确匹配的 Route 上加一个属性 exact，或者使用 Switch 组件。</p><p>可以把 Switch 组件看做是 JavaScript 的 switch 语句，像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">switch (条件) &#123;</span><br><span class="line">  case 1: 渲染1; break;</span><br><span class="line">  case 2: 渲染2; break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上往下找第一个匹配的 Route，匹配中了之后，立刻就 break，不继续这个 Switch 下其他的 Route 匹配了。</p><p>可以看到，react-router 巧妙地用 React 组件实现了路由的所有逻辑，印证了那句话：React 世界里一切都是组件。</p><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>摘自《React 实战：设计模式和最佳实践》第15章；<br>在了解了 react-router的基本路由功能之后，再来理解“动态路由”就容易了。</p><p>假设，我们增加一个新的页面叫 Product，对应路径为 /product，但是只有用户登录了之后才显示。如果用静态路由，我们在渲染之前就确定这条路由规则，这样即使用户没有登录，也可以访问 product，我们还不得不在 Product 组件中做用户是否登录的检查。</p><p>如果用动态路由，则只需要在代码中的一处涉及这个逻辑：</p><pre><code>&lt;Switch&gt;  &lt;Route exact path=&apos;/&apos; component={Home}/&gt;  {    isUserLogin() &amp;&amp;    &lt;Route exact path=&apos;/product&apos; component={Product}/&gt;,  }    &lt;Route path=&apos;/about&apos; component={About}/&gt;&lt;/Switch&gt;</code></pre><p>可以用任何条件决定 Route 组件实例是否渲染，比如，可以根据页面宽度、设备类型决定路由规则，动态路由有了最大的自由度。</p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
          <category> React Router </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>webpack笔记</title>
      <link href="/2019/05/21/webpack/"/>
      <url>/2019/05/21/webpack/</url>
      
        <content type="html"><![CDATA[<h2 id="webpack常用知识-上"><a href="#webpack常用知识-上" class="headerlink" title="webpack常用知识 上"></a>webpack常用知识 上</h2><h3 id="sourcemap的处理"><a href="#sourcemap的处理" class="headerlink" title="sourcemap的处理"></a>sourcemap的处理</h3><h4 id="css模块-sourcemap的处理"><a href="#css模块-sourcemap的处理" class="headerlink" title="css模块 sourcemap的处理"></a>css模块 sourcemap的处理</h4><p>给一下loader加上sourceMap: true，就可以做到css的sourcemap调试。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: /\.(sc|c|sa)ss$/,</span><br><span class="line">        use: [</span><br><span class="line">          &apos;style-loader&apos;, &#123;</span><br><span class="line">            loader: &apos;css-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;postcss-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              ident: &apos;postcss&apos;,</span><br><span class="line">              sourceMap: true,</span><br><span class="line">              plugins: (loader) =&gt; [require(&apos;autoprefixer&apos;)(&#123;browsers: [&apos;&gt; 0.15% in CN&apos;]&#125;)]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;sass-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><h4 id="js模块-sourcemap的处理"><a href="#js模块-sourcemap的处理" class="headerlink" title="js模块 sourcemap的处理"></a>js模块 sourcemap的处理</h4><p>很简单，加一个这个配置即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devtool: &apos;inline-source-map&apos;, // 开发阶段开启 sourcemap</span><br></pre></td></tr></table></figure></p><h4 id="要不要配置index-html"><a href="#要不要配置index-html" class="headerlink" title="要不要配置index.html"></a>要不要配置index.html</h4><p>有时候容易误解，webpack会自动生成index.html，这是不对的。<br>入口文件index.html必须要自己手动配置例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//index.html</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>其实webpack只是一个js打包器，会把index.html用到的js全部打包成一个js，就是上面的index.js。<br>只是我们可以通过webpack的插件html-webpack-plugin，写一个index.html模板，不用手动输入index.js的引用，且不用每次手动将index.html拷贝到build目录。<br>将上面的index.html，改成模板，其实就是就是去掉这句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>改成的index.html如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//index.html模板</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>所以在项目中，你必须写一个index.html，或者一个index.html模板。<br>看这个章节加深 项目中index.html 的理解：《webpack常用知识 —解决css文件或者js文件名字哈希值变化的问题》</p><h4 id="output-publicPath-output-path-exports-context-devServer-publicPath"><a href="#output-publicPath-output-path-exports-context-devServer-publicPath" class="headerlink" title="output.publicPath output.path exports.context devServer.publicPath"></a>output.publicPath output.path exports.context devServer.publicPath</h4><ul><li>exports.context 与 output.path<br>exports.context 是提供一个全局的根目录，为配置提供方便,你也可不配置；如果配置此目录下面的output.path 基于此目录。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">context: path.resolve(__dirname, &apos;src&apos;),</span><br><span class="line">output: &#123;</span><br><span class="line">  path: &apos;version1.0.0&apos;,</span><br><span class="line">  publicPath: &apos;/&apos;,</span><br><span class="line">  filename: &apos;assets/[name].[hash:8].js&apos;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ul><p>相当于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  path: path.resolve(__dirname, &apos;version1.0.0/version1.0.0&apos;),</span><br><span class="line">  publicPath: &apos;/&apos;,</span><br><span class="line">  filename: &apos;assets/[name].[hash:8].js&apos;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><ul><li>output.publicPath<br>output.publicPath是给index.html文件内所以link或js引用，在原编辑结果下，在最左侧统一加一个目录，通常也可不配置。<br>如：<br>不加output.publicPath<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">context: path.resolve(__dirname, &apos;src&apos;),</span><br><span class="line">output: &#123;</span><br><span class="line">  path: &apos;version1.0.0&apos;,</span><br><span class="line">  filename: &apos;assets/[name].[hash:8].js&apos;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ul><p>编译出来的index.html为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;robots&quot; content=&quot;noindex, nofollow&quot;&gt;</span><br><span class="line">    &lt;title&gt;React App Pro&lt;/title&gt;</span><br><span class="line">    &lt;link rel=&quot;preload&quot; href=&quot;assets/css/1.db782111.css&quot;  as=&quot;style&quot;&gt;</span><br><span class="line">    &lt;link rel=&quot;preload&quot; href=&quot;assets/css/style.db782111.css&quot;  as=&quot;style&quot;&gt;</span><br><span class="line">    &lt;link rel=&quot;preload&quot; href=&quot;assets/vendors.db782111.js&quot; as=&quot;script&quot;&gt;</span><br><span class="line">    &lt;link rel=&quot;preload&quot; href=&quot;assets/client.db782111.js&quot; as=&quot;script&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot; src=&quot;assets/vendors.db782111.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot; src=&quot;assets/client.db782111.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>加了output.publicPath<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">context: path.resolve(__dirname, &apos;src&apos;),</span><br><span class="line">output: &#123;</span><br><span class="line">  path: &apos;version1.0.0&apos;,</span><br><span class="line">  publicPath: &apos;/&apos;,</span><br><span class="line">  filename: &apos;assets/[name].[hash:8].js&apos;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>编译出来的index.html每个引用路径前都加了一个’/‘<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;preload&quot; href=&quot;/assets/css/1.2e0f42df.css&quot;  as=&quot;style&quot;&gt;</span><br><span class="line">&lt;link rel=&quot;preload&quot; href=&quot;/assets/css/style.2e0f42df.css&quot;  as=&quot;style&quot;&gt;</span><br><span class="line">&lt;link rel=&quot;preload&quot; href=&quot;/assets/vendors.2e0f42df.js&quot; as=&quot;script&quot;&gt;</span><br><span class="line">&lt;link rel=&quot;preload&quot; href=&quot;/assets/client.2e0f42df.js&quot; as=&quot;script&quot;&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;/assets/vendors.2e0f42df.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;/assets/client.2e0f42df.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><ul><li>devServer.publicPath<br>这么没什么说的，默认配置为 ‘/‘，大多时候我们不会去改，使用默认配置。</li></ul><h3 id="给css加前缀-postcss-loader"><a href="#给css加前缀-postcss-loader" class="headerlink" title="给css加前缀  postcss-loader"></a>给css加前缀  postcss-loader</h3><p><a href="https://www.webpackjs.com/loaders/postcss-loader/#options" target="_blank" rel="noopener">postcss-loader</a>有很多用处，其中之一就是给各个浏览器添加css3兼容样式。</p><p>postcss-loader 要与 autoprefixer一起使用， autoprefixer 用来配置 postcss-loader。使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: /\.(sc|c|sa)ss$/,</span><br><span class="line">        use: [</span><br><span class="line">          &apos;style-loader&apos;, &#123;</span><br><span class="line">            loader: &apos;css-loader&apos;,</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;postcss-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              ident: &apos;postcss&apos;,//这里一定要定义一个唯一的名字，一般喜欢定义为postcss，你也可以定义任意其他唯一名字</span><br><span class="line">              //&gt; 0.15% in CN 大致是指兼容什么范围内的浏览器，这样写就行，一定要设置，否则可能不加前缀，</span><br><span class="line">              //且数值一定要设置合适，否则设置浏览器太新，也可能不会生成前缀</span><br><span class="line">              plugins: (loader) =&gt; [require(&apos;autoprefixer&apos;)(&#123;browsers: [&apos;&gt; 0.15% in CN&apos;]&#125;)]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;sass-loader&apos;,</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><p>如上，给postcss-loader配置来options，<strong>如果不配置options，则一定要配置postcss.config.js，</strong>否则会报错。<br>如果配置了  postcss-loader，如果你还使用了happypack,就必须要 在根目录 (通常是webpack.comfig.js同级目录)配置 postcss.config.js。详细请看下面章节 《构建与性能优化–happypack》</p><h3 id="抽离css样式文件"><a href="#抽离css样式文件" class="headerlink" title="抽离css样式文件"></a>抽离css样式文件</h3><p>注意：1.webpack4开始使用mini-css-extract-plugin ，1-3版本可以用 extract-text-webpack-plugin。<br>     2.只有 mode: ‘production’ 插件才生效。<br>     3.开发阶段使用style-loader就行了<br>方法：<br>1.mode: ‘production’<br>2.抽离只需将原先style-loader的对象换成mini-css-extract-plugin；<br>3.配置plugins；</p><p>配置代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">const MiniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;);</span><br><span class="line">...</span><br><span class="line">mode: &apos;production&apos;,</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">        test: /\.(sc|c|sa)ss$/,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader, &#123;</span><br><span class="line">            loader: &apos;css-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;postcss-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              ident: &apos;postcss&apos;,</span><br><span class="line">              sourceMap: true,</span><br><span class="line">              plugins: (loader) =&gt; [require(&apos;autoprefixer&apos;)(&#123;browsers: [&apos;&gt; 0.15% in CN&apos;]&#125;)]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;sass-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line"> ....</span><br><span class="line"> plugins: [</span><br><span class="line">   new MiniCssExtractPlugin(&#123;</span><br><span class="line">     filename: &apos;[name][hash].css&apos;, // 设置最终输出的文件名，这个name最终根据output.filename一致。</span><br><span class="line">     chunkFilename: &apos;[id][hash].css&apos;</span><br><span class="line">   &#125;)</span><br><span class="line"> ],</span><br></pre></td></tr></table></figure><p>以下是css未从html上抽离的原先配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: /\.(sc|c|sa)ss$/,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &apos;style-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,&#123;</span><br><span class="line">            loader: &apos;css-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &apos;postcss-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              ident: &apos;postcss&apos;,</span><br><span class="line">              sourceMap: true,</span><br><span class="line">              plugins: (loader) =&gt; [require(&apos;autoprefixer&apos;)(&#123;browsers: [&apos;&gt; 0.15% in CN&apos;]&#125;)]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;sass-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="压缩css"><a href="#压缩css" class="headerlink" title="压缩css"></a>压缩css</h3><p>所谓压缩代码，就是把css压缩成紧凑的一行。<br>注意：1.webpack5内置压缩 ，4版本可以设置插件optimize-css-assets-webpack-plugin即可。<br>     2.只有 mode: ‘production’ 。<br>配置代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const OptimizeCSSAssetsPlugin = require(&apos;optimize-css-assets-webpack-plugin&apos;);</span><br><span class="line">...</span><br><span class="line">mode: &apos;production&apos;</span><br><span class="line">...</span><br><span class="line">optimization: &#123;</span><br><span class="line">    minimizer: [</span><br><span class="line">      new OptimizeCSSAssetsPlugin(&#123;&#125;), // 压缩CSS插件</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="解决css文件或者js文件名字哈希值变化的问题"><a href="#解决css文件或者js文件名字哈希值变化的问题" class="headerlink" title="解决css文件或者js文件名字哈希值变化的问题"></a>解决css文件或者js文件名字哈希值变化的问题</h3><p>html-webpack-plugin插件，可以把打包后的css或js文件引用直接注入到HTML模板中，这样就不用每次手动修改文件引用了。<br>因此，只要项目中使用了hash，就必须配套使用html-webpack-plugin。<br>另外如果要使用模板html，也必须配套使用html-webpack-plugin。<br>当然，你也可以不使用模板，就算有哈希值，你不怕麻烦，当然也可以不适用html-webpack-plugin,你自己手写html，然后将打包生成的js\css文件手动引用也是可以的。<br>配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">new HtmlWebpackPlugin(&#123;</span><br><span class="line">  title: &apos;AICODER test&apos;, // 默认值：Webpack App</span><br><span class="line">  filename: &apos;index.html&apos;, // 默认值： &apos;index.html&apos;</span><br><span class="line">  template: path.resolve(__dirname, &apos;src/main.html&apos;),</span><br><span class="line">  minify: &#123;</span><br><span class="line">    collapseWhitespace: true, // 折叠空白</span><br><span class="line">    removeComments: true, // 是否移除注释</span><br><span class="line">    removeAttributeQuotes: true // 移除属性的引号</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="每次打包自动清除上一个dist目录"><a href="#每次打包自动清除上一个dist目录" class="headerlink" title="每次打包自动清除上一个dist目录"></a>每次打包自动清除上一个dist目录</h3><p>使用插件：clean-webpack-plugin，配置如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;);</span><br><span class="line">plugins: [</span><br><span class="line">    new CleanWebpackPlugin([&apos;dist&apos;])</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="配置如何解析react-与-jsx"><a href="#配置如何解析react-与-jsx" class="headerlink" title="配置如何解析react 与 jsx"></a>配置如何解析react 与 jsx</h3><p>解决方式如下，可以看到都是通过.babelrc完成，所以要重视.babelrc的作用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//.babelrc</span><br><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    &quot;react&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//package.json</span><br><span class="line"> &quot;babel-preset-react&quot;: &quot;^6.24.1&quot;,</span><br></pre></td></tr></table></figure></p><h3 id="压缩图片"><a href="#压缩图片" class="headerlink" title="压缩图片"></a>压缩图片</h3><p>使用loader：image-webpack-loader，一定在url-loader之前执行image-webpack-loader。<br>image-webpack-loader可以让原来90kb的图片，变成70kb，而不怎么影响质量。<br>配置如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: /\.(png|svg|jpg|gif|jpeg)$/,</span><br><span class="line">        include: [path.resolve(__dirname, &apos;src/&apos;)],</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &apos;url-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: 10000</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;image-webpack-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              mozjpeg: &#123;</span><br><span class="line">                progressive: true,</span><br><span class="line">                quality: 65</span><br><span class="line">              &#125;,</span><br><span class="line">              optipng: &#123;</span><br><span class="line">                enabled: false</span><br><span class="line">              &#125;,</span><br><span class="line">              pngquant: &#123;</span><br><span class="line">                quality: &apos;65-90&apos;,</span><br><span class="line">                speed: 4</span><br><span class="line">              &#125;,</span><br><span class="line">              gifsicle: &#123;</span><br><span class="line">                interlaced: false</span><br><span class="line">              &#125;,</span><br><span class="line">              webp: &#123;</span><br><span class="line">                quality: 75</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><h3 id="file-loader-与-url-loader-异同"><a href="#file-loader-与-url-loader-异同" class="headerlink" title="file-loader 与 url-loader 异同"></a>file-loader 与 url-loader 异同</h3><p>他们都是用来处理项目中图片的。<br>file-loader 有的功能，基本上url-loader都用；<br>而且url-loader还可以将图片进行base64压缩的功能（你可以不使用此功能）；<br>因此，项目中使用url-loader而不适用file-loader。<br>url-loader 配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: /\.(png|svg|jpg|gif|jpeg)$/,</span><br><span class="line">        include: [path.resolve(__dirname, &apos;src/&apos;)],</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &apos;url-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: 10000 //1kb以内的图片将被base64压缩</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><p>url-loader将图片进行base64压缩后就是一串DataURL：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    background: url(data:image/png;base64,UklGRkYwAABXRUJQVlA4WAoAAAAQAAAA/QIA8AAAQUxQSMAcAAABb…KnjLJNbGNAMFRe2WQhUfMAAAA19AAAkbAAAAAAAAAAAAAAABrYAAAAAD0gAAAAAAAAAAAAAAAA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在基本上常用的浏览器和移动端都可很好兼容DataURL，所以可以放心使用。<br>base64压缩图片为一串DataURL的好处在于减少html页面的http请求。缺点在于会加大打包文件大小。<br>一般网页性能优化时：<br>对于小图片，会使用base64压缩，减少http请求；<br>对于大图片，还是使用http请求。</p><h3 id="字体文件处理"><a href="#字体文件处理" class="headerlink" title="字体文件处理"></a>字体文件处理</h3><p>字体文件处理同图片文件处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: /\.(woff|woff2|eot|ttf|otf)$/,</span><br><span class="line">    include: [path.resolve(__dirname, &apos;src/&apos;)],</span><br><span class="line">    use: [</span><br><span class="line">      &#123;</span><br><span class="line">        loader: &apos;file-loader&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><figure class="image-box">                <img src="/image/webpack/proxy1.jpg" alt="" title="" class="">                <p></p>            </figure><figure class="image-box">                <img src="/image/webpack/proxy2.jpg" alt="" title="" class="">                <p></p>            </figure><figure class="image-box">                <img src="/image/webpack/proxy3.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="changeOrigin与其他注意"><a href="#changeOrigin与其他注意" class="headerlink" title="changeOrigin与其他注意"></a>changeOrigin与其他注意</h4><p>代理有三种情况：<br>localhost<br>http的其他主机名<br>https的其他主机名<br>涉及到其他主机名时，要配置changeOrigin: true，<br>涉及到https时，要配置secure: false,不过经测试，不设置secure: false，也可以运行正常<br>详细参考 <a href="https://www.webpackjs.com/configuration/dev-server/#devserver-proxy" target="_blank" rel="noopener">webpack官网 devServer.proxy</a><br><a href="https://github.com/chimurai/http-proxy-middleware" target="_blank" rel="noopener">http-proxy-middleware</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">proxy: &#123;</span><br><span class="line">     &quot;/j&quot;: &#123; </span><br><span class="line">       target: &quot;https://read.douban.com&quot;,</span><br><span class="line">       changeOrigin: true,</span><br><span class="line">       secure: false,</span><br><span class="line">     &#125;,</span><br><span class="line">     &quot;/ajax&quot;: &#123; </span><br><span class="line">       target: &quot;http://m.maoyan.com&quot;,</span><br><span class="line">       changeOrigin: true</span><br><span class="line">     &#125;,</span><br><span class="line">     &quot;/test&quot;: &#123; </span><br><span class="line">       target: &quot;http://127.0.0.1:8080&quot;,</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h3 id="外部扩展-externals"><a href="#外部扩展-externals" class="headerlink" title="外部扩展(externals)"></a>外部扩展(externals)</h3><p> 把一个模块做成外部依赖也就是用cdn的方式依赖，不会打包到 js文件中。<br> 例如lodash,jquery基本上每个页面都要用到，这个时候把它们放在index.html模板中，<br> 每个组件都可以通过externals定义的名称进行引用。<br> 从而可以减少打包后js的大小。<br> 配置如下：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//index.html模板中</span><br><span class="line">&lt;script</span><br><span class="line">  src=&quot;https://code.jquery.com/jquery-3.1.0.js&quot;</span><br><span class="line">  integrity=&quot;sha256-slogkvB1K3VOkzAI8QITxV3VzpOnkeNVsKvtkYLMjfk=&quot;</span><br><span class="line">  crossorigin=&quot;anonymous&quot;&gt;</span><br><span class="line"></span><br><span class="line">  //webpack.config.js</span><br><span class="line">   externals: &#123;  // 把一个模块做成外部依赖，不会打包到 js文件中。</span><br><span class="line">      jquery: &apos;jQuery&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    //index.js使用jquery</span><br><span class="line">    import $ from &apos;jquery&apos;; //注意是小写</span><br></pre></td></tr></table></figure></p><h3 id="webpack-bundle-analyzer统计分析"><a href="#webpack-bundle-analyzer统计分析" class="headerlink" title="webpack-bundle-analyzer统计分析"></a>webpack-bundle-analyzer统计分析</h3><p>注意，这个是在开发环境下使用,配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const BundleAnalyzerPlugin = require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin;</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">   new BundleAnalyzerPlugin(), // 打包模块报表</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure></p><p>配置好后，执行npm start ，会自动在浏览器打开分析页面：<br><figure class="image-box">                <img src="/image/webpack/analyzer.png" alt="" title="" class="">                <p></p>            </figure><br>由图看出，loadsh.js的体积最大，经过分析，可以将loadsh.js做成外部依赖，从而减少打包后js的体积。</p><h3 id="分离-库与业务代码"><a href="#分离-库与业务代码" class="headerlink" title="分离 库与业务代码"></a>分离 库与业务代码</h3><h4 id="配置方法一"><a href="#配置方法一" class="headerlink" title="配置方法一"></a>配置方法一</h4><p>配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">   filename: &apos;[name].[hash].js&apos;, //定义库代码以外的代码打包成的js appIndex.54c949dd739536531ad5.js</span><br><span class="line">   chunkFilename: &apos;[name].chunk.js&apos;,//定义库代码打包成的js customChunkNameQQ.chunk.js</span><br><span class="line">   path: path.resolve(__dirname, &apos;dist&apos;) //打包后输出的路径</span><br><span class="line"> &#125;,</span><br><span class="line">optimization: &#123;</span><br><span class="line">   splitChunks: &#123;</span><br><span class="line">           cacheGroups: &#123;</span><br><span class="line">             commons: &#123;</span><br><span class="line">                chunks: &apos;initial&apos;,</span><br><span class="line">                test: path.resolve(__dirname,&apos;node_modules&apos;),//匹配到的文件都将被一起打包成库js</span><br><span class="line">                enforce: true,</span><br><span class="line">                name: &apos;customChunkNameQQ&apos;,//定义打包后[name]值</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure></p><p>库与业务代码分离 使用的是splitChunks配置，其实它是一个插件，被整合到webpack4了。<br>这个插件的思路是，利用test匹配文件，只要匹配到的就打包成库js，剩下没有被匹配到的，就被打包成业务js；<br>所以如果test匹配不到任何文件，将不会有库js生成，所有的js资源都会被剩下，都被打包到业务js中。</p><p>以下就是一个例子，只有业务js生成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">   appIndex:&apos;./src/index.js&apos;</span><br><span class="line"> &#125;,</span><br><span class="line"> optimization: &#123;</span><br><span class="line">   splitChunks: &#123;</span><br><span class="line">           cacheGroups: &#123;</span><br><span class="line">             commons: &#123;</span><br><span class="line">                chunks: &apos;initial&apos;,</span><br><span class="line">                test: path.resolve(__dirname,&apos;node_modules11&apos;),//因为项目没有node_modules11目录,将只会有一个业务js生成</span><br><span class="line">                enforce: true,</span><br><span class="line">                name: &apos;customChunkNameQQ&apos;,</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p> <strong>webpack打包的原则就是这样，如果没有插件,所有的js将被webpack系统打包成一个js，如果有插件做代码分离，插件匹配的部分将被插件打包成js，剩下的将被webpack系统打包成一个js，如果插件没有匹配到任何js，,所有的js将被webpack系统打包成一个js</strong></p><p>还有其他几种定义方法：</p><h4 id="显示配置方法-推荐"><a href="#显示配置方法-推荐" class="headerlink" title="显示配置方法(推荐)"></a>显示配置方法(推荐)</h4><p>注意下面这个示例配置有一点点问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//将&apos;lodash&apos;,&apos;axios&apos;两个库的代码合并打包成一个名字为customChunkNameQQ 的 js，文件；</span><br><span class="line">//剩下所有js包含其他依赖库和业务js将被合并打包成另个一个js。</span><br><span class="line"> entry: &#123;</span><br><span class="line">    appIndex:&apos;./src/index.js&apos;,</span><br><span class="line">    lodashAndAxios:[&apos;lodash&apos;,&apos;axios&apos;],//显示定义需要将这些依赖库打成一个js</span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">              commons: &#123;</span><br><span class="line">                 chunks: &apos;initial&apos;,</span><br><span class="line">                 test: &apos;lodashAndAxios&apos;, //一定要匹配entry对象内，key值，lodashAndAxios就是entry中的key值</span><br><span class="line">                 enforce: true,</span><br><span class="line">                 name: &apos;customChunkNameQQ&apos;,</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>上面配置有些问题，打包后，会生成三个js：<br><figure class="image-box">                <img src="/image/webpack/verder2.png" alt="" title="" class="">                <p></p>            </figure><br>所以修改以上配置，将cacheGroups.commons.name与cacheGroups.commons.test统一定义成entry中的lodashAndAxios这样生成的文件就正常了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 正确配置方法 --&gt;</span><br><span class="line"> entry: &#123;</span><br><span class="line">    appIndex:&apos;./src/index.js&apos;,</span><br><span class="line">    lodashAndAxios:[&apos;lodash&apos;,&apos;axios&apos;],//显示定义需要将这些依赖库打成一个js</span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">              commons: &#123;</span><br><span class="line">                 chunks: &apos;initial&apos;,</span><br><span class="line">                 test: &apos;lodashAndAxios&apos;, //一定要匹配entry对象内，key值，lodashAndAxios就是entry中的key值</span><br><span class="line">                 enforce: true,</span><br><span class="line">                 name: &apos;lodashAndAxios&apos;,</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>打包结果为：<br><figure class="image-box">                <img src="/image/webpack/verder2.png" alt="" title="" class="">                <p></p>            </figure></p><h4 id="直接用test匹配方法"><a href="#直接用test匹配方法" class="headerlink" title="直接用test匹配方法"></a>直接用test匹配方法</h4><p>上面的方法也可以写成如下，效果一样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//将&apos;lodash&apos;,&apos;axios&apos;两个库的代码合并打包成一个名字为customChunkNameQQ 的 js，文件；</span><br><span class="line">//剩下所有js包含其他依赖库和业务js将被合并打包成另个一个js。</span><br><span class="line"> entry: &#123;</span><br><span class="line">    appIndex:&apos;./src/index.js&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">              commons: &#123;</span><br><span class="line">                 chunks: &apos;initial&apos;,</span><br><span class="line">                 test: /lodash|axios/,  //直接使用test去匹配</span><br><span class="line">                 enforce: true,</span><br><span class="line">                 name: &apos;customChunkNameQQ&apos;,</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><h3 id="entry多种配置形式"><a href="#entry多种配置形式" class="headerlink" title="entry多种配置形式"></a>entry多种配置形式</h3><p>入口可以使用 entry 字段来进行配置，webpack 支持配置多个入口来进行构建：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &apos;./src/index.js&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 上述配置等同于</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: &apos;./src/index.js&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 或者配置多个入口</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    foo: &apos;./src/page-foo.js&apos;,</span><br><span class="line">    bar: &apos;./src/page-bar.js&apos;,</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用数组来对多个文件进行打包</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: [</span><br><span class="line">      &apos;./src/foo.js&apos;,</span><br><span class="line">      &apos;./src/bar.js&apos;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后的例子，可以理解为多个文件作为一个入口，webpack 会解析两个文件的依赖后进行打包。</p><p>还有一种形式，就是使用库与业务代码分离optimization.splitChunks时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//将&apos;lodash&apos;,&apos;axios&apos;两个库的代码合并打包成一个名字为customChunkNameQQ 的 js，文件；</span><br><span class="line">//剩下所有js包含其他依赖库和业务js将被合并打包成另个一个js。</span><br><span class="line"> entry: &#123;</span><br><span class="line">    appIndex:&apos;./src/index.js&apos;,</span><br><span class="line">    lodashAndAxios:[&apos;lodash&apos;,&apos;axios&apos;],//显示定义需要将这些依赖库打成一个js</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">  filename: &apos;[name].[hash].js&apos;,//库js剩下的，也就是所谓的业务js</span><br><span class="line">  chunkFilename: &apos;[name].chunk.js&apos;, //打包出来的库js</span><br><span class="line">  path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">&#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        commons: &#123;</span><br><span class="line">           chunks: &apos;initial&apos;,</span><br><span class="line">           test: &apos;lodashAndAxios&apos;,</span><br><span class="line">           enforce: true,</span><br><span class="line">           name: &apos;lodashAndAxios&apos;,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p><strong>entry 值可以是字符串，可以是对象；当entry为对象时，对象元素的key，value；value可以是字符串，也可以是数组。</strong></p><h3 id="生产与开发环境差异配置"><a href="#生产与开发环境差异配置" class="headerlink" title="生产与开发环境差异配置"></a>生产与开发环境差异配置</h3><p>前面提及的使用环境变量的方式可以让我们在不同的构建环境中完成不同的构建需求，这里列举一下常见的 webpack 构建差异配置：</p><ul><li>生产环境可能需要分离 CSS 成单独的文件，以便多个页面共享同一个 CSS 文件</li><li>生产环境需要压缩 HTML/CSS/JS 代码</li><li>生产环境需要压缩图片</li><li>开发环境需要生成 sourcemap 文件</li><li>开发环境需要打印 debug 信息</li><li>开发环境需要 live reload 或者 hot reload 的功能</li></ul><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ul><li>Entry: 入口。</li><li>Module: 模块。在webpack里，一切皆模块，一个模块对应一个文件，webpack会从配置的entry开始递归找出所有依赖的模块。</li><li>Chunk: 代码块。一个Chunk由多个模块组合而成，用于代码合并和分割。</li><li>loader: 模块转换器。</li><li>Plugin: 扩展插件。</li><li>Output: 输出结果。<br>webpack 在启动后会从Entry里配置的Moule开始，递归解析Entry依赖的所有module，每找到一个module，就会根据配置的loader去找出对应的转换规则，对module进行转换后，再解析出当前module依赖的module。这些模块会以entry为单位进行分组，一个entry及其所有依赖的module被分到一个组也就是一个chunk，最后webpack会将所有chunk转换成文件输出。<br><strong>在webpack中chunk概念很重要，也很不好理解，也容易被忽视，其实webpack目的是一个打包工具，然而将整个包打成几个代码块，都是由chunk控制，所以理解chunk对理解webpack，至关重要。</strong></li></ul><h3 id="babelrc相关"><a href="#babelrc相关" class="headerlink" title=".babelrc相关"></a>.babelrc相关</h3><h4 id="babelrc插件安装"><a href="#babelrc插件安装" class="headerlink" title="babelrc插件安装"></a>babelrc插件安装</h4><p>如下，要安装 syntax-dynamic-import ，实际上安装的是 babel-plugin-syntax-dynamic-import，要在名字前加 babel-plugin-。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    &quot;syntax-dynamic-import&quot;,</span><br><span class="line">    &quot;transform-class-properties&quot;,</span><br><span class="line">    &quot;transform-object-rest-spread&quot;,</span><br><span class="line">    [&quot;module-resolver&quot;, &#123;</span><br><span class="line">      &quot;root&quot;: [&quot;./src&quot;]</span><br><span class="line">    &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="webpack常用知识-下"><a href="#webpack常用知识-下" class="headerlink" title="webpack常用知识 下"></a>webpack常用知识 下</h2><h3 id="如何让某个插件-在其他代码之前执行"><a href="#如何让某个插件-在其他代码之前执行" class="headerlink" title="如何让某个插件 在其他代码之前执行"></a>如何让某个插件 在其他代码之前执行</h3><p>如下，从上到小，先后执行 babel-polyfill –&gt;  react-hot-loader/patch –&gt; src/index，这是将react-hot-loader/patch先于index执行的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">entry: [</span><br><span class="line">  &apos;babel-polyfill&apos;,</span><br><span class="line">  &apos;react-hot-loader/patch&apos;,</span><br><span class="line">  path.resolve(__dirname, &apos;src/index&apos;)</span><br><span class="line">],</span><br></pre></td></tr></table></figure></p><h2 id="webpack-黑知识"><a href="#webpack-黑知识" class="headerlink" title="webpack 黑知识"></a>webpack 黑知识</h2><h3 id="合并两个webpack的js配置"><a href="#合并两个webpack的js配置" class="headerlink" title="合并两个webpack的js配置"></a>合并两个webpack的js配置</h3><p>使用webpack-merge即可，配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//webpack.common</span><br><span class="line">module.exports = &#123;&#125;  //module.exports是node的语法，是commonjs标准</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//webpack.dev.js</span><br><span class="line">const merge = require(&apos;webpack-merge&apos;);</span><br><span class="line">const common = require(&apos;./webpack.common&apos;);</span><br><span class="line">let devConfig = &#123;&#125;</span><br><span class="line">module.exports = merge(common, devConfig);</span><br></pre></td></tr></table></figure><h3 id="–watch-与-热更新"><a href="#–watch-与-热更新" class="headerlink" title="–watch 与 热更新"></a>–watch 与 热更新</h3><p>在命令中加入 –watch，可以达到效果：当文件改动时，会自动编译，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;watch&quot;: &quot;npx webpack --watch --config webpack.dev.js&quot;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>自动编译还是不够的，我们还想它能够编译后自动刷新页面，也就是热更新，最常见的是npm start：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;npm webpack-dev-server --config webpack.dev.js&quot;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>其中devServer.hot置为true，就可以达到热更新。</p><p>所以启动 webpack-dev-server，可以达到自动编译(–watch功能)和热更新功能。</p><h3 id="自动编译与热更新三大条件"><a href="#自动编译与热更新三大条件" class="headerlink" title="自动编译与热更新三大条件"></a>自动编译与热更新三大条件</h3><p>需要同时如下配置，才能进行自动编译与热更新：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const webpack = require(&apos;webpack&apos;);</span><br><span class="line"></span><br><span class="line">devServer: &#123;</span><br><span class="line">   hot: true, // 启用 webpack 的模块热替换特性, 这个需要配合： webpack.HotModuleReplacementPlugin插件</span><br><span class="line"> &#125;,</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  new webpack.NamedModulesPlugin(), // 更容易查看(patch)的依赖</span><br><span class="line">  new webpack.HotModuleReplacementPlugin() // 替换插件</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="webpack-dev-server黑知识"><a href="#webpack-dev-server黑知识" class="headerlink" title="webpack-dev-server黑知识"></a>webpack-dev-server黑知识</h3><p>如下，将看到以下几点黑知识：</p><h4 id="为什么是-0-0-0-0；"><a href="#为什么是-0-0-0-0；" class="headerlink" title="为什么是 0.0.0.0；"></a>为什么是 0.0.0.0；</h4><p>当然，服务器也可以设置为127.0.0.1，这个随你，注意的是设置为0.0.0.0时，可能0.0.0.0:58080有问题，在浏览器上改为127即可正常访问。</p><h4 id="npm-start后自动打开浏览器；"><a href="#npm-start后自动打开浏览器；" class="headerlink" title="npm start后自动打开浏览器；"></a>npm start后自动打开浏览器；</h4><h4 id="编译监听的防抖设置；"><a href="#编译监听的防抖设置；" class="headerlink" title="编译监听的防抖设置；"></a>编译监听的防抖设置；</h4><h4 id="忽略监控文件范围设置；"><a href="#忽略监控文件范围设置；" class="headerlink" title="忽略监控文件范围设置；"></a>忽略监控文件范围设置；</h4><h4 id="proxy的代理重写pathRewrite；"><a href="#proxy的代理重写pathRewrite；" class="headerlink" title="proxy的代理重写pathRewrite；"></a>proxy的代理重写pathRewrite；</h4><h4 id="publicPath的黑知识；"><a href="#publicPath的黑知识；" class="headerlink" title="publicPath的黑知识；"></a>publicPath的黑知识；</h4><figure class="image-box">                <img src="/image/webpack/publicPath.jpg" alt="" title="" class="">                <p></p>            </figure><p>publicPath 的优先级高于 contentBase。contentBase 用于配置提供额外静态文件内容的目录，之前提到的 publicPath 是配置构建好的结果以什么样的路径去访问，而 contentBase 是配置额外的静态文件内容的访问路径，即那些不经过 webpack 构建，但是需要在 webpack-dev-server 中提供访问的静态资源（如部分图片等）<br>你不懂contentBase publicPath为什么，没关系，先这样用着。<br>更多配置说明可参考掘金小册的第六章节。</p><p>webpack-dev-server的配置devServer 完整代码及解释如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    clientLogLevel: &apos;warning&apos;, // 可能的值有 none, error, warning 或者 info（默认值)</span><br><span class="line">    hot: true, // 启用 webpack 的模块热替换特性, 这个需要配合： webpack.HotModuleReplacementPlugin插件</span><br><span class="line">    contentBase: path.join(__dirname, &quot;dist&quot;), // 告诉服务器从哪里提供内容， 默认情况下，将使用当前工作目录作为提供内容的目录</span><br><span class="line">    compress: true, // 一切服务都启用gzip 压缩</span><br><span class="line">    host: &apos;0.0.0.0&apos;, // 指定使用一个 host。默认是 localhost。如果你希望服务器外部可访问 0.0.0.0</span><br><span class="line">    port: 58080, // 端口</span><br><span class="line">    open: true, // 是否打开浏览器</span><br><span class="line">    overlay: &#123; // 出现错误或者警告的时候，是否覆盖页面线上错误消息。</span><br><span class="line">      warnings: true,</span><br><span class="line">      errors: true</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    publicPath: &apos;/&apos;, // 此路径下的打包文件可在浏览器中访问。（注意若无特殊要求，一定设置为&apos;/&apos;,默认配置为 &apos;/                   //&apos;，大多时候我们不会去改，使用默认配置。）</span><br><span class="line"></span><br><span class="line">    proxy: &#123; // 设置代理</span><br><span class="line">      &quot;/api&quot;: &#123; // 访问api开头的请求，会跳转到  下面的target配置</span><br><span class="line">        target: &quot;http://192.168.0.102:8080&quot;,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          &quot;^/api&quot;: &quot;/mockjsdata/5/api&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        //以上配置的意思就是 /api/getuser     =&gt;  http://192.168.0.102:8080//mockjsdata/5/api/getuser</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    quiet: true, // necessary for FriendlyErrorsPlugin. 启用 quiet 后，除了初始启动信息之外的任何内容都不会被打印到控制台。这也意味着来自 webpack 的错误或警告在控制台不可见。</span><br><span class="line">    watchOptions: &#123; // 监视文件相关的控制选项</span><br><span class="line">      poll: true, // webpack 使用文件系统(file system)获取文件改动的通知。在某些情况下，不会正常工作。例如，当使用 Network File System (NFS) 时。Vagrant 也有很多问题。在这些情况下，请使用轮询. poll: true。当然 poll也可以设置成毫秒数，比如：  poll: 1000</span><br><span class="line">      ignored: /node_modules/, // 忽略监控的文件夹，正则</span><br><span class="line">      aggregateTimeout: 300 // 默认值，当第一个文件更改，会在重新构建前增加延迟，防抖的功能，如果你连续几次改的文件间隔小于300毫秒，会延迟编译</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="服务器默认读取index-html"><a href="#服务器默认读取index-html" class="headerlink" title="服务器默认读取index.html"></a>服务器默认读取index.html</h3><p>入口HTML若不是index.html则需补全：<br><figure class="image-box">                <img src="/image/webpack/index.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="resolve之默认扩展文件名"><a href="#resolve之默认扩展文件名" class="headerlink" title="resolve之默认扩展文件名"></a>resolve之默认扩展文件名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">    alias: &#123; // 配置别名</span><br><span class="line">      &apos;@&apos;: path.resolve(__dirname, &apos;src/&apos;)</span><br><span class="line">    &#125;,</span><br><span class="line">    extensions: [&quot;.js&quot;, &quot;.vue&quot;, &quot;.json&quot;] // 默认值: [&quot;.js&quot;,&quot;.json&quot;]  模块名字可以省略的后缀名</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h3 id="name-id-hash-chunkhash"><a href="#name-id-hash-chunkhash" class="headerlink" title="[name][id][hash][chunkhash]"></a>[name][id][hash][chunkhash]</h3><h4 id="name"><a href="#name" class="headerlink" title="[name]"></a>[name]</h4><p>所有的name，默认为entry中定义的，如果entry的值为字符串，则默认为main。<br>如：<br>下面代码是entry为字符串时，[name] 为默认的main<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">entry: &apos;./src/index.js&apos;,</span><br><span class="line"></span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">              commons: &#123;</span><br><span class="line">                 chunks: &apos;initial&apos;,</span><br><span class="line">                 test: path.resolve(__dirname,&apos;node_modules&apos;),</span><br><span class="line">                 enforce: true,</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"> output: &#123;</span><br><span class="line">    filename: &apos;[name].[hash].js&apos;,//main.24673fe716edfcec07a9.js</span><br><span class="line">    chunkFilename: &apos;[name].chunk.js&apos;, //commons~main.chunk.js 这里多了一个commons，是因为splitChunks的commons配置的，默认加commons</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line"> new HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: &apos;AICODER 全栈线下实习&apos;, // 默认值：Webpack App</span><br><span class="line">      filename: &apos;indexMyApp.html&apos;, // 默认值： &apos;index.html&apos;</span><br><span class="line">      template: path.resolve(__dirname, &apos;src/tempHtml.html&apos;),</span><br><span class="line">      minify: &#123;</span><br><span class="line">        collapseWhitespace: true,</span><br><span class="line">        removeComments: true, // 是否移除注释</span><br><span class="line">        removeAttributeQuotes: true // 移除属性的引号</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">  new MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: &apos;[name][hash].css&apos;, // main24673fe716edfcec07a9.css</span><br><span class="line">      chunkFilename: &apos;[id][hash].css&apos;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p><p>下面代码是entry为对象时，[name] 为entry的key值，下面的例子，[name]就是appIndex：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">  appIndex:&apos;./src/index.js&apos;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">              commons: &#123;</span><br><span class="line">                 chunks: &apos;initial&apos;,</span><br><span class="line">                 test: path.resolve(__dirname,&apos;node_modules&apos;),</span><br><span class="line">                 enforce: true,</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"> output: &#123;</span><br><span class="line">    filename: &apos;[name].[hash].js&apos;,//appIndex.90feeea169ea4a86288d.js</span><br><span class="line">    chunkFilename: &apos;[name].chunk.js&apos;, //commons~appIndex.chunk.js</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line"> new HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: &apos;AICODER 全栈线下实习&apos;, // 默认值：Webpack App</span><br><span class="line">      filename: &apos;indexMyApp.html&apos;, // 默认值： &apos;index.html&apos;</span><br><span class="line">      template: path.resolve(__dirname, &apos;src/tempHtml.html&apos;),</span><br><span class="line">      minify: &#123;</span><br><span class="line">        collapseWhitespace: true,</span><br><span class="line">        removeComments: true, // 是否移除注释</span><br><span class="line">        removeAttributeQuotes: true // 移除属性的引号</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">  new MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: &apos;[name][hash].css&apos;, // appIndex90feeea169ea4a86288d.css</span><br><span class="line">      chunkFilename: &apos;[id][hash].css&apos;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p><p>可在插件中自定义对应模块的[name]，例如定义splitChunks模块下name: ‘custom_chunkName’，他会覆盖entry中定义的name，由此splitChunks插件生成的文件将[name]值为custom_chunkName:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">entry: &#123;</span><br><span class="line">  appIndex:&apos;./src/index.js&apos;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">              commons: &#123;</span><br><span class="line">                 chunks: &apos;initial&apos;,</span><br><span class="line">                 test: path.resolve(__dirname,&apos;node_modules&apos;),</span><br><span class="line">                 enforce: true,</span><br><span class="line">                 name: &apos;custom_chunkName&apos;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"> output: &#123;</span><br><span class="line">    filename: &apos;[name].[hash].js&apos;,//appIndex.c81ab09b0bd828f71845.js</span><br><span class="line">    chunkFilename: &apos;[name].chunk.js&apos;, //customChunkNameQQ.chunk.js</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">  new MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: &apos;[name][hash].css&apos;, // appIndexc81ab09b0bd828f71845.css</span><br><span class="line">      chunkFilename: &apos;[id][hash].css&apos;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">//其他跟上面代码一样，只列与上不同的代码：</span><br></pre></td></tr></table></figure><p>当然你也可以直接通过filename定义splitChunks模块下输出文件的名字，这个优先级最高：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">  appIndex:&apos;./src/index.js&apos;</span><br><span class="line">&#125;,</span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">              commons: &#123;</span><br><span class="line">                 chunks: &apos;initial&apos;,</span><br><span class="line">                 test: path.resolve(__dirname,&apos;node_modules&apos;),</span><br><span class="line">                 enforce: true,</span><br><span class="line">                 name: &apos;customChunkNameQQ&apos;,</span><br><span class="line">                 filename: &apos;chunckNiceName.js&apos;,</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"> output: &#123;</span><br><span class="line">    filename: &apos;[name].[hash].js&apos;,//appIndex.c81ab09b0bd828f71845.js</span><br><span class="line">    chunkFilename: &apos;[name].chunk.js&apos;, //chunckNiceName.js</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">  new MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: &apos;[name][hash].css&apos;, // appIndexc81ab09b0bd828f71845.css</span><br><span class="line">      chunkFilename: &apos;[id][hash].css&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">//其他跟上面代码一样，只列与上不同的代码：</span><br></pre></td></tr></table></figure><p>关于[name]小结：<br>如果entry为字符串，name值默认为main；<br>如果entry以对象形式，name值为对象的key值；<br>各个插件(如css、js处理插件)可自定义本插件生成的js的文件名，或自定name值覆盖entry中定义的name值。</p><h4 id="id"><a href="#id" class="headerlink" title="[id]"></a>[id]</h4><p>这个最简单，[id]其实就是数字1,2,3,4…..；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    filename: &apos;[name].[hash].js&apos;,</span><br><span class="line">    chunkFilename: &apos;[id].chunk.js&apos;,</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><h4 id="hash"><a href="#hash" class="headerlink" title="[hash]"></a>[hash]</h4><p>这就是一个hash码，值得注意的是，每次build的hash值都是相同的，也就是打包完成后，js\css文件名的hash值都是相同的。<br>hash一个典型特征是，只有有一个文件改变，那么重新打包后hash值将变化，所以使用hash输出文件名的都将变化，<br>所以业务js，必须使用hash，而不能使用chunkhash。</p><h4 id="chunkhash-及-chunkhash-与-hash-的异同"><a href="#chunkhash-及-chunkhash-与-hash-的异同" class="headerlink" title="[chunkhash]及 [chunkhash]与[hash]的异同"></a>[chunkhash]及 [chunkhash]与[hash]的异同</h4><p>依赖库的源码，我们一般单独打包成一个库js，这个js必须使用chunkhash，<br>chunkhash的原则是只要chunkhash对应的模块文件不变，就算其他文件有变化了，重新打包了，改变的是hash值，chunkhash值保持不变。<br><strong>需特别注意的是，在一般情况下，修改文件和增加文件，webpack编译生成chunkhash的策略是不同的，上面所说的只适合修改文件的情况，如果增加文件或删除文件，就算库文件不变，还是会产生不同的chunkhash，原因在与webpack会根据总体文件，为每个文件设置一个index进行编译，增加或删除文件都会改变整体的index，从而导致chunkhash改变，为了防止这一情况，可配置webpack.HashedModuleIdsPlugin</strong><br>关于chunkhash的规则，更多请看章节3.12:《构建与性能优化 之 webpack.HashedModuleIdsPlugin》<br>对于 chunkhash与HashedModuleIdsPlugin 看参看 <a href="https://www.cnblogs.com/zhishaofei/p/8590627.html" target="_blank" rel="noopener">这里</a><br><strong>所以为了利用http缓存，对于依赖源码库js，必须使用chunkhash，业务js必须使用hash，否则将失去库与业务代码分离的意义</strong></p><h3 id="关于chunkFilename"><a href="#关于chunkFilename" class="headerlink" title="关于chunkFilename"></a>关于chunkFilename</h3><p>chunkFilename是用来配置无入口的chunk输出的名字的。<br>1.代码如下，进行打包；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    appIndex:&apos;./src/index.js&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mode: &apos;production&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &apos;[name].[hash].js&apos;,</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        commons: &#123;</span><br><span class="line">           chunks: &apos;initial&apos;,</span><br><span class="line">           test: path.resolve(__dirname,&apos;node_modules&apos;),</span><br><span class="line">           enforce: true,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>打包后生成：<br><figure class="image-box">                <img src="/image/webpack/chunkfilename1.png" alt="" title="" class="">                <p></p>            </figure><br>因为splitChunks.cacheGroups.commons没有定义name，所以输出文件，默认加 commons~….js;</p><p>2.与1其他配置不变，加上name，再打包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">    cacheGroups: &#123;</span><br><span class="line">      commons: &#123;</span><br><span class="line">        ...</span><br><span class="line">         name: &apos;lodashAndAxios&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>打包后生成，我们发现，这个分离出来的代码块，用的是output.filename的配置：<br><figure class="image-box">                <img src="/image/webpack/chunkfilename2.png" alt="" title="" class="">                <p></p>            </figure></p><p>3.与2其他配置不变，加上chunkfilename，再打包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    ...</span><br><span class="line">    chunkFilename: &apos;[name]._chunk_[chunkhash].js&apos;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>打包后生成，我们发现，这个分离出来的代码块，用的是output.chunkFilename的配置：<br><figure class="image-box">                <img src="/image/webpack/chunkfilename3.png" alt="" title="" class="">                <p></p>            </figure></p><p>这单独分离的代码，在entry中没有入口，只通过splitChunks.cacheGroups.test进行匹配，所以chunkFilename 是用来配置没有入口的名称的，<br>如果不配置chunkFilename，将会根据filename输出。不配置splitChunks.cacheGroups.name，会给输出文件名默认加commons~</p><h3 id="chunk的名称"><a href="#chunk的名称" class="headerlink" title="chunk的名称"></a>chunk的名称</h3><p>chunk的名称和entry的配置有关；</p><ul><li>如果entry是一个string或array，只会生成一个chunk，这是的chunk的名称就是main；</li><li>如果entry是一个Object，就可能会出现多个chunk,这时chunk的名称是Object键值对中健的名称。</li></ul><h3 id="从代码分离看chunk与minChunks"><a href="#从代码分离看chunk与minChunks" class="headerlink" title="从代码分离看chunk与minChunks"></a>从代码分离看chunk与minChunks</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">  a: &apos;./path/to/my/entry/file.js&apos;,</span><br><span class="line">  b: &apos;./path/to/my/entry/app.js&apos;,</span><br><span class="line">&#125;</span><br><span class="line">optimization: &#123;</span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">    cacheGroups: &#123;</span><br><span class="line">      commons: &#123;</span><br><span class="line">        &lt;!-- 如果不指定chunks，将会从现有的所有chunk中提取公共代码 --&gt;</span><br><span class="line">         chunks: [&apos;a&apos;,&apos;b&apos;],//a、b是entry中的两个chunk，从a，b中抽取公共的代码，最终会形成一个名字为appCommon的js，和a.js和b.js</span><br><span class="line">         name: &apos;appCommon&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个参数是minChunks，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">minChunks = 2;</span><br><span class="line">chunks = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;]</span><br></pre></td></tr></table></figure></p><p>只要在abcde模块中任意两个模块出现了公共代码的，都被提取。<br>minChunks主要应对，很可能abcde没有一个公共代码，在所有模块中都有的情况。</p><h3 id="dev模式禁chunkhash"><a href="#dev模式禁chunkhash" class="headerlink" title="dev模式禁chunkhash"></a>dev模式禁chunkhash</h3><p>在dev模式下，只能用hash，不能使用chunkhash，否则报错。</p><h3 id="模块解析规则与resolve"><a href="#模块解析规则与resolve" class="headerlink" title="模块解析规则与resolve"></a>模块解析规则与resolve</h3><h4 id="解析相对路径"><a href="#解析相对路径" class="headerlink" title="解析相对路径"></a>解析相对路径</h4><ul><li>查找相对当前模块的路径下是否有对应文件或文件夹</li><li>是文件则直接加载</li><li>是文件夹则继续查找文件夹下的 package.json 文件</li><li>有 package.json 文件则按照文件中 main 字段的文件名来查找文件</li><li>无 package.json 或者无 main 字段则查找 index.js 文件<h4 id="解析模块名"><a href="#解析模块名" class="headerlink" title="解析模块名"></a>解析模块名</h4>查找当前文件目录下，父级目录及以上目录下的 node_modules 文件夹，看是否有对应名称的模块<h4 id="解析绝对路径（不建议使用）"><a href="#解析绝对路径（不建议使用）" class="headerlink" title="解析绝对路径（不建议使用）"></a>解析绝对路径（不建议使用）</h4>直接查找对应路径的文件</li></ul><p>在 webpack 配置中，和模块路径解析相关的配置都在 resolve 字段下。</p><h4 id="resolve-常用配置："><a href="#resolve-常用配置：" class="headerlink" title="resolve 常用配置："></a>resolve 常用配置：</h4><p>module.exports = {<br>   resolve: {<br>      alias: { // 配置别名<br>         utils: path.resolve(<strong>dirname, ‘src/utils’), // 模糊匹配，意味着只要模块路径中携带utils 就可以被替换掉<br>         component$: path.resolve(</strong>dirname, ‘src/component’) // 只会匹配 import ‘component’， 这是精确匹配方法。<br>      },<br>      modules: [<br>        path.resolve(__dirname, ‘node_modules’), // 指定当前目录下的 node_modules 优先查找<br>        ‘node_modules’, // 如果有一些类库是放在一些奇怪的地方的，你可以添加自定义的路径或者目录<br>      ],<br>      mainFiles: [‘index’], //当目录下没有 package.json 文件时，我们说会默认使用目录下的 index.js 这个文件,就是这个字段配置的。// 你可以添加其他默认使用的文件名<br>      extensions: [“.js”, “.vue”, “.json”] // 默认值: [“.js”,”.json”]  模块名字可以省略的后缀名<br>  },<br>}</p><h3 id="loader的规则条件配置"><a href="#loader的规则条件配置" class="headerlink" title="loader的规则条件配置"></a>loader的规则条件配置</h3><p>大多数情况下，配置 loader 的匹配条件时，只要使用 test 字段就好了，很多时候都只需要匹配文件后缀名来决定使用什么 loader，但也不排除在某些特殊场景下，我们需要配置比较复杂的匹配条件。webpack 的规则提供了多种配置形式：</p><ul><li>{ test: … } 匹配特定条件</li><li>{ include: … } 匹配特定路径</li><li>{ exclude: … } 排除特定路径</li><li>{ and: […] }必须匹配数组中所有条件</li><li>{ or: […] } 匹配数组中任意一个条件</li><li><p>{ not: […] } 排除匹配数组中所有条件<br>上述的所谓条件的值可以是：</p></li><li><p>字符串：必须以提供的字符串开始，所以是字符串的话，这里我们需要提供绝对路径</p></li><li>正则表达式：调用正则的 test 方法来判断匹配</li><li>函数：(path) =&gt; boolean，返回 true 表示匹配</li><li>数组：至少包含一个条件的数组</li><li>对象：匹配所有属性值的条件</li></ul><h3 id="关于output"><a href="#关于output" class="headerlink" title="关于output"></a>关于output</h3><p>单个入口是配置方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const config = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: &apos;./path/to/my/entry/file.js&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const config = &#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &apos;bundle.js&apos;,</span><br><span class="line">    path: &apos;/home/proj/public/assets&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>多个入口时配置方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: &apos;./src/app.js&apos;,</span><br><span class="line">    search: &apos;./src/search.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &apos;[name].js&apos;,//多个时，用占位符[name]的方式定义</span><br><span class="line">    path: __dirname + &apos;/dist&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="css-js是怎么嵌入html"><a href="#css-js是怎么嵌入html" class="headerlink" title="css\js是怎么嵌入html"></a>css\js是怎么嵌入html</h3><p>无论output出来一个或多个js，html-webpack-plugin都会将js、css嵌入到html内：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">new HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: &apos;AICODER 全栈线下实习&apos;, // 默认值：Webpack App</span><br><span class="line">      filename: &apos;indexMyApp.html&apos;, // 默认值： &apos;index.html&apos;</span><br><span class="line">      template: path.resolve(__dirname, &apos;src/tempHtml.html&apos;),</span><br><span class="line">      minify: &#123;</span><br><span class="line">        collapseWhitespace: true,</span><br><span class="line">        removeComments: true, // 是否移除注释</span><br><span class="line">        removeAttributeQuotes: true // 移除属性的引号</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br></pre></td></tr></table></figure></p><h3 id="模板index-html的ejs写法与html-webpack-plugin配合"><a href="#模板index-html的ejs写法与html-webpack-plugin配合" class="headerlink" title="模板index.html的ejs写法与html-webpack-plugin配合"></a>模板index.html的ejs写法与html-webpack-plugin配合</h3><p>模板文件index.html可以写ejs，ejs语法允许写js，然后每行用&lt;%= %&gt;包起来即可:<br><figure class="image-box">                <img src="/image/webpack/tpl1.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/tpl2.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/tpl3.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/tpl4.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/tpl5.png" alt="" title="" class="">                <p></p>            </figure></p><p>注意：1.当有需求把一个js放在html 的header上，一个在body上时，可以定义模板script引用，此时必须设置inject为fasle，表示不适用插件默认嵌入。<br>2.上面ejs模板上一定要写成htmlWebpackPlugin，否则undefined，目前不知道为什么写成HtmlWebpackPlugin就可以关联到插件html-webpack-plugin</p><h3 id="多页面html的配置打包"><a href="#多页面html的配置打包" class="headerlink" title="多页面html的配置打包"></a>多页面html的配置打包</h3><p>要生成多个html，就需要在webpack.config.js中多配置几次new  html-webpack-plugin<br><figure class="image-box">                <img src="/image/webpack/mutilPage1.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/mutilPage2.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/mutilPage3.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/mutilPage4.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/mutilPage5.png" alt="" title="" class="">                <p></p>            </figure></p><h3 id="autoprefixer-配置-postcss-loader"><a href="#autoprefixer-配置-postcss-loader" class="headerlink" title="autoprefixer 配置 (postcss-loader)"></a>autoprefixer 配置 (postcss-loader)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">要生成多个html，就需要在webpack.config.js中多配置几次new  html-webpack-plugin</span><br><span class="line">&#123;</span><br><span class="line">  loader: &apos;postcss-loader&apos;,</span><br><span class="line">  options: &#123;</span><br><span class="line">    ident: &apos;postcss&apos;,</span><br><span class="line">    sourceMap: true,</span><br><span class="line">    //根据中国使用浏览器情况统计，兼容使用率大于百分之0.15的所有浏览器</span><br><span class="line">    plugins: (loader) =&gt; [require(&apos;autoprefixer&apos;)(&#123;browsers: [&apos;&gt; 0.15% in CN&apos;]&#125;)]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">browsers: [&apos;&gt; 5% in US&apos;] //根据美国使用浏览器情况统计，兼容使用率大于百分之5的所有浏览器</span><br><span class="line">browsers: [&apos;last 5 versions&apos;] //兼容所有浏览器最新的五个版本</span><br></pre></td></tr></table></figure><p><a href="https://github.com/browserslist/browserslist#best-practices" target="_blank" rel="noopener">点击查看更多</a></p><h3 id="html内img图片引用路径"><a href="#html内img图片引用路径" class="headerlink" title="html内img图片引用路径"></a>html内img图片引用路径</h3><p>在html或ejs模板文件，此时如果写绝对路径引用图片是没问题的，如果要使用相对路径，就必须使用require，<br>这是index.html文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> &lt;div class=img&gt;</span><br><span class="line">     &lt;img src=&quot;$&#123; require(&apos;./assets/img/WechatIMG92.jpeg&apos;) &#125;&quot;  alt=&quot;标志&quot; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>这是ejs模板文件：<br><figure class="image-box">                <img src="/image/webpack/htmltpl.png" alt="" title="" class="">                <p></p>            </figure><br>不过在项目中，所以类型的，对图片的引用，使用绝对路径都没问题，只有使用相对路径才会有以上问题。<br>不过在css中，引用图片，使用相对路径和绝对路径都没问题。</p><h3 id="给图片指定生成目录"><a href="#给图片指定生成目录" class="headerlink" title="给图片指定生成目录"></a>给图片指定生成目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: /\.(png|svg|jpg|gif|jpeg)$/,</span><br><span class="line">        include: [path.resolve(__dirname, &apos;src/&apos;)],</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &apos;url-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: 10000,</span><br><span class="line">              //name既可以定义文件名字，也可以定义css生成路径，占位符[ext]是扩展externals的简写指图片扩展名</span><br><span class="line">              name: &apos;image/[name]_image.[ext]&apos;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="带ejs的入口index-html模板文件示例"><a href="#带ejs的入口index-html模板文件示例" class="headerlink" title="带ejs的入口index.html模板文件示例"></a>带ejs的入口index.html模板文件示例</h3><p>对ejs的一点解释</p><ol><li>&lt;%  %&gt; 不输出显示到浏览器上的写法，专门用来运算js；</li><li>&lt;%=  %&gt; 加了一个=后，输出显示到浏览器上的写法；<br>完整示例看 看<a href="https://github.com/YeWills/webpack-code/tree/ejsHtml" target="_blank" rel="noopener">github 仓库中的 ejsHtml 分支 demo </a>，对应的tag发布版本为ejsHtmlV1.0</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">  &lt;script</span><br><span class="line">  src=&quot;https://code.jquery.com/jquery-3.1.0.js&quot;</span><br><span class="line">  integrity=&quot;sha256-slogkvB1K3VOkzAI8QITxV3VzpOnkeNVsKvtkYLMjfk=&quot;</span><br><span class="line">  crossorigin=&quot;anonymous&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"> &lt;% for (var key of htmlWebpackPlugin.files.css) &#123; %&gt;</span><br><span class="line">  &lt;link href=&quot;&lt;%= key %&gt;&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line"> &lt;% &#125; %&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;dmo&quot;&gt;我是模板文件自带的内容1&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;% for (var key in htmlWebpackPlugin.files) &#123; %&gt;</span><br><span class="line">        &lt;%= key %&gt; : &lt;%= JSON.stringify(htmlWebpackPlugin.files.css) %&gt;</span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=img&gt;</span><br><span class="line">      &lt;img src=&quot;$&#123; require(&apos;./assets/img/WechatIMG92.jpeg&apos;) &#125;&quot;  alt=&quot;标志&quot; /&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">  &lt;script</span><br><span class="line">  src=&quot;&lt;%= htmlWebpackPlugin.files.chunks.appIndex.entry %&gt;&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script</span><br><span class="line">  src=&quot;&lt;%= htmlWebpackPlugin.files.chunks.lodashAndAxios.entry %&gt;&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="两个横杠命令"><a href="#两个横杠命令" class="headerlink" title="两个横杠命令"></a>两个横杠命令</h3><p>webpack –devtool source-map;<br>发现凡是带两个–的命令，都是配置 webpack 的配置项。</p><h2 id="构建与性能优化"><a href="#构建与性能优化" class="headerlink" title="构建与性能优化"></a>构建与性能优化</h2><p>构建与性能优化很多思路受益于kangshen，膜拜下大神。</p><h3 id="升级到最新的webpack稳定版本"><a href="#升级到最新的webpack稳定版本" class="headerlink" title="升级到最新的webpack稳定版本"></a>升级到最新的webpack稳定版本</h3><p>这无疑是性能显著提升的</p><h3 id="babel-loader-的优化"><a href="#babel-loader-的优化" class="headerlink" title="babel-loader 的优化"></a>babel-loader 的优化</h3><p>把 loader 应用的文件范围缩小,也就是说，配置loader的include来限定查询范围<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rules: [ </span><br><span class="line">  &#123;</span><br><span class="line">    test: /\.jsx?/,</span><br><span class="line">    include: [ </span><br><span class="line">      path.resolve(__dirname, &apos;src&apos;), </span><br><span class="line">      // 限定只在 src 目录下的 js/jsx 文件需要经 babel-loader 处理</span><br><span class="line">      // 通常我们需要 loader 处理的文件都是存放在 src 目录</span><br><span class="line">    ],</span><br><span class="line">    use: &apos;babel-loader&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">  // ...</span><br><span class="line">],</span><br></pre></td></tr></table></figure></p><h4 id="设置exclude"><a href="#设置exclude" class="headerlink" title="设置exclude"></a>设置exclude</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  modules: [</span><br><span class="line">    path.resolve(__dirname, &apos;node_modules&apos;), // 使用绝对路径指定 node_modules，不做过多查询</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  // 删除不必要的后缀自动补全，少了文件后缀的自动匹配，即减少了文件路径查询的工作</span><br><span class="line">  // 其他文件可以在编码时指定后缀，如 import(&apos;./index.scss&apos;)</span><br><span class="line">  extensions: [&quot;.js&quot;], </span><br><span class="line"></span><br><span class="line">  // 避免新增默认文件，编码时使用详细的文件路径，代码会更容易解读，也有益于提高构建速度</span><br><span class="line">  mainFiles: [&apos;index&apos;],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="启用缓存"><a href="#启用缓存" class="headerlink" title="启用缓存"></a>启用缓存</h4><p>总代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: /\.js$/,</span><br><span class="line">    exclude: /(node_modules)/, // 加快编译速度，不包含node_modules文件夹内容</span><br><span class="line">    use: &#123;</span><br><span class="line">      loader: &apos;babel-loader&apos;,</span><br><span class="line">      options: &#123;</span><br><span class="line">        cacheDirectory: true // 启用缓存，提高编译速度，生成和开发都要如此设置</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="生产下库与业务js分离"><a href="#生产下库与业务js分离" class="headerlink" title="生产下库与业务js分离"></a>生产下库与业务js分离</h3><p>对于单页面应用 生产下库与业务js分离，可以利用浏览器http请求缓存机制，提高下一次访问速度。<br>对于多页面应用 生产下库与业务js分离，可以利用浏览器http请求缓存机制，提高访问下一页的速度。</p><p>更多详细库与业务js分离配置方法 请看 1.13章节 《webpack常用知识–分离 库与业务代码》</p><p>更多信息，看<a href="https://github.com/YeWills/webpack-code/tree/master" target="_blank" rel="noopener">demo示例</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        commons: &#123;</span><br><span class="line">           chunks: &apos;initial&apos;,</span><br><span class="line">           test: &apos;lodashAndAxios&apos;,</span><br><span class="line">           enforce: true,</span><br><span class="line">           name: &apos;lodashAndAxios&apos;,//对应覆盖entry.chunkFilename中的name占位符[name]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>optimization.splitChunks.cacheGroups.chunks也可以是函数，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        styles: &#123;</span><br><span class="line">           chunks: &apos;all&apos;,</span><br><span class="line">           test: /\.(sc|c|sa)ss$/,</span><br><span class="line">           enforce: true,</span><br><span class="line">           name: &apos;styles&apos;,//对应覆盖entry.chunkFilename中的name占位符[name]</span><br><span class="line">        &#125;,</span><br><span class="line">        commons: &#123;</span><br><span class="line">           chunks: (chunk) =&gt; &#123;</span><br><span class="line">             return chunk.name !== &apos;styles&apos;;//避开上面定义的styles chunk</span><br><span class="line">           &#125;,</span><br><span class="line">           test: &apos;lodashAndAxios&apos;,</span><br><span class="line">           enforce: true,</span><br><span class="line">           name: &apos;lodashAndAxios&apos;,//对应覆盖entry.chunkFilename中的name占位符[name]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="使用花括号-进行import"><a href="#使用花括号-进行import" class="headerlink" title="使用花括号{}进行import"></a>使用花括号{}进行import</h3><p>例如 使用lodash，推荐这种写法import { filter } from ‘lodash’;<br>用什么就花括号，取什么。</p><h3 id="依赖包和业务js分离"><a href="#依赖包和业务js分离" class="headerlink" title="依赖包和业务js分离"></a>依赖包和业务js分离</h3><p>一般依赖包如loadsh，jq这些很少改变，而一般只改变业务js，分开打包后，依赖包js文件名，每次发布版本都是一样的，<br>浏览器的http请求缓存机制，浏览器不会重复请求，直接拿浏览器缓存的依赖包js即可，可提高性能，减少流量。每次发布版本，<br>只需要请求业务js。</p><h3 id="设置外部依赖"><a href="#设置外部依赖" class="headerlink" title="设置外部依赖"></a>设置外部依赖</h3><p>将笨重的很多页面都用到的js通过externals设置成外部依赖。</p><h3 id="利用浏览器http缓解机制"><a href="#利用浏览器http缓解机制" class="headerlink" title="利用浏览器http缓解机制"></a>利用浏览器http缓解机制</h3><p>利用浏览器http缓解机制，库与js代码分离，可以提高速度，减少流量。(这个应该属于 项目性能优化范畴)</p><h3 id="autodll-webpack-plugin"><a href="#autodll-webpack-plugin" class="headerlink" title="autodll-webpack-plugin"></a>autodll-webpack-plugin</h3><p>该插件能够快速打包，能把第三方依赖的文件能提前进行预编译打包到一个文件里面去。提高了构建速度。因为很多第三方插件我们并不需要改动它，所以我们想这些第三方库在我们每次编译的时候不要再次构建它就好,可以非常明显提高rebuild速度<br>该插件有两个作用：<br>1、可以明显提高rebuild的速度；<br>2、可以调试库源码；</p><p>更多信息，看<a href="https://github.com/YeWills/webpack-code/tree/master" target="_blank" rel="noopener">demo示例</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const AutoDllPlugin = require(&apos;autodll-webpack-plugin&apos;);</span><br><span class="line"> new AutoDllPlugin(&#123;</span><br><span class="line">      filename: &apos;[name]_chunk.js&apos;,</span><br><span class="line">      // 如果需要调试库源码，将inherit设置为true，是调试源码的尖刀利器，不过会影响rebuild速度</span><br><span class="line">      inherit: false,//当为false时，速度更快；当为true时，可以打开webpack没有压缩过的源码sourcemap调试</span><br><span class="line">      inject: true,</span><br><span class="line">      debug: true,</span><br><span class="line">      entry: &#123;</span><br><span class="line">        appVendor: [</span><br><span class="line">          &apos;axios&apos;,</span><br><span class="line">          &apos;lodash&apos;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br></pre></td></tr></table></figure><h3 id="happypack"><a href="#happypack" class="headerlink" title="happypack"></a>happypack</h3><p>webpack 只能一个loader处理完后处理下一个loader，这样，速度就慢，为了同时进行多线程loader，同时处理多个loader，可以使用happypack；<br>配置happypack可以明显提高构建速度。</p><ul><li>其他的都好配置，就postcss-loader 比较特殊，必须要另外新建 postcss.config.js 否则报错；</li><li>happypack 重写原来loader配置时，基本上就是复制，不改变，只有postcss可能稍微改动下</li></ul><p>更多信息，看<a href="https://github.com/YeWills/webpack-code/tree/master" target="_blank" rel="noopener">demo示例</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const HappyPack = require(&apos;happypack&apos;);</span><br><span class="line"> module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(sc|c|sa)ss$/,</span><br><span class="line">        loader: &apos;happypack/loader?id=handerStyle&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"> new HappyPack(&#123;</span><br><span class="line">      id:&apos;handerStyle&apos;,</span><br><span class="line">      loaders:[</span><br><span class="line">        &apos;style-loader&apos;, </span><br><span class="line">        &#123;</span><br><span class="line">          loader: &apos;css-loader&apos;,</span><br><span class="line">          options: &#123;</span><br><span class="line">            sourceMap: true</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &apos;postcss-loader&apos;, </span><br><span class="line">        &#123;</span><br><span class="line">          loader: &apos;sass-loader&apos;,</span><br><span class="line">          options: &#123;</span><br><span class="line">            sourceMap: true</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//postcss.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  ident: &apos;postcss&apos;,</span><br><span class="line">  sourceMap: true,</span><br><span class="line">  plugins: &#123;</span><br><span class="line">    &apos;autoprefixer&apos;: &#123;</span><br><span class="line">      browsers: [&apos;&gt; 0.15% in CN&apos;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="webpack-parallel-uglify-plugin"><a href="#webpack-parallel-uglify-plugin" class="headerlink" title="webpack-parallel-uglify-plugin"></a>webpack-parallel-uglify-plugin</h3><p>生产环境配置。<br>happypack是多线程操作loader进行多线程转译文件；与此相似，webpack-parallel-uglify-plugin是多线程进行压缩js，提高生产环境下的打包速度。<br>更多信息，看<a href="https://github.com/YeWills/webpack-code/tree/master" target="_blank" rel="noopener">demo示例</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    // 使用 ParallelUglifyPlugin 并行压缩输出JS代码</span><br><span class="line">    new ParallelUglifyPlugin(&#123;</span><br><span class="line">      // 传递给 UglifyJS的参数如下：</span><br><span class="line">      uglifyJS: &#123;</span><br><span class="line">        output: &#123;</span><br><span class="line">          /*</span><br><span class="line">           是否输出可读性较强的代码，即会保留空格和制表符，默认为输出，为了达到更好的压缩效果，</span><br><span class="line">           可以设置为false</span><br><span class="line">          */</span><br><span class="line">          beautify: false,</span><br><span class="line">          /*</span><br><span class="line">           是否保留代码中的注释，默认为保留，为了达到更好的压缩效果，可以设置为false</span><br><span class="line">          */</span><br><span class="line">          comments: false</span><br><span class="line">        &#125;,</span><br><span class="line">        compress: &#123;</span><br><span class="line">          /*</span><br><span class="line">           是否在UglifyJS删除没有用到的代码时输出警告信息，默认为输出，可以设置为false关闭这些作用</span><br><span class="line">           不大的警告</span><br><span class="line">          */</span><br><span class="line">          warnings: false,</span><br><span class="line"></span><br><span class="line">          /*</span><br><span class="line">           是否删除代码中所有的console语句，默认为不删除，开启后，会删除所有的console语句</span><br><span class="line">          */</span><br><span class="line">          drop_console: true,</span><br><span class="line"></span><br><span class="line">          /*</span><br><span class="line">           是否内嵌虽然已经定义了，但是只用到一次的变量，比如将 var x = 1; y = x, 转换成 y = 5, 默认为不</span><br><span class="line">           转换，为了达到更好的压缩效果，可以设置为false</span><br><span class="line">          */</span><br><span class="line">          collapse_vars: true,</span><br><span class="line"></span><br><span class="line">          /*</span><br><span class="line">           是否提取出现了多次但是没有定义成变量去引用的静态值，比如将 x = &apos;xxx&apos;; y = &apos;xxx&apos;  转换成</span><br><span class="line">           var a = &apos;xxxx&apos;; x = a; y = a; 默认为不转换，为了达到更好的压缩效果，可以设置为false</span><br><span class="line">          */</span><br><span class="line">          reduce_vars: true</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="ContextReplacementPlugin"><a href="#ContextReplacementPlugin" class="headerlink" title="ContextReplacementPlugin"></a>ContextReplacementPlugin</h3><p>配置ContextReplacementPlugin，是优化配置，下面章节《其他常用插件》有讲</p><h3 id="webpack-HashedModuleIdsPlugin"><a href="#webpack-HashedModuleIdsPlugin" class="headerlink" title="webpack.HashedModuleIdsPlugin"></a>webpack.HashedModuleIdsPlugin</h3><p>打包中chunkhash的规则：<br>当没有删除或增加文件，如果对于chunk的代码没有变化，chunkhash值不会变，可以起到浏览器缓存的作用；<br>但当有删除或增加文件是，如果对应chunk的代码没有变化，打包是，chunkhash还是会变，这不是我们想要的结果，我们只希望对应chunk代码如果没变化，<br>无论其他代码文件删除或增加，chunkhash都不变。<br>（为什么会变，webpack自带打包策略是给每个文件配置了一个数字index，无论增加或删除一个文件，都会打乱整个 index，导致chunkhash变化，<br>HashedModuleIdsPlugin，改变策略为，根据文件路径配置，所以达到了稳定chunkhash）<br>为了达到以上效果，请配置HashedModuleIdsPlugin插件：<br>new webpack.HashedModuleIdsPlugin({<br>  hashDigestLength：20<br>})</p><p>该插件会根据模块的相对路径生成一个四位数的hash作为模块id, 建议用于生产环境。<br>用 HashedModuleIdsPlugin 可以轻松地实现 chunkhash 的稳定化，可以实现持久化缓存。<br>建议生产配置使用，如果使用到了chunkhash，则最好配置HashedModuleIdsPlugin。<br>更多请看章节2.7.4:《webpack 黑知识 之 [name][id][hash][chunkhash][name]》<br>或看官网<br>对于 chunkhash与HashedModuleIdsPlugin 看参看 <a href="https://www.cnblogs.com/zhishaofei/p/8590627.html" target="_blank" rel="noopener">这里</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  new webpack.HashedModuleIdsPlugin(&#123;</span><br><span class="line">    hashDigestLength: 20</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="webpack-NormalModuleReplacementPlugin"><a href="#webpack-NormalModuleReplacementPlugin" class="headerlink" title="webpack.NormalModuleReplacementPlugin"></a>webpack.NormalModuleReplacementPlugin</h3><p>webpack.NormalModuleReplacementPlugin(a,b)编译时，第一个参数通常是正则，第一个参数正则匹配到文件后，会将此文件替换为第二个参数，从而达到生产或开发时，编译不同文件的目的，比如生产和开发时编译不同的路由文件。<br>所以配置时，在webpack.config.plugins中，位于最前面，保证webpack执行编译时，首先启用此插件替换文件。<br>注意的是，此插件的第一个参数一般都设置为正则。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">  new webpack.NormalModuleReplacementPlugin(</span><br><span class="line">    /some\/path\/config\.development\.js/,</span><br><span class="line">    &apos;./config.production.js&apos;</span><br><span class="line">  ),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="webpack-optimize-OccurrenceOrderPlugin"><a href="#webpack-optimize-OccurrenceOrderPlugin" class="headerlink" title="webpack.optimize.OccurrenceOrderPlugin"></a>webpack.optimize.OccurrenceOrderPlugin</h3><p>OccurrenceOrderPlugin插件：根据出现次数为每一个模块或者chunk设置id,经常使用的模块则会获取到较短的id(和前缀树类似)，这可以使id可预测并有效减少文件大小，建议使用在生产环境中～<br><a href="https://www.cnblogs.com/xuepei/p/7992423.html" target="_blank" rel="noopener">参考</a><br>有些说是可以优化排序输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">  new webpack.optimize.OccurrenceOrderPlugin(),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="webpack-optimize-AggressiveMergingPlugin"><a href="#webpack-optimize-AggressiveMergingPlugin" class="headerlink" title="webpack.optimize.AggressiveMergingPlugin"></a>webpack.optimize.AggressiveMergingPlugin</h3><p>AggressiveMergingPlugin用于合并块。<br>AggressiveMergingPlugin用于解决如路由分配不合理，会打包出很多很小的文件，每个文件或许只有几k，却多了很多网络请求，得不偿失。<br>用法很简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">  new webpack.optimize.AggressiveMergingPlugin(),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="react-loadable-懒加载优化生产模式构建速度以及页面访问速度"><a href="#react-loadable-懒加载优化生产模式构建速度以及页面访问速度" class="headerlink" title="react-loadable 懒加载优化生产模式构建速度以及页面访问速度"></a>react-loadable 懒加载优化生产模式构建速度以及页面访问速度</h3><p>这条优化经验受kangshen启发，表示对大神的膜拜，具体思路是：<br>利用react-loadable懒加载，将生产模式下的路由配合react-loadable懒加载，显示哪个路由页面，就编译加载某个路由页面，这样既提高webpack编译速度，又提高页面访问速度。<br>将路由进行懒加载有一个弊端是只能看到你打开页面的报错，没有打开的页面报错你无法看到。</p><p>react-loadable 是2017年5月左右才出现，到如今，GitHub上已经有一万多颗star，是可以比拟react-redux的插件，非常棒，项目中如果有用到懒加载，用这个框架非常好react-loadable</p><h3 id="减少不必要的plugin"><a href="#减少不必要的plugin" class="headerlink" title="减少不必要的plugin"></a>减少不必要的plugin</h3><h2 id="热重载与热替换"><a href="#热重载与热替换" class="headerlink" title="热重载与热替换"></a>热重载与热替换</h2><h3 id="热重载-与-–inline"><a href="#热重载-与-–inline" class="headerlink" title="热重载 与 –inline"></a>热重载 与 –inline</h3><p>在使用webpack的 devServer时，只需在<code>npm script</code>中加入<code>--inline</code>,即可自动编译，自动重新加载整个页面。<a href="https://www.webpackjs.com/configuration/dev-server/#devserver-inline" target="_blank" rel="noopener">参考 配置-开发中 Server(devServer)</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack-dev-server --inline</span><br></pre></td></tr></table></figure></p><h3 id="热替换介绍"><a href="#热替换介绍" class="headerlink" title="热替换介绍"></a>热替换介绍</h3><p>热替换有两种方法，一种是使用webpack-dev-server，一种是使用webpack-hot-loader；</p><h3 id="热替换方式一：-webpack-dev-server"><a href="#热替换方式一：-webpack-dev-server" class="headerlink" title="热替换方式一： webpack-dev-server"></a>热替换方式一： webpack-dev-server</h3><p>webpack-dev-server有两种方法，<br>一种是直接在webpack.config.js中的devSever上配置hot实现。<br>一种是自定义配置。</p><h4 id="devSever"><a href="#devSever" class="headerlink" title="devSever"></a>devSever</h4><p>只需在<code>npm script</code>中加入<code>--hot</code>,<a href="https://www.webpackjs.com/configuration/dev-server/#devserver-hot" target="_blank" rel="noopener">参考 配置-开发中 Server(devServer)-devServer.hot</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack-dev-server --hot</span><br></pre></td></tr></table></figure></p><p>在<code>npm script</code>中加入<code>--hot</code>这一句代码相当于 在webpack.config.js的设置devServer.hot为<code>true</code>,并且在plugins中加了 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new webpack.HotModuleReplacementPlugin()</span><br></pre></td></tr></table></figure></p><p>所以，一旦在<code>npm script</code>中加入<code>--hot</code>，就要去掉plugins的<code>new webpack.HotModuleReplacementPlugin()</code>，不然就相当于执行了两次HotModuleReplacementPlugin，并因此可能报错。</p><p><strong>值得注意的是， 在webpack.config.js的设置devServer.hot为<code>true</code>效果并不佳，推荐在<code>npm script</code>中加入<code>--hot</code></strong></p><p>因此一般<code>npm script</code>配置如下，意思是当代码变化，重新编译的时候，如果热替换起作用，就执行热替换，如果热替换不起作用，就执行热重装整个页面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack-dev-server --inline --hot</span><br></pre></td></tr></table></figure></p><h4 id="express或koa-的自定义方式"><a href="#express或koa-的自定义方式" class="headerlink" title="express或koa 的自定义方式"></a>express或koa 的自定义方式</h4><p>有些项目不用webpack.config.js的设置devServer，而选择express或koa，直接引用webpack-dev-server插件自定义配置热替换效果，此时就需要配合 webpack-hot-middleware 与 webpack-dev-middleware 一起使用，才能达到效果。<br>详细见 <a href="https://github.com/YeWills/react-hot-loader-demo" target="_blank" rel="noopener">demo</a>。</p><h3 id="热替换方式二：-react-hot-loader"><a href="#热替换方式二：-react-hot-loader" class="headerlink" title="热替换方式二： react-hot-loader"></a>热替换方式二： react-hot-loader</h3><p>这是热替换最佳模式。具体配置方法，参见 <a href="https://github.com/YeWills/wills-react-pro/commit/971612a647e0a93c037c04830526cc684d90de76" target="_blank" rel="noopener">增加react-hot-loader热更新功能</a></p><h3 id="热替换最佳方案"><a href="#热替换最佳方案" class="headerlink" title="热替换最佳方案"></a>热替换最佳方案</h3><p>配置了几个项目的热加载后发现一般 webpack自带的webpack-dev-server方式的热替换一般效果不好或干脆失效，所以最佳方案是使用react-hot-loader。</p><h3 id="module-hot"><a href="#module-hot" class="headerlink" title="module.hot"></a>module.hot</h3><p>module.hot是一下代码是 webpack Hot Module Replacement API，在react-hot-loader v3的版本中要配置webpack Hot Module Replacement 的 module.hot。不过在v4的版本后，就不需要配置module.hot了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (module.hot) &#123;</span><br><span class="line">    module.hot.accept(&apos;./print.js&apos;, function()&#123;</span><br><span class="line">        console.log(&quot;Accepting the updated printMe module!&quot;);</span><br><span class="line">        printMe();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="react-hot-loader失效问题"><a href="#react-hot-loader失效问题" class="headerlink" title="react-hot-loader失效问题"></a>react-hot-loader失效问题</h3><h4 id="去掉不必要或重复配置"><a href="#去掉不必要或重复配置" class="headerlink" title="去掉不必要或重复配置"></a>去掉不必要或重复配置</h4><p>失效可能有很多问题，其中之一是 将不必要的配置删除，可以解决hot实效问题，例如在<code>npm script</code>中加入<code>--hot</code>，又在webpack.config.js的设置devServer.hot为<code>true</code>,并且在plugins中加HotModuleReplacementPlugin，就可能导致失效，删除重复配置即可。</p><h4 id="不要使用-createApp-而使用"><a href="#不要使用-createApp-而使用" class="headerlink" title="不要使用 createApp() 而使用"></a>不要使用 createApp() 而使用<app></app></h4><p>项目hot改造的坑在于application函数方式的缺点可能是，每次render页面都会执行函数，生成崭新的页面，这会有潜在的坑。—》解决之道函数方式改成 组件方式<code>&lt;app/&gt;</code><br>根据react-hot-loader的配置方法，需要改写为<code>&lt;app/&gt;</code>方式，并hot app；<br>详细见 <a href="https://github.com/YeWills/wills-react-pro/commit/971612a647e0a93c037c04830526cc684d90de76" target="_blank" rel="noopener">增加react-hot-loader热更新功能</a></p><h3 id="更多知识"><a href="#更多知识" class="headerlink" title="更多知识"></a>更多知识</h3><h4 id="–watch-与-热更新-1"><a href="#–watch-与-热更新-1" class="headerlink" title="–watch 与 热更新"></a>–watch 与 热更新</h4><p>参考《webpack 黑知识》</p><h4 id="自动编译与热更新三大条件-1"><a href="#自动编译与热更新三大条件-1" class="headerlink" title="自动编译与热更新三大条件"></a>自动编译与热更新三大条件</h4><p>参考《webpack 黑知识》</p><h4 id="webpack-dev-server黑知识-1"><a href="#webpack-dev-server黑知识-1" class="headerlink" title="webpack-dev-server黑知识"></a>webpack-dev-server黑知识</h4><p>参考《webpack 黑知识》</p><h2 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h2><h3 id="ContextReplacementPlugin-1"><a href="#ContextReplacementPlugin-1" class="headerlink" title="ContextReplacementPlugin"></a>ContextReplacementPlugin</h3><p>当项目用到moment时，务必使用此插件，可减少打包体积，以下代码为例，匹配moment/locale路径，只加载编译此路径下的/zh-cn|zh-hk|en/的文件。<br>new webpack.ContextReplacementPlugin(/moment[/\]locale$/, /zh-cn|zh-hk|en/)</p><h3 id="webpack-NormalModuleReplacementPlugin-1"><a href="#webpack-NormalModuleReplacementPlugin-1" class="headerlink" title="webpack.NormalModuleReplacementPlugin"></a>webpack.NormalModuleReplacementPlugin</h3><p>用法请看章节《构建与性能优化》</p><h3 id="webpack-DefinePlugin"><a href="#webpack-DefinePlugin" class="headerlink" title="webpack.DefinePlugin"></a>webpack.DefinePlugin</h3><p>此插件定义值时，都需加JSON.stringify。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    new webpack.DefinePlugin(&#123;</span><br><span class="line">      &apos;process.env.ASSET_PATH&apos;: JSON.stringify(&quot;5fa3b9&quot;),</span><br><span class="line">      &apos;process.env.FLAG&apos;: JSON.stringify(true)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p><h3 id="ProvidePlugin"><a href="#ProvidePlugin" class="headerlink" title="ProvidePlugin"></a>ProvidePlugin</h3><p>配置全局变量，自动加载模块，不必到处import或require：<br>例如设置$为全局变量，指向jq。<br>new webpack.ProvidePlugin({<br>  $: ‘jquery’,<br>  jQuery: ‘jquery’<br>})</p><h3 id="webpack-optimize-OccurrenceOrderPlugin-1"><a href="#webpack-optimize-OccurrenceOrderPlugin-1" class="headerlink" title="webpack.optimize.OccurrenceOrderPlugin"></a>webpack.optimize.OccurrenceOrderPlugin</h3><p>用法请看章节《构建与性能优化》</p><h3 id="happypack-1"><a href="#happypack-1" class="headerlink" title="happypack"></a>happypack</h3><p>用法请看章节《构建与性能优化》</p><h3 id="AutoDllPlugin"><a href="#AutoDllPlugin" class="headerlink" title="AutoDllPlugin"></a>AutoDllPlugin</h3><p>用法请看章节《构建与性能优化》</p><h3 id="webpack-parallel-uglify-plugin-1"><a href="#webpack-parallel-uglify-plugin-1" class="headerlink" title="webpack-parallel-uglify-plugin"></a>webpack-parallel-uglify-plugin</h3><p>用法请看章节《构建与性能优化》</p><h3 id="webpack-HashedModuleIdsPlugin-1"><a href="#webpack-HashedModuleIdsPlugin-1" class="headerlink" title="webpack.HashedModuleIdsPlugin"></a>webpack.HashedModuleIdsPlugin</h3><p>用法请看章节《构建与性能优化》</p><h3 id="webpack-optimize-AggressiveMergingPlugin-1"><a href="#webpack-optimize-AggressiveMergingPlugin-1" class="headerlink" title="webpack.optimize.AggressiveMergingPlugin"></a>webpack.optimize.AggressiveMergingPlugin</h3><p>用法请看章节《构建与性能优化》</p><h2 id="webpack-版本变化"><a href="#webpack-版本变化" class="headerlink" title="webpack 版本变化"></a>webpack 版本变化</h2><h3 id="css分离插件"><a href="#css分离插件" class="headerlink" title="css分离插件"></a>css分离插件</h3><p>webpack4.x弃用了extract-text-webpack-plugin，使用mini-css-extract-plugin代替，来做css从html中分离单独成一个css文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">const MiniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;);</span><br><span class="line"> module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(sc|c|sa)ss$/,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader, &#123;</span><br><span class="line">            loader: &apos;css-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;postcss-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              ident: &apos;postcss&apos;,</span><br><span class="line">              sourceMap: true,</span><br><span class="line">              plugins: (loader) =&gt; [require(&apos;autoprefixer&apos;)(&#123;browsers: [&apos;&gt; 0.15% in CN&apos;]&#125;)]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;sass-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: &apos;[name][hash].css&apos;, // 设置最终输出的文件名</span><br><span class="line">      chunkFilename: &apos;[id][hash].css&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure></p><h3 id="webpack注意事项"><a href="#webpack注意事项" class="headerlink" title="webpack注意事项"></a>webpack注意事项</h3><ul><li>不要在生产环境下使用inline模式的source map，因为这会使js文件变得很大，而且会泄露源码。</li><li>尽量写全名称，扩展名也写上 const common = require(‘./webpack.common.js’);不要写成require(‘./webpack.common’)，不利于编译查询。</li><li>线上发布，或CDN优化配置，大部分与合理配置publicpath有关。</li></ul><h2 id="参考和学习资料"><a href="#参考和学习资料" class="headerlink" title="参考和学习资料"></a>参考和学习资料</h2><h3 id="webpack-文档介绍"><a href="#webpack-文档介绍" class="headerlink" title="webpack 文档介绍"></a>webpack 文档介绍</h3><p>有两个webpack官网<br><a href="https://www.webpackjs.com/plugins/" target="_blank" rel="noopener">webpackjs 官网</a><br><a href="https://webpack.docschina.org/plugins/" target="_blank" rel="noopener">docschina 官网</a></p><p>其中webpackjs 官网的信息相比之下更全全，在webpackjs 官网中能搜索到插件NamedModulesPlugin，docschina 官网 中不能。<br>但是，webpack github上官方给出链接的官网是docschina 官网，为什么它信息还不全呢，可能的原因是不显示的API可能已经被废弃。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://ke.qq.com/course/321174" target="_blank" rel="noopener">老马全栈VIP2_02_webpack4配置入门到进阶</a><br><a href="https://www.imooc.com/learn/802" target="_blank" rel="noopener">webpack深入与实战</a><br><a href="https://www.imooc.com/learn/935" target="_blank" rel="noopener">Vue+Webpack打造todo应用</a><br>掘金小册-使用webpack定制前端开发环境<br>吴浩麟-深入浅出webpack<br><a href="https://www.webpackjs.com/" target="_blank" rel="noopener">webpack 官网</a><br>此官网下的四个子模块文档：<br>    <a href="https://www.webpackjs.com/concepts/" target="_blank" rel="noopener">webpack 文档官网_概念</a><br>    <a href="https://www.webpackjs.com/configuration/" target="_blank" rel="noopener">webpack 文档官网_配置</a><br>    <a href="https://www.webpackjs.com/api/" target="_blank" rel="noopener">webpack 文档官网_API</a><br>    <a href="https://www.webpackjs.com/guides/" target="_blank" rel="noopener">webpack 文档官网_指南</a><br>    <a href="https://www.webpackjs.com/loaders/" target="_blank" rel="noopener">webpack 文档官网_loader</a><br>    <a href="https://www.webpackjs.com/plugins/" target="_blank" rel="noopener">webpack 文档官网_插件</a><br><a href="https://segmentfault.com/a/1190000007479892" target="_blank" rel="noopener">webpack学习系列</a><br><a href="https://www.mmxiaowu.com/article/58482332d4352863efb55465" target="_blank" rel="noopener">WebPack 终极配置说明</a><br><a href="https://github.com/YeWills/webpack-code/tree/master" target="_blank" rel="noopener">原创webpack demo 主要应用分支</a><br><a href="https://github.com/YeWills/webpack-code/tree/ejsHtml" target="_blank" rel="noopener">原创webpack demo 模板ejs语法分支</a><br><a href="https://github.com/YeWills/webpack-code/tree/webpack_custom_merge_demo" target="_blank" rel="noopener">原创webpack demo 自定义merge config分支</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>css之移动开发</title>
      <link href="/2019/05/21/css_mobile/"/>
      <url>/2019/05/21/css_mobile/</url>
      
        <content type="html"><![CDATA[<h2 id="分辨率与像素"><a href="#分辨率与像素" class="headerlink" title="分辨率与像素"></a>分辨率与像素</h2><p>这是三星 GALAXY S5 手机<br><figure class="image-box">                <img src="/image/css_mobile/mobile1.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="pixels单词含义"><a href="#pixels单词含义" class="headerlink" title="pixels单词含义"></a>pixels单词含义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pixels //此单词含义为：像素</span><br></pre></td></tr></table></figure><p>所以px，指得就是像素。</p><h3 id="物理像素-与-分辨率"><a href="#物理像素-与-分辨率" class="headerlink" title="物理像素 与 分辨率"></a>物理像素 与 分辨率</h3><h4 id="物理像素"><a href="#物理像素" class="headerlink" title="物理像素"></a>物理像素</h4><p>上图中1920X1080像素，其实就是1920pxX1080px；如下图：<br><figure class="image-box">                <img src="/image/css_mobile/mobile2.jpg" alt="" title="" class="">                <p></p>            </figure><br>没错，这个像素就是(设备)物理像素(physical pixels)，它的单位也是px。(注意，这个px 非 css中使用的px，后面有讲解)。<br>上图表面，这个手机 横向的物理像素为 1080px; 竖向的物理像素为 1920px；<br>物理像素是一个虚拟的单位，与现实当中的厘米，毫米是两个东西，物理像素，能大能小，随不同设备变化。<br>(设备)物理像素，1px表示如下图的一个小方块：<br><figure class="image-box">                <img src="/image/css_mobile/img.jpg" alt="" title="" class="">                <p></p>            </figure><br>上图中Device pixels说的就是物理像素 (物理像素英文名肯定是physical pixels，这毫无疑问，但对是否是Device pixels还存一些考证，下面章节做了一些补充《别名 – Device pixels》)。</p><h4 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h4><p>屏幕分辨率为：1920*1080px；屏幕分辨率其实就是横向和竖向物理像素的组合表达的。因此：<br>(屏幕)分辨率是由横向和竖向的物理像素值表示的一种屏幕参考。</p><h4 id="分辨率不等同于物理像素"><a href="#分辨率不等同于物理像素" class="headerlink" title="分辨率不等同于物理像素"></a>分辨率不等同于物理像素</h4><p>由上分辨率的概念，屏幕分辨率不等同于物理像素。</p><h3 id="dpr-与-css像素"><a href="#dpr-与-css像素" class="headerlink" title="dpr 与 css像素"></a>dpr 与 css像素</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>dpr (devicePixelRatio)，设备像素比。<br>我们在实际开发中，会发现GALAXY S5的屏幕是 360pxX640px：<br><figure class="image-box">                <img src="/image/css_mobile/dpr.jpg" alt="" title="" class="">                <p></p>            </figure></p><p>GALAXY S5 的横向物理像素是1080px,为什么在上图中就变成360px了呢？<br>原来，手机厂商在手机出厂时，为每个手机提供了一个参数，这个参数就是dpr，通过window.devicePixelRatio获取。<br>根据MDN的解释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpr = 物理像素/css像素</span><br></pre></td></tr></table></figure></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio" target="_blank" rel="noopener">MDN的解释原文</a>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The Window property devicePixelRatio returns the ratio of the resolution in physical pixels (物理像素) to the resolution in CSS pixels (css像素) for the current display device.</span><br></pre></td></tr></table></figure></p><p>因此，拿到一个手机的分辨率后，再通过window.devicePixelRatio 获取dpr后，就知道这个手机在前端开发时，它的css像素的 宽高。</p><h4 id="dpr是联系分辨率与css像素的桥梁"><a href="#dpr是联系分辨率与css像素的桥梁" class="headerlink" title="dpr是联系分辨率与css像素的桥梁"></a>dpr是联系分辨率与css像素的桥梁</h4><p>由上可知，如何让分辨率为前端技术所用，就是通过手机厂商定义的dpr，把分辨率变成我们前端可以理解的css像素。</p><h4 id="css像素"><a href="#css像素" class="headerlink" title="css像素"></a>css像素</h4><p>以上什么分辨率，物理像素，通通我们都不熟悉，都与前端开发无关，因为他们不是前端技术的度量范畴，此时说到css像素，是不是倍感亲切了，<br>它就是我们日常用的px，上面部分说的css像素就是这个东西。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//这个100px就是css像素</span><br><span class="line">.wrap&#123;</span><br><span class="line">    width:100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="dpr与css像素关系"><a href="#dpr与css像素关系" class="headerlink" title="dpr与css像素关系"></a>dpr与css像素关系</h4><p>在iPhone4之前，手机的dpr一般都是1，那时候手机的物理像素就是css像素。<br>随着iPhone4及以后高清屏的出现，dpr开始大于1，目前dpr场景值为 1、1.5、2、3。</p><h4 id="iPhone4是Retina屏"><a href="#iPhone4是Retina屏" class="headerlink" title="iPhone4是Retina屏"></a>iPhone4是Retina屏</h4><p>从iPhone4开始，及以后的iPhone都是Retina屏。<a href="https://baike.baidu.com/item/Retina/4616695?fr=aladdin" target="_blank" rel="noopener">参考</a></p><h3 id="放大2倍还是4倍？"><a href="#放大2倍还是4倍？" class="headerlink" title="放大2倍还是4倍？"></a>放大2倍还是4倍？</h3><p>下图 左侧是dpr=1，右侧dpr=2；<br>这里的放大几倍基于物理像素(英文可以是physical pixels 或 Device pixels )而言，<br>一个css像素为2X2px的元素。<br>dpr=1下，物理像素是 2X2px；<br>dpr=2下，物理像素是 4X4px；<br><figure class="image-box">                <img src="/image/css_mobile/img.jpg" alt="" title="" class="">                <p></p>            </figure><br>dpr=2下，原来的1小方块变成4个方块表示，好像是放大了四倍，其实不然，<br>1个方块可以写成：1X1px;<br>4个方块可以写成：2X2px；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//其实就是放大2倍</span><br><span class="line">(2*2px)/(1*1px) === 2</span><br><span class="line"></span><br><span class="line">//其实还是放大2倍</span><br><span class="line">(4*4px)/(2*2px) === 2</span><br></pre></td></tr></table></figure></p><p>所以dpr=2时相比dpr=1时，只是放大了两倍。<br>下面讲到的响应式设计时，用到媒体查询，需要UI根据dpr设计不同倍率的图片，需要多少倍的图片，由上面就知道了。</p><h3 id="多倍图响应式设计"><a href="#多倍图响应式设计" class="headerlink" title="多倍图响应式设计"></a>多倍图响应式设计</h3><p>当dpr大于1是，容易出现图片模糊的问题，以iPhone6为例:<br>iPnone6参数：<br><figure class="image-box">                <img src="/image/css_mobile/flex.jpg" alt="" title="" class="">                <p></p>            </figure><br>iPnone6 的 dpr为2，对应的屏幕的css像素尺寸为：375X667px；<br>由图片可知，i6的横向物理像素为750px，此时，如果在html页面定义展示一个img{width:375px}的图片，<br>i6在展示时因为会将此图片拉伸两倍，导致图片失真。解决的方法是，让UI设计一个750px的图片，避免失真，<br>这里解释失真可能有些牵强，姑且这样理解吧，也或者简单理解成，凡是dpr大于1的手机，<strong>只要提供与手机物理像素不一致的图片,显示时都会失真；</strong><br>不用太穷究为什么要失真，知道这样会失真就行。如果对失真有兴趣，去网上搜索，很多资源。</p><p>高清时，一般也就图片这种失真的情况，其他还好，为了解决这个图片失真，一般采用媒体查询方式。</p><h4 id="如何才图片不失真"><a href="#如何才图片不失真" class="headerlink" title="如何才图片不失真"></a>如何才图片不失真</h4><p>由上面推测可知，<strong>只有UI给的图片与手机的物理像素相等时才不失真</strong>，<br>比如，我在html上定义了一个100px css像素的图片；<br>手机的dpr为2；<br>此时这个100px css像素，对应的是 100*2=200px 的物理像素尺寸。<br>此时只有UI提供200px的图片放在上面的HTMl上才不失真。</p><h4 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h4><p>解决方法如下，详细的可网上搜索：<br>主要思路，就是让UI提供几种不同尺寸的图片，通过媒体查询方式灵活使用。<a href="https://www.cnblogs.com/sese/p/5977486.html" target="_blank" rel="noopener">参考</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.css&#123;/* 普通显示屏(设备像素比例小于等于1.3)使用1倍的图 */ </span><br><span class="line">    background-image: url(img_1x.png);</span><br><span class="line">&#125;</span><br><span class="line">@media only screen and (-webkit-min-device-pixel-ratio:1.5),</span><br><span class="line">       (min-resolution: 1.5dppx)&#123;</span><br><span class="line">            .css&#123;/* 高清显示屏(设备像素比例大于等于1.5)使用2倍图  */</span><br><span class="line">                background-image: url(img_2x.png);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>媒体查询设备像素比主要查询 min-resolution,而webkit-min-device-pixel-ratio是一个意思，为了兼容safari。见《精通css》P233<br>当然，解决失真的方式还有js或svg矢量图的方式。</p><h3 id="ppi"><a href="#ppi" class="headerlink" title="ppi"></a>ppi</h3><p>ppi:屏幕像素密度,这个概念其实与前端开发无关，可以不用过多了解。<br>只是最上面的图片中提到了GALAXY S5 的像素密度，具体公式如下，<a href="https://www.jianshu.com/p/c3387bcc4f6e" target="_blank" rel="noopener">详细了解点击这里</a>：<br><figure class="image-box">                <img src="/image/css_mobile/ppi.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>下面列举了如 设备独立像素、什么其他像素…这些统统不要管，与前端开发无关，与前端开发有关的东西，上面已经单独列出讲解。<br>在这里写一些别名，只是为了在阅读别人的文文章时，他们写出这些名词你知道是什么，避免看不懂其他人的文章。</p><h4 id="设备独立像素"><a href="#设备独立像素" class="headerlink" title="设备独立像素"></a>设备独立像素</h4><p>有很多地方将 dpr = 物理像素 /设备独立像素;<br>显然这里 将设备独立像素看成是css像素了。我这里不说对不对，这里只是让大家知道<strong>设备独立像素 把它简单认为是 css像素就好，不必深究。</strong>关于dpr的定义还是以MDN网址定义为准，请看上文《dpr 与 css像素》<br><a href="https://www.jianshu.com/p/3d28f4959c5a?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">参见</a></p><p>我们再看 它的定义：<br><a href="https://www.cnblogs.com/jiangzilong/p/6700023.html" target="_blank" rel="noopener">设备独立像素（Device Independent Pixel）：与设备无关的逻辑像素，代表可以通过程序控制使用的虚拟像素，是一个总体概念，包括了CSS像素</a></p><h4 id="设备无关的像素"><a href="#设备无关的像素" class="headerlink" title="设备无关的像素"></a>设备无关的像素</h4><p>参考《设备独立像素》。<br>设备无关的像素 其实就是 设备独立像素 的说法，下面公式是相等的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CSS像素 =设备独立像素 = 设备无关的像素</span><br></pre></td></tr></table></figure></p><h4 id="逻辑像素"><a href="#逻辑像素" class="headerlink" title="逻辑像素"></a>逻辑像素</h4><p><a href="https://www.jianshu.com/p/3d28f4959c5a?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">这篇文章提到:</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CSS像素 =设备独立像素 = 逻辑像素</span><br></pre></td></tr></table></figure></p><h4 id="设备像素"><a href="#设备像素" class="headerlink" title="设备像素"></a>设备像素</h4><p>设备像素也是物理像素，物理像素全称，设备物理像素，下面公式成立：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">物理像素===设备像素===设备物理像素===physical pixels====Device pixels</span><br></pre></td></tr></table></figure></p><h4 id="虚拟像素"><a href="#虚拟像素" class="headerlink" title="虚拟像素"></a>虚拟像素</h4><p>其实 物理像素、css像素、这些都是虚拟像素。(个人认为，未佐证)</p><h4 id="Device-pixels"><a href="#Device-pixels" class="headerlink" title="Device pixels"></a>Device pixels</h4><p>Device pixels应该就是物理像素的英文名称，<a href="https://www.w3schools.com/cssref/css_units.asp" target="_blank" rel="noopener">根据外文W3c – CSS Units 中关于 px的解释</a>，原文如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* Pixels (px) 【css像素】 are relative to the viewing device. For low-dpi devices, 1px is one device pixel (dot) of the display. For printers and high resolution screens 1px implies multiple device pixels【多倍的设备像素】.</span><br></pre></td></tr></table></figure></p><p>结合上面的分析，我们知道，屏幕中一般只有一种设备像素，那就是物理像素，因此物理像素的另外英文名称为 device pixels.</p><h3 id="物理像素的px与css像素px区别"><a href="#物理像素的px与css像素px区别" class="headerlink" title="物理像素的px与css像素px区别"></a>物理像素的px与css像素px区别</h3><p>虽然通过上面的分析，我们知道物理像素与css像素，有本质上的不同。<br>不过通过分析多倍dpr图片失真问题，解决失真，就要放与物理像素相同的px图片时才不失真。我们知否可大胆推测物理像素的px可能与css像素的px是一回事。<br>以上仅代表个人揣测。<br>然而物理像素确实又与css像素有本质区别。</p><h2 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h2><p>视口部分，参考《精通css》这边书，若有问题，查询这边书的第八章。</p><h3 id="理想视口"><a href="#理想视口" class="headerlink" title="理想视口"></a>理想视口</h3><p>理想视口就是每个手机的屏幕css像素尺寸，例如GALAXY S5屏幕360pxX640px，它的理想视口就是360pxX640px 的css像素尺寸。 见《dpr 与 css像素》。</p><h3 id="默认视口"><a href="#默认视口" class="headerlink" title="默认视口"></a>默认视口</h3><p>手机设备都有一个默认视口，且不同类型的手机设备，其默认视口都是一样的尺寸，不同类型手机设备的默认视口，宽约为1000px css像素。<br>每想到吧，默认视口居然还有一个统一的宽度：约为1000px css像素，而且不同类型的手机宽度一样。</p><h3 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h3><h4 id="理想视口显示"><a href="#理想视口显示" class="headerlink" title="理想视口显示"></a>理想视口显示</h4><p>使用 理想视口显示，设置meta如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;</span><br></pre></td></tr></table></figure></p><h4 id="默认视口显示"><a href="#默认视口显示" class="headerlink" title="默认视口显示"></a>默认视口显示</h4><p>如果不设置meta，那么手机将采用默认视口显示，将html写的页面按照屏幕宽大约1000px排列布局好，然后把它缩小显示到手机中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;vs_test&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .wrap &#123;</span><br><span class="line">            background: rebeccapurple;</span><br><span class="line">            word-break: break-word;</span><br><span class="line">            font-size: 16px;</span><br><span class="line">        &#125;</span><br><span class="line">        .cell&#123;</span><br><span class="line">            display: inline-block;</span><br><span class="line">            height: 50px;</span><br><span class="line">            width: 100px;</span><br><span class="line">            font-size: 40px;</span><br><span class="line">        &#125;</span><br><span class="line">        .cell:nth-child(even)&#123;</span><br><span class="line">            background: #FF9800</span><br><span class="line">        &#125;</span><br><span class="line">        .cell:nth-child(odd)&#123;</span><br><span class="line">            background: #00BCD4</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;wrap&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;cell&quot;&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;cell&quot;&gt;2&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;cell&quot;&gt;3&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;cell&quot;&gt;4&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;cell&quot;&gt;5&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;cell&quot;&gt;6&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;cell&quot;&gt;7&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;cell&quot;&gt;8&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;cell&quot;&gt;9&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;cell&quot;&gt;0&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;cell&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;cell&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;cell&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;cell&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;cell&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p> GALAXY S5手机端显示如下：<br><figure class="image-box">                <img src="/image/css_mobile/view-port.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="默认视口-与-qq截图工具量元素尺寸"><a href="#默认视口-与-qq截图工具量元素尺寸" class="headerlink" title="默认视口 与 qq截图工具量元素尺寸"></a>默认视口 与 qq截图工具量元素尺寸</h4><p>如上图所示， 采用默认视口显示，会将原来在大约1000px显示好的页面，缩小到GALAXY S5手机宽360px的屏幕显示，<br>这样调试的时候，我们就无法使用qq或微信的截图工具里面显示的尺寸，来量元素的尺寸。<br>以此举一反三，只有移动端采用理想视口的情况时，才可以使用qq截图工具量元素尺寸。<br>不过，pc浏览器屏幕不存在此情况，pc浏览器任何情况下可以采用qq截图工具量尺寸。</p><h3 id="不要禁用缩放"><a href="#不要禁用缩放" class="headerlink" title="不要禁用缩放"></a>不要禁用缩放</h3><p>很多人喜欢用下面的方式来定义meta，下面配置了user-scalable=no，禁用了缩放，这样是不推荐的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//不推荐这种写法，因为禁用了缩放</span><br><span class="line">&lt;meta </span><br><span class="line">    name=&quot;viewport&quot; </span><br><span class="line">    content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot;</span><br><span class="line"> /&gt;</span><br></pre></td></tr></table></figure></p><p>推荐写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//推荐写法：</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>上面写initial-scale=1完全是为了兼容，如果不考虑兼容，直接这样写就行，因为initial-scale=1表达的意思和width=device-width一样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//推荐写法也可以这样写</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;</span><br></pre></td></tr></table></figure></p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="http://www.ituring.com.cn/book/1910" target="_blank" rel="noopener">精通css 高级web标准解决方案</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio" target="_blank" rel="noopener">MDN –devicePixelRatio</a><br><a href="https://www.w3schools.com/cssref/css_units.asp" target="_blank" rel="noopener">外文W3c –CSS Units</a><br><a href="https://www.cnblogs.com/sese/p/5977486.html" target="_blank" rel="noopener">高清屏及适配不同设备的方案总结</a><br><a href="https://www.jianshu.com/p/c3387bcc4f6e" target="_blank" rel="noopener">（全解析）屏幕尺寸，分辨率，像素，PPI之间到底什么关系？</a><br><a href="https://www.jianshu.com/p/3d28f4959c5a?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">一篇文章搞懂CSS像素、物理像素、逻辑像素、设备像素比、PPI、Viewport</a><br><a href="https://www.cnblogs.com/jiangzilong/p/6700023.html" target="_blank" rel="noopener">CSS像素、设备独立像素、设备像素之间关系</a></p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 屏幕分辨率 </tag>
            
            <tag> 物理像素 </tag>
            
            <tag> css像素 </tag>
            
            <tag> ppi </tag>
            
            <tag> dpr </tag>
            
            <tag> 多倍图的响应式设计 </tag>
            
            <tag> 视口 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js设计模式下</title>
      <link href="/2019/05/21/js_design_main/"/>
      <url>/2019/05/21/js_design_main/</url>
      
        <content type="html"><![CDATA[<p>js设计模式分两篇来写，此为下篇，上篇为 《js设计模式上(面向对象、闭包、命名空间)》。<br>主要讲设计原则与设计模式两部分。</p><h1 id="js设计原则"><a href="#js设计原则" class="headerlink" title="js设计原则"></a>js设计原则</h1><p>js设计原则有四五个，但真正在js编程中的用得最多的差不多就两个：单一职责原则、开放封闭原则。<br>另外在本节的最后部分，附上《unix／linux 设计哲学》书中提到的几个linux的编码准则，列举其中对js编码有启发意义的几个。</p><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>单一职责原则：一个对象（方法）只做一件事情。<br>单一职责原则要求我们在写复杂方法时，将方法进行抽象，分离颗粒化成多个方法，让每个方法只做一件事情。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：让一个方法只做一个事情，将复杂职责分解为多个职责，后期维护代码的时候，修改其中一个职责，也就不会影响其他职责，这样代码可读性、可维护性、可扩张、可移植性更好，也更符合开放封闭原则。<br>缺点：增加编写代码的复杂度（能写出单一职责设计原则代码的程序员，也是要求他有一定编程水平才能写出的），当我们按照职责把对象分解成更小粒度之后，实际上也增大了这些对象之间相互联系的难度。</p><p>单一职责原则是js编写代码最重要的两个准则之一，在它的优点面前，它的缺点不值得一提。</p><h2 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>开放封闭原则：对扩展开放，对修改封闭。<br>开放封闭原则要求我们写出来的方法，当对程序方法进行扩展时，更加方便，不要修改原来的行为方法。</p><p>通过一段代码来体现 开放封闭原则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 这是原代码，此代码相比之下，每次扩展都需要修改makeSound方法，违反了开放封闭原则</span><br><span class="line">//每次扩展时，因为要修改公共方法makeSound，你还要担心有回归测试的一些问题，还要去测试Duck和Chicken</span><br><span class="line">var makeSound = function(animal)&#123;</span><br><span class="line">  if(animal instanceof Duck)&#123;</span><br><span class="line">    console.log(&apos;嘎嘎嘎&apos;);</span><br><span class="line">  &#125;else if(animal instanceof Chicken)&#123;</span><br><span class="line">    console.log(&apos;咯咯咯&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var Duck = function()&#123;&#125;</span><br><span class="line">var Chicken = function()&#123;&#125;</span><br><span class="line">makeSound(new Duck);</span><br><span class="line">makeSound(new Chicken);</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 这是改良后代码，此代码相比之下，每次扩展都不用修改makeSound方法，更加易于扩展，而且makeSound是一个公共的方法，</span><br><span class="line">//每次扩展时，因为不用修改公共方法makeSound，就不会担心有回归测试的一些问题，不用担心还要去测试Duck和Chicken</span><br><span class="line">var makeSound = function(animal)&#123;</span><br><span class="line">  animal.sound();</span><br><span class="line">&#125;</span><br><span class="line">var Duck = function()&#123;&#125;</span><br><span class="line">Duck.prototype.sound = function()&#123;</span><br><span class="line">  console.log(&apos;嘎嘎嘎&apos;);</span><br><span class="line">&#125;</span><br><span class="line">var Chicken = function()&#123;&#125;</span><br><span class="line">Chicken.prototype.sound = function()&#123;</span><br><span class="line">  console.log(&apos;咯咯咯&apos;);</span><br><span class="line">&#125;</span><br><span class="line">makeSound(new Duck);</span><br><span class="line">makeSound(new Chicken);</span><br><span class="line"></span><br><span class="line">//增加新需求，添加一个Dog行为</span><br><span class="line">var Dog = function()&#123;&#125;</span><br><span class="line">Dog.prototype.sound = function()&#123;</span><br><span class="line">  console.log(&apos;汪汪汪&apos;);</span><br><span class="line">&#125;</span><br><span class="line">makeSound(new Dog);</span><br></pre></td></tr></table></figure><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：从上面代码例子中看到，开放封闭原则的代码，后期可维护性更高，扩展性更强，当有扩展新功能时，风险更小，要做的回归测试问题更少，因此维护、扩展成本更低。<br>缺点：在项目刚开始时，因为业务不熟，或业务不稳定，因此你很难抽象出 方法中永远变化的部分和永远不变化的部分进行封装。</p><h3 id="接受第一次愚弄"><a href="#接受第一次愚弄" class="headerlink" title="接受第一次愚弄"></a>接受第一次愚弄</h3><p>为了解决上面说的缺点，一种现实的做法是，在项目刚开始时，我们假设方法的所有部分都是不变化的，不对方法进行开放封闭进行抽象封装处理，项目初期快速编码完成需求，不影响项目进度。<br>当后期变化发生时，再来回过头来封装这些变化地方，确保下一次不会掉进同一个坑里。<br>我们将这条编码经验称之为 ‘接受第一次愚弄’，但永远不会被同样的招数击倒第二次。</p><h2 id="其他准则"><a href="#其他准则" class="headerlink" title="其他准则"></a>其他准则</h2><p>下面是unix／linux 设计哲学 的 几条准则，对js编程依然有借鉴：<br>准则1:小即是美<br>准则2:让每个程序只做好一件事情<br>准则3:快速建立原型（快速更早将功能骨架做好，先让用户用起来，然后客户边用边反馈，开发根据这个实施开发客户反馈需求）<br>准则4:舍弃高效率而取可移植性（硬件升级或浏览器内核升级后，原来不高效的写法，因为计算机硬件提高，原来不高效写法不影响效率了）<br>准则5:充分地抽象封装程序，以此达到程序复用性</p><h1 id="js设计模式"><a href="#js设计模式" class="headerlink" title="js设计模式"></a>js设计模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>单例模式 定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><h3 id="标准单例模式示例"><a href="#标准单例模式示例" class="headerlink" title="标准单例模式示例"></a>标准单例模式示例</h3><p>标准的单例模式示例，如下代码符合单例模式的几点定义：</p><ul><li>Singletom是一个类；</li><li>new Singletom 是它点实例；</li><li>全局范围内，可通过Singletom访问这个类。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//标准的单例模式示例</span><br><span class="line">var Singletom = function(name)&#123;</span><br><span class="line">            console.log(name)</span><br><span class="line">          &#125;</span><br><span class="line">Singletom.getInstance = (function()&#123;</span><br><span class="line">var instance = null;</span><br><span class="line">return function(name)&#123;</span><br><span class="line">    if(!instance)&#123;</span><br><span class="line">    instance = new Singletom(name);</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)()</span><br><span class="line">var a = Singletom.getInstance(&apos;sven1&apos;);</span><br><span class="line">var b = Singletom.getInstance(&apos;sven2&apos;);</span><br><span class="line">console.log(a === b)//true</span><br></pre></td></tr></table></figure><h3 id="将以上-标准单例模式示例-优化"><a href="#将以上-标准单例模式示例-优化" class="headerlink" title="将以上 标准单例模式示例 优化"></a>将以上 标准单例模式示例 优化</h3><p>上面的标准示例，将new 实例和 管理是否有无两个功能放在一个函数内，违背了 单一职责原则，在此改造下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//优化后的单例模式示例</span><br><span class="line">var CreateDiv = function(html)&#123;</span><br><span class="line">          this.html = html;</span><br><span class="line">          this.init()</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">CreateDiv.prototype.init = function()&#123;</span><br><span class="line">    var div = document.createElement(&apos;div&apos;);</span><br><span class="line">    div.innerHTML = this.html;</span><br><span class="line">    document.body.appendChild(div);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var ProxySingletonCreateDiv = (function()&#123;</span><br><span class="line">    var instance;</span><br><span class="line">    return function(html)&#123;</span><br><span class="line">    if(! instance)&#123;</span><br><span class="line">        instance = new CreateDiv(html);</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line">var a = new ProxySingletonCreateDiv(&apos;sven1&apos;);</span><br><span class="line">var b = new ProxySingletonCreateDiv(&apos;sven2&apos;);</span><br><span class="line">console.log(a === b)//true</span><br></pre></td></tr></table></figure></p><h3 id="通用的单例模式示例"><a href="#通用的单例模式示例" class="headerlink" title="通用的单例模式示例"></a>通用的单例模式示例</h3><p>上面我们解释了标准的单例模式，这样可以更加容易理解单例模式是什么，在实际应用中，我们更偏向使用基于以上标准单例模式改造而来的通用的单例模式。<br>我们不必拘泥于单例模式的定义，单例模式必须要求是一个类 和 实例，<br>其实类也是一个函数，实例其实就是对call或apply的应用，我们不必拘泥于new 实例，大可 将 函数的直接执行 来 代替实例。<br>单例模式的精神就是：</p><ul><li>有一个全局的函数（类）</li><li>此函数被执行或被实例一次<br>满足了以上两个条件，都可以称之为单例设计模式；<br>下面写了一个经典 单例模式示例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//优化后的单例模式示例</span><br><span class="line">var num = 0;</span><br><span class="line">var CreateDiv = function(...args)&#123;</span><br><span class="line">    num ++;</span><br><span class="line">    console.log(args[0],`一共执行了$&#123;num&#125;次`);</span><br><span class="line">    var div = document.createElement(&apos;div&apos;);</span><br><span class="line">    div.innerHTML = this.html;</span><br><span class="line">    document.body.appendChild(div);</span><br><span class="line">    return div;</span><br><span class="line">&#125;</span><br><span class="line">ProxySingletonCreateDiv 专门用来管理 函数是否执行</span><br><span class="line">var ProxySingletonCreateDiv = function(fn)&#123;</span><br><span class="line">    var instance;</span><br><span class="line">    return function()&#123;</span><br><span class="line">    if(! instance)&#123;</span><br><span class="line">        instance = fn.apply(this, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var a = ProxySingletonCreateDiv(CreateDiv);</span><br><span class="line"></span><br><span class="line">a(&apos;单例模式&apos;)//单例模式 一共执行了1次</span><br><span class="line">a(&apos;单例模式&apos;)//单例模式 一共执行了1次</span><br><span class="line"></span><br><span class="line">//如果我们要扩展，增加一个CreateFrame，只需这样做,非常容易扩展</span><br><span class="line">var CreateFrame = function(...args)&#123;</span><br><span class="line">    console.log(args[0]);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">var f = ProxySingletonCreateDiv(CreateFrame);</span><br><span class="line">f(&apos;单例模式&apos;)//单例模式 一共执行了1次</span><br><span class="line">f(&apos;单例模式&apos;)//单例模式 一共执行了1次</span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>购物车，登陆，redux 的 store都是单例模式的运用。</p><h3 id="如何写一个单例模式"><a href="#如何写一个单例模式" class="headerlink" title="如何写一个单例模式"></a>如何写一个单例模式</h3><p>由上面例子看到，写一个单例模式的功能，基本上要借助闭包来实现。<br>通过上面的例子看到，在单例模式中，请将管理单例 和 功能函数 分开编写。</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式也称为发布订阅模式</p><h3 id="es6示例"><a href="#es6示例" class="headerlink" title="es6示例"></a>es6示例</h3><h4 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h4><p>对下面例子解说，<br>新闻公司通过 暴露出来一个接口attach，用来给订阅者(观察者)报名或参加订阅，<br>新闻公司内部，用以下几个属性用来记录情况：<br>this.foodState —- 将要推送的 食品消息<br>this.houseState —- 将要推送的 房产消息<br>this.foodObservers —- 食品消息订阅者个人信息<br>this.houseObservers —- 房产消息订阅者个人信息<br>this.deliveryType —- 将要推送的消息的类别<br>deliveryState —- 推送消息<br>notifyAllObservers  —- 给每个订阅者打电话将消息通知给订阅者<br>getState —- 暴露给订阅者的API,订阅者接到通知消息的电话后，可通过公司提供的渠道网站或短信来看新闻</p><p>订阅者：<br>订阅者用以下几个属性来记录情况<br>this.phoneNum —- 订阅新闻需要提供给新闻公司的 手机号码<br>this.subscribeType  —- 订阅新闻需要提供给新闻公司的 新闻类别<br>this.company  —- 用来保存公司资料，刚开始是根据公司提供的报名方式attach进行报名，后期新闻发送消息是，<br>                   可以通过公司提供的渠道(this.company.getState)查看消息，也可以针对新闻服务公司的服务态度，给公司反馈或投诉建议<br>this.company.attach 通过公司对外暴露的接口，登记报名订阅。</p><p>cellphone 订阅者对外暴露给新闻公司自己接收消息的方式，用来update。</p><h4 id="示例小结"><a href="#示例小结" class="headerlink" title="示例小结"></a>示例小结</h4><p>新闻公司必须 对订阅者暴露 订阅方式attach；<br>订阅者必须 对公司暴露 接收消息方式cellphone；<br>因为订阅者要 保存公司的资料，例如获取订阅方式等等，所以订阅者必须设计一个属性用来保存公司这个对象总类；<br>因为公司要 保存订阅者的资料，例如获取订阅者的接收方式等等，所以公司必须设计一个属性用来保存订阅者完整类；</p><p>因为公司要 发送消息deliveryState，就要用一个属性来保存将要发的消息foodState，然后要执行打电话通知notifyAllObservers，<br>通知完后，还要提供网站或app或短信等渠道getState，让订阅者查看新闻。</p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><p>此代码针对上面解说而写的，此示例代码的好处是可以很好地先理解好观察者到底是一个什么东西。<br>但此代码也有弊端，例如NewsCompany不易维护性，NewsCompany中维护了food，house，如果将来增加了money等等呢，需要改写NewsCompany内部。所以NewsCompany需要进一步优化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">// 主题，接收状态变化，触发每个观察者</span><br><span class="line"></span><br><span class="line">class NewsCompany &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.foodState = 0</span><br><span class="line">        this.houseState = 0</span><br><span class="line">        this.foodObservers = []</span><br><span class="line">        this.houseObservers = []</span><br><span class="line">        this.deliveryType = 0</span><br><span class="line">    &#125;</span><br><span class="line">    getState() &#123;</span><br><span class="line">        if(this.deliveryType === &apos;food&apos;)&#123;</span><br><span class="line">            return this.foodState</span><br><span class="line">        &#125;</span><br><span class="line">        return this.houseState</span><br><span class="line">    &#125;</span><br><span class="line">    deliveryState(state,deliveryType) &#123;</span><br><span class="line">        if(deliveryType === &apos;food&apos;)&#123;</span><br><span class="line">            this.foodState = state</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            this.houseState = state</span><br><span class="line">        &#125;</span><br><span class="line">        this.deliveryType = deliveryType;</span><br><span class="line">        this.notifyAllObservers(deliveryType)</span><br><span class="line">    &#125;</span><br><span class="line">    attach(observer) &#123;</span><br><span class="line">        if(observer.subscribeType === &apos;food&apos;)&#123;</span><br><span class="line">            this.foodObservers.push(observer)</span><br><span class="line">        &#125;</span><br><span class="line">        if(observer.subscribeType === &apos;house&apos;)&#123;</span><br><span class="line">            this.houseObservers.push(observer)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    notifyAllObservers(type) &#123;</span><br><span class="line">        const observers = type === &apos;food&apos; ? this.foodObservers : this.houseObservers;</span><br><span class="line">        observers.forEach(observer =&gt; &#123;</span><br><span class="line">            //发布消息，给每个订阅者留的电话打电话，通知订阅者</span><br><span class="line">            observer.cellphone()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 观察者，等待被触发</span><br><span class="line">class Observer &#123;</span><br><span class="line">    constructor(phoneNum, subscribeType ,company) &#123;</span><br><span class="line">        this.phoneNum = phoneNum</span><br><span class="line">        //订阅的第一步，就必须获得订阅内容的资料或对象，我们把这个对象看成是新闻服务公司，这个新闻服务公司提供很多种类的新闻：房产新闻，食品新闻，体育新闻。。。。</span><br><span class="line">        this.company = company //必不可少，将公司资料保存下来，可以针对新闻服务公司的服务态度，给公司反馈或投诉建议</span><br><span class="line">        this.subscribeType = subscribeType</span><br><span class="line">        this.company.attach(this)//报名，参加订阅，这一步是不是可以理解为订阅.attach就是公司给订阅者的报名方式</span><br><span class="line">    &#125;</span><br><span class="line">    //cellphone 新闻服务公司，有消息时会打电话给每个订阅者，cellphone模拟的是订阅者手机接到电话的行为，很多示例中将cellphone写作update，不过为了方便理解，在此写成cellphone</span><br><span class="line">    cellphone() &#123;</span><br><span class="line">        console.log(`$&#123;this.phoneNum&#125; 收到, state新闻: $&#123;this.company.getState()&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 测试代码</span><br><span class="line">let newsCompany = new NewsCompany()</span><br><span class="line">//对于新闻服务公司来说，他只需要知道 订阅者 电话号码 和 订阅内容即可，一个人可以有很多特性，例如名字，性别，爱好等等，</span><br><span class="line">//但对于新闻服务公司而言，它只需要知道订阅者的 手机号码 和 新闻类别，所以一个订阅者的对象，只需要具备手机号码和订阅新闻类别两个属性即可。</span><br><span class="line">//所以我们上面设计的订阅者类Observer，只有phoneNum, subscribeType 两个属性。</span><br><span class="line">//从观察者的角度看，它还需要 一个属性来将公司资料保存下来，可以针对新闻服务公司的服务态度，给公司反馈或投诉建议</span><br><span class="line">//基于以上，一个订阅者，需要设置三个属性，而cellphone是公司打电话来时，模拟订阅者手机接到电话的行为</span><br><span class="line">let o1 = new Observer(&apos;15099281126&apos;, &apos;food&apos;, newsCompany)</span><br><span class="line">let o2 = new Observer(&apos;15099281127&apos;, &apos;food&apos;, newsCompany)</span><br><span class="line">let o3 = new Observer(&apos;15099281128&apos;, &apos;food&apos;, newsCompany)</span><br><span class="line">newsCompany.deliveryState(&apos;奶制食品新闻&apos;,&apos;food&apos;);//给每个订阅者发布消息</span><br><span class="line"></span><br><span class="line">let o7 = new Observer(&apos;13899761271&apos;, &apos;house&apos;, newsCompany)</span><br><span class="line">let o8 = new Observer(&apos;13899761272&apos;, &apos;house&apos;, newsCompany)</span><br><span class="line">let o9 = new Observer(&apos;13899761273&apos;, &apos;house&apos;, newsCompany)</span><br><span class="line">newsCompany.deliveryState(&apos;房产新闻&apos;,&apos;house&apos;);//给每个订阅者发布消息</span><br></pre></td></tr></table></figure></p><h4 id="优化及延伸方式一"><a href="#优化及延伸方式一" class="headerlink" title="优化及延伸方式一"></a>优化及延伸方式一</h4><p>对示例代码优化及延伸方式一：<br>上面代码不易扩展，将上面代码优化：NewsCompany中去掉constructor，并且改写food与house切换，将cellphone改为callback不再统一管理callback：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">class NewsCompany &#123;</span><br><span class="line">    deliveryState(state,deliveryType) &#123;</span><br><span class="line">        this[`$&#123;deliveryType&#125;State`] = state;</span><br><span class="line">        this.deliveryType = deliveryType;</span><br><span class="line">        this.notifyAllObservers()</span><br><span class="line">    &#125;</span><br><span class="line">    attach(observer) &#123;</span><br><span class="line">        const &#123;subscribeType&#125; = observer;</span><br><span class="line">        if(!this[`$&#123;subscribeType&#125;Observers`])&#123;</span><br><span class="line">            this[`$&#123;subscribeType&#125;Observers`] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        this[`$&#123;subscribeType&#125;Observers`].push(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    notifyAllObservers() &#123;</span><br><span class="line">        const observers = this[`$&#123;this.deliveryType&#125;Observers`];</span><br><span class="line">        observers.forEach(observer =&gt; &#123;</span><br><span class="line">            observer.callback(this[`$&#123;this.deliveryType&#125;State`], this, observer)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 观察者，等待被触发</span><br><span class="line">class Observer &#123;</span><br><span class="line">    constructor(phoneNum, subscribeType ,company, callback) &#123;</span><br><span class="line">        this.phoneNum = phoneNum</span><br><span class="line">        this.subscribeType = subscribeType</span><br><span class="line">        this.callback = callback</span><br><span class="line">        company.attach(this)//报名，参加订阅，</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let newsCompany = new NewsCompany()</span><br><span class="line">//state, newsCompany, observerMyself 将newsCompany和observerMyself都传给callback，以备不时之需</span><br><span class="line">let o1 = new Observer(&apos;15099281126&apos;, &apos;food&apos;, newsCompany, (state, newsCompany, observerMyself)=&gt;&#123;</span><br><span class="line">    console.log(`15099281126 收到, state新闻: `,state)</span><br><span class="line">&#125;)</span><br><span class="line">let o2 = new Observer(&apos;15099281127&apos;, &apos;food&apos;, newsCompany, (state, newsCompany, observerMyself)=&gt;&#123;</span><br><span class="line">    console.log(`15099281127 收到, state新闻: `,state)</span><br><span class="line">&#125;)</span><br><span class="line">let o3 = new Observer(&apos;15099281128&apos;, &apos;food&apos;, newsCompany, (state, newsCompany, observerMyself)=&gt;&#123;</span><br><span class="line">    console.log(`15099281128 收到, state新闻: `,state)</span><br><span class="line">&#125;)</span><br><span class="line">newsCompany.deliveryState(&apos;奶制食品新闻&apos;,&apos;food&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let o7 = new Observer(&apos;13899761271&apos;, &apos;house&apos;, newsCompany, (state, newsCompany, observerMyself)=&gt;&#123;</span><br><span class="line">    console.log(`13899761271 收到, state新闻: `,state)</span><br><span class="line">&#125;)</span><br><span class="line">let o8 = new Observer(&apos;13899761272&apos;, &apos;house&apos;, newsCompany, (state, newsCompany, observerMyself)=&gt;&#123;</span><br><span class="line">    console.log(`13899761272 收到, state新闻: `,state)</span><br><span class="line">&#125;)</span><br><span class="line">let o9 = new Observer(&apos;13899761273&apos;, &apos;house&apos;, newsCompany, (state, newsCompany, observerMyself)=&gt;&#123;</span><br><span class="line">    console.log(`13899761273 收到, state新闻: `,state)</span><br><span class="line">&#125;)</span><br><span class="line">newsCompany.deliveryState(&apos;房产新闻&apos;,&apos;house&apos;);</span><br></pre></td></tr></table></figure><h4 id="优化及延伸方式二"><a href="#优化及延伸方式二" class="headerlink" title="优化及延伸方式二"></a>优化及延伸方式二</h4><p>对示例代码优化及延伸方式二：<br>你会发现上面的phoneNum其实可有可无，NewsCompany保持跟上面不变，改造其他部分：<br>删除phoneNum,<br>将attach提取出来，<br>删除Observer类，直接用参数来代替，<br>参数因为可能会超过3个改成options对象方式容易扩展</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let newsCompany = new NewsCompany()</span><br><span class="line">//state, newsCompany, observerMyself 将newsCompany和observerMyself都传给callback，以备不时之需</span><br><span class="line">newsCompany.attach(&#123;</span><br><span class="line">    subscribeType : &apos;food&apos;, </span><br><span class="line">    callback: (state, newsCompany, observerMyself)=&gt;&#123;</span><br><span class="line">      console.log(`o1 订阅或观察者 收到, state新闻: `,state)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">newsCompany.attach(&#123;</span><br><span class="line">    subscribeType : &apos;food&apos;, </span><br><span class="line">    callback: (state, newsCompany, observerMyself)=&gt;&#123;</span><br><span class="line">      console.log(`o2 订阅或观察者 收到, state新闻: `,state)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">newsCompany.attach(&#123;</span><br><span class="line">    subscribeType : &apos;food&apos;, </span><br><span class="line">    callback: (state, newsCompany, observerMyself)=&gt;&#123;</span><br><span class="line">      console.log(`o3 订阅或观察者 收到, state新闻: `,state)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">newsCompany.deliveryState(&apos;奶制食品新闻&apos;,&apos;food&apos;);</span><br></pre></td></tr></table></figure><p>此时，你是否可以将attach想象成 addEventListener，deliveryState想象成fire或trigger。</p><h3 id="es5示例"><a href="#es5示例" class="headerlink" title="es5示例"></a>es5示例</h3><p>由于js天生可以很优雅地使用花括号来构造一个对象，而不用通过class实例化，因此我们可很容易通过es5来写一个观察者与订阅模式示例：</p><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">var Event = (function()&#123;</span><br><span class="line">    var ClientList = &#123;&#125;,</span><br><span class="line">    listen,</span><br><span class="line">    trigger,</span><br><span class="line">    remove;</span><br><span class="line">    listen = function(key, fn)&#123;</span><br><span class="line">        if(!ClientList[key])&#123;</span><br><span class="line">            ClientList[key] = []</span><br><span class="line">        &#125;</span><br><span class="line">        ClientList[key].push(fn);</span><br><span class="line">    &#125;</span><br><span class="line">    trigger = function()&#123;</span><br><span class="line">        var key = Array.prototype.shift.call(arguments),</span><br><span class="line">        fns = ClientList[key];</span><br><span class="line">        if(!fns || fns.listen === 0)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        for(var i = 0; i&lt;fns.length; i++)&#123;</span><br><span class="line">            fns[i].apply(this,arguments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    remove = function(key, fn)&#123;</span><br><span class="line">        var fns = ClientList[key];</span><br><span class="line">        if(!fns)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        var fns = ClientList[key];</span><br><span class="line">        if(!fn)&#123;</span><br><span class="line">            fns &amp;&amp; (fns.length = 0);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            for (var l = fns.length -1;l&gt;0;l--)&#123;</span><br><span class="line">                var _fn = fns[l];</span><br><span class="line">                if(_fn === fn)&#123;</span><br><span class="line">                    fns.splice(l,1);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;listen,trigger,remove&#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">Event.listen(&apos;squeremeter88&apos;, function(price)&#123;</span><br><span class="line">    console.log(&apos;价格= &apos;+price);</span><br><span class="line">&#125;)</span><br><span class="line">Event.listen(&apos;squeremeter88&apos;, function(price)&#123;</span><br><span class="line">    console.log(&apos;价格_111= &apos;+price);</span><br><span class="line">&#125;)</span><br><span class="line">Event.trigger(&apos;squeremeter88&apos;, 20000);</span><br></pre></td></tr></table></figure><p>当业务复杂后，可能出现命名污染的现象，这个时候，我们可以改写Event，通过Event.creat(namespace).listen(add),<br>Event.creat(namespace).trigger(add),详细可看 《js设计模式》书</p><h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><p>一个按钮被点击时，出发一个div显示最新的count值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button id=&quot;count&quot;&gt;click&lt;/button&gt;</span><br><span class="line">&lt;div id=&quot;show&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var a = (function()&#123;</span><br><span class="line">    var count = 0;</span><br><span class="line">    var button = document.getElementById(&apos;count&apos;);</span><br><span class="line">    button.onclick = function()&#123;</span><br><span class="line">        //Event 就是上面的Event不变。</span><br><span class="line">        Event.trigger(&apos;add&apos;, count++)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line">var b = (function()&#123;</span><br><span class="line">    var div = document.getElementById(&apos;show&apos;);</span><br><span class="line">    Event.listen(&apos;add&apos;, function(count)&#123;</span><br><span class="line">        div.innerHTML = count</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)()</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>网页事件绑定，promise的一系列then，还有react的生命周期函数其实都是定义callbase，是一种观察者模式</p><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>它定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都将得到通知。<br>它的特征是，</p><ul><li>发布和订阅</li><li>一对多（包含一对一）<br>设计的原则：<br>主题与观察者分离，不是主动触发而是被动监听，两者解耦。</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>上面举例来es6和es5两种方式的观察者模式示例，es6和es5两种方式，各有各的优点，本质上也是一样的，为了便于直观理解观察者模式，可先行记忆es5示例的形式。</p><h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><p>缺点 观察者模式容易隐藏 代码逻辑，过量使用观察者模式，后期后期维护时，可能不好找入口的风险带来一些麻烦。<br>优点 观察者模式可以用来很好地写异步编程，事件驱动编程。</p><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><h3 id="反例"><a href="#反例" class="headerlink" title="反例"></a>反例</h3><p>举例一个常规编程，但这个编程是一个不好的例子–反例，下节会基于此做优化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var Light = function()&#123;</span><br><span class="line">    this.state = &apos;off&apos;</span><br><span class="line">    this.button = null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Light.prototype.init = function()&#123;</span><br><span class="line">    var button = document.createElement(&apos;button&apos;),</span><br><span class="line">    self = this;</span><br><span class="line">    this.button = document.body.appendChild(button);</span><br><span class="line">    this.button.innerHTML = &apos;开关&apos;;</span><br><span class="line">    this.button.onclick = function()&#123;</span><br><span class="line">        self.buttonWasPressed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Light.prototype.buttonWasPressed = function(newState)&#123;</span><br><span class="line">   if(this.state === &apos;off&apos;)&#123;</span><br><span class="line">       console.log(&apos;弱光&apos;);//用console来象征 状态行为</span><br><span class="line">       this.state = &apos;weakLight&apos;;</span><br><span class="line">   &#125;else if(this.state === &apos;weakLight&apos;)&#123;</span><br><span class="line">       console.log(&apos;高光&apos;);</span><br><span class="line">       this.state = &apos;strongLight&apos;;</span><br><span class="line">   &#125;else if(this.state === &apos;strongLight&apos;)&#123;</span><br><span class="line">       console.log(&apos;关灯&apos;);</span><br><span class="line">       this.state = &apos;off&apos;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">var light = new Light();</span><br><span class="line">light.init();</span><br></pre></td></tr></table></figure></p><p>需求来了，如果再增加一个超级强光，那么就要改写buttonWasPressed，违反了开放封闭原则，而且Light.prototype.buttonWasPressed会越来越臃肿，<br>代码中状态行为只有一句console.log(),但实际开发中，肯定不止这一句代码，基于以上两点理由，因为有必要 改写成下一节的示例代码</p><h3 id="标准状态模式示例"><a href="#标准状态模式示例" class="headerlink" title="标准状态模式示例"></a>标准状态模式示例</h3><p>将上节反例demo改造，优化，以下是标准状态模式demo：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">//标准状态模式示例</span><br><span class="line">var LightState = function(nextState, stateCallback)&#123;</span><br><span class="line">    this.stateCallback = stateCallback;</span><br><span class="line">    this.nextState = nextState;</span><br><span class="line">&#125;</span><br><span class="line">LightState.prototype.buttonWasPressed = function()&#123;</span><br><span class="line">    this.stateCallback();//对应的行为</span><br><span class="line">    this.light.setState(this.nextState) //切换状态</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var OffLightState = function(light)&#123;</span><br><span class="line">    this.light = light;</span><br><span class="line">&#125;</span><br><span class="line">OffLightState.prototype = new LightState(&apos;weakLightState&apos;, function()&#123;</span><br><span class="line">    console.log(&apos;弱光&apos;);//自定义对应的行为</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var WeakLightState = function(light)&#123;</span><br><span class="line">    this.light = light;</span><br><span class="line">&#125;</span><br><span class="line">WeakLightState.prototype = new LightState(&apos;strongLightState&apos; ,function()&#123;</span><br><span class="line">    console.log(&apos;强光&apos;);//自定义对应的行为</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var StrongLightState = function(light)&#123;</span><br><span class="line">    this.light = light;</span><br><span class="line">&#125;</span><br><span class="line">StrongLightState.prototype = new LightState(&apos;offLightState&apos; , function()&#123;</span><br><span class="line">    console.log(&apos;关灯&apos;);//自定义对应的行为</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var LightContext = function()&#123;</span><br><span class="line">    this.offLightState = new OffLightState(this)</span><br><span class="line">    this.weakLightState = new WeakLightState(this)</span><br><span class="line">    this.strongLightState = new StrongLightState(this)</span><br><span class="line">    this.button = null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LightContext.prototype.init = function()&#123;</span><br><span class="line">    var button = document.createElement(&apos;button&apos;),</span><br><span class="line">    self = this;</span><br><span class="line">    this.button = document.body.appendChild(button);</span><br><span class="line">    this.button.innerHTML = &apos;开关&apos;;</span><br><span class="line">    this.currState = this.offLightState; //设置开始状态</span><br><span class="line">    this.button.onclick = function()&#123;</span><br><span class="line">        self.currState.buttonWasPressed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">LightContext.prototype.setState = function(newState)&#123;</span><br><span class="line">   this.currState = this[newState]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var light = new LightContext();</span><br><span class="line">light.init();</span><br></pre></td></tr></table></figure></p><p>当增加一个超级强光时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var SuperStrongLightState = function(light)&#123;</span><br><span class="line">    this.light = light;</span><br><span class="line">&#125;</span><br><span class="line">SuperStrongLightState.prototype = new LightState(&apos;offLightState&apos; , function()&#123;</span><br><span class="line">    console.log(&apos;关灯&apos;);//自定义对应的行为</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">StrongLightState.prototype = new LightState(&apos;superStrongLightState&apos; , function()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var LightContext = function()&#123;</span><br><span class="line">...</span><br><span class="line">    this.superStrongLightState = new SuperStrongLightState(this)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="状态模式的优缺点"><a href="#状态模式的优缺点" class="headerlink" title="状态模式的优缺点"></a>状态模式的优缺点</h3><p>以上就是状态模式的魅力，符合开放封闭原则，可以不让buttonWasPressed臃肿，其实就是不让context无限臃肿。<br>缺点 会增加代码量，把逻辑分散到状态类中，无法在一个地方就可以将逻辑不能一目了然。</p><h3 id="设计原则与定义"><a href="#设计原则与定义" class="headerlink" title="设计原则与定义"></a>设计原则与定义</h3><p>状态模式，最重要的特征是定义状态类(如上的LightState)，并将逻辑分散到状态类中。<br>将状态(LightState)与主体(LightContext)分离，状态变化的逻辑单独到每个状态类中(例如OffLightState)处理。</p><p>状态模式的定义较晦涩：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。<br>这个定义基本看不懂，可以忽视掉。<br>状态模式的精髓在于 定义状态类，并状态对应的逻辑封装到状态类中。</p><h3 id="什么情况下使用"><a href="#什么情况下使用" class="headerlink" title="什么情况下使用"></a>什么情况下使用</h3><p>什么情况下使用状态模式，<br>如上面优缺点说的，<br>当你不希望Light.prototype.buttonWasPressed太臃肿时；<br>当每次有新需求你不希望每次都去修改Light.prototype.buttonWasPressed时；<br>当你做的功能业务有太多状态变化，且每个状态逻辑较多时；<br>那么就请使用状态模式吧</p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h3 id="两者代理模式的概念"><a href="#两者代理模式的概念" class="headerlink" title="两者代理模式的概念"></a>两者代理模式的概念</h3><p>js中用得最多的虚拟代理和缓存代理；<br>虚拟代理指通过代理，将一个函数延迟或等到真正需要执行的时候再执行，说白了就是延时下，例如下面例子中，等图片完全加载好后再执行真正的加载。<br>缓存代理，如下例子中，指通过代理，不用每次都执行函数，开始执行完函数后，后期从缓存取，如果我计算或2+3，后面再2+3时，直接从缓存取。<br>代理模式很简单直接通过以下两个例子来领略下代理模式；</p><h3 id="虚拟代理示例"><a href="#虚拟代理示例" class="headerlink" title="虚拟代理示例"></a>虚拟代理示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var myImage = (function()&#123;</span><br><span class="line">    var imgNode = document.createElement(&apos;img&apos;);</span><br><span class="line">    document.body.appendChild(imgNode);</span><br><span class="line">    return &#123;</span><br><span class="line">        setSrc: function(src)&#123;</span><br><span class="line">            imgNode.src = src;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">var proxyImage = (function()&#123;</span><br><span class="line">    var img = new Image;</span><br><span class="line">    img.onload = function()&#123;</span><br><span class="line">        myImage.setSrc(this.src)</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">        setSrc:function(src)&#123;</span><br><span class="line">            myImage.setSrc(&apos;file:// /c:/user/abc.gif&apos;);</span><br><span class="line">            img.src = src;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">//myImage.setSrc(&apos;http://s9.knowsky.com/bizhi/l/20100615/2010112611%20(1).jpg&apos;)</span><br><span class="line">proxyImage.setSrc(&apos;http://s9.knowsky.com/bizhi/l/20100615/2010112611%20(1).jpg&apos;)</span><br></pre></td></tr></table></figure><p>注意一个现象，myImage有一个setSrc接口，proxyImage也有一个setSrc接口，并且代理函数体内用了myImage.setSrc；</p><h3 id="缓存代理示例"><a href="#缓存代理示例" class="headerlink" title="缓存代理示例"></a>缓存代理示例</h3><h4 id="简单版示例"><a href="#简单版示例" class="headerlink" title="简单版示例"></a>简单版示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var mult = function()&#123;</span><br><span class="line">    console.log(&apos;开始计算乘积&apos;);</span><br><span class="line">    var a = 1;</span><br><span class="line">    for (var i =0, l = arguments.length; i&lt;l; i++)&#123;</span><br><span class="line">        a = a*arguments[i]</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var proxyMult = (function()&#123;</span><br><span class="line">    var cache = &#123;&#125;;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        var args = Array.prototype.join.call(arguments, &apos;,&apos;);</span><br><span class="line">        if(args in cache)&#123;</span><br><span class="line">            return cache[args];</span><br><span class="line">        &#125;</span><br><span class="line">        return cache[args] = mult.apply(this, arguments)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line">console.log(proxyMult(1,2,3,4))</span><br><span class="line">console.log(proxyMult(1,2,3,4))</span><br></pre></td></tr></table></figure><h4 id="延伸版示例"><a href="#延伸版示例" class="headerlink" title="延伸版示例"></a>延伸版示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var plus = function()&#123;</span><br><span class="line">    console.log(&apos;开始计算加和&apos;);</span><br><span class="line">    var a = 0;</span><br><span class="line">    for (var i =0, l = arguments.length; i&lt;l; i++)&#123;</span><br><span class="line">        a = a+arguments[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var createProxyFactory = function(fn)&#123;</span><br><span class="line">    var cache = &#123;&#125;;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        var args = Array.prototype.join.call(arguments, &apos;,&apos;);</span><br><span class="line">        if(args in cache)&#123;</span><br><span class="line">            return cache[args];</span><br><span class="line">        &#125;</span><br><span class="line">        return cache[args] = fn.apply(this, arguments)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var proxyMult = createProxyFactory(mult);</span><br><span class="line"></span><br><span class="line">console.log(proxyMult(11,2,3,4))</span><br><span class="line">console.log(proxyMult(11,2,3,4))</span><br></pre></td></tr></table></figure><p>注意一个现象，proxyMult代理函数体内用了fn.apply,且mult与proxyMult接收的参数是一致的，可以认为二者接口一致。</p><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>从上面的示例我们可以看到，<br>设计一个代理模式，有一个小技巧：</p><ul><li>就是代理函数 要 提供跟被代理函数一摸一样的接口，或者有一摸一样的接收传参方式；</li><li>代理函数体内 引用 被代理函数。</li></ul><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>策略模式的思想：<br>定义一系列的算法，把他们一个个封装起来，并且使他们可以相互替换。<br>最代表性和关键的操作是将每种算法单独封装成类，或者函数。</p><h3 id="经典示例一"><a href="#经典示例一" class="headerlink" title="经典示例一"></a>经典示例一</h3><p>下面看一个策略模式最代表的例子：</p><h4 id="反例-1"><a href="#反例-1" class="headerlink" title="反例"></a>反例</h4><p>计算绩效奖金，最开始的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 这是反例</span><br><span class="line">var calculateBonus = function(performanceLevel, salary)&#123;</span><br><span class="line">    if(performanceLevel === &apos;S&apos;)&#123;</span><br><span class="line">        return salary*4;</span><br><span class="line">    &#125;</span><br><span class="line">    if(performanceLevel === &apos;A&apos;)&#123;</span><br><span class="line">        return salary*3;</span><br><span class="line">    &#125;</span><br><span class="line">    if(performanceLevel === &apos;B&apos;)&#123;</span><br><span class="line">        return salary*2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">calculateBonus(&apos;B&apos;, 20000);</span><br><span class="line">calculateBonus(&apos;S&apos;, 6000);</span><br></pre></td></tr></table></figure></p><p>上面写法致命缺点在于，将来如果有更多的绩效等级，例如C、D、E、F…时，都需要在calculateBonus中增加代码逻辑；<br>改进上面代码的关键，在于精简calculateBonus。</p><h4 id="标准示例"><a href="#标准示例" class="headerlink" title="标准示例"></a>标准示例</h4><p>改进如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//标准策略模式示例</span><br><span class="line">var S = function(salary)&#123;</span><br><span class="line">    return salary*4;</span><br><span class="line">&#125;</span><br><span class="line">var A = function(salary)&#123;</span><br><span class="line">    return salary*3;</span><br><span class="line">&#125;</span><br><span class="line">var B = function(salary)&#123;</span><br><span class="line">    return salary*2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var calculateBonus = function(func, salary)&#123;</span><br><span class="line">    return func(salary);</span><br><span class="line">&#125;</span><br><span class="line">calculateBonus(B, 20000);</span><br><span class="line">calculateBonus(S, 6000);</span><br></pre></td></tr></table></figure></p><p>改进后，将每个等级的逻辑封装成单独的类或函数，<br>无论未来增加多少绩效逻辑，都将单独定义绩效逻辑类，不会影响现有类，同时calculateBonus都不变。<br>改进用到的策略模式技巧：</p><ul><li>将算法类直接以算法名字命名</li></ul><h3 id="经典示例二"><a href="#经典示例二" class="headerlink" title="经典示例二"></a>经典示例二</h3><p>如果只需了解 策略模式，只需看以上内容即可，这部分内容只是再举例加深理解。</p><p>下面再看一个经典测试模式示例</p><h4 id="反例-2"><a href="#反例-2" class="headerlink" title="反例"></a>反例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//这是反例</span><br><span class="line">&lt;form action=&quot;#&quot; id=&quot;registerForm&quot; method=&quot;POST&quot;&gt;</span><br><span class="line">    请输入用户名：&lt;input type=&quot;text&quot; name=&quot;userName&quot;/&gt;</span><br><span class="line">    请输入密码：&lt;input type=&quot;text&quot; name=&quot;passWord&quot; /&gt;</span><br><span class="line">    请输入手机号码：&lt;input type=&quot;text&quot; name=&quot;phoneNumber&quot; /&gt;</span><br><span class="line">    &lt;button&gt;提交&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">var registerForm = document.getElementById(&apos;registerForm&apos;);</span><br><span class="line">registerForm.onsubmit = function()&#123;</span><br><span class="line">    if(registerForm.userName.value === &apos;&apos;)&#123;</span><br><span class="line">        alert(&apos;用户名不能为空&apos;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if(registerForm.userName.length &lt; 6)&#123;</span><br><span class="line">        alert(&apos;用户名不能少于6位&apos;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if(registerForm.password.length &lt; 6)&#123;</span><br><span class="line">        alert(&apos;密码不能少于6位&apos;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="标准示例-1"><a href="#标准示例-1" class="headerlink" title="标准示例"></a>标准示例</h4><p>对以上示例进行改进：</p><ul><li>将每种验证方法 封装成单独的类或函数，如strategies.isNonEmpty;</li><li>Validator可以看作是本节的第一个标准示例中的calculateBonus，<br>validataForm可以看作是calculateBonus(B, 20000);</li><li>将验证Validator分两步逻辑，一步是逐条添加规则，一步是一次性验证所有规则<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">//将一系列 规则算法 封装成单独的函数</span><br><span class="line">var strategies = &#123;</span><br><span class="line">    isNonEmpty: function(value, errorMsg)&#123;</span><br><span class="line">        if(!value)&#123;</span><br><span class="line">            return errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    minLength: function(value, length, errorMsg)&#123;</span><br><span class="line">        if(value.length&lt;length)&#123;</span><br><span class="line">            return errorMsg</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    isMobile: function(value, errorMsg)&#123;</span><br><span class="line">        if(!/13511112222/.test(value))&#123;</span><br><span class="line">            return errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var Validator = function()&#123;</span><br><span class="line">    this.cache = [];</span><br><span class="line">&#125;</span><br><span class="line">//设计 添加 和 验证 规则的逻辑</span><br><span class="line">Validator.prototype.add = function(dom, rules)&#123;</span><br><span class="line">    var self = this;</span><br><span class="line">    for (var i = 0,rule; rule = rules[i++];)&#123;</span><br><span class="line">        (function(rule)&#123;</span><br><span class="line">            var strategyAry = rule.strategy.split(&apos;:&apos;);</span><br><span class="line">            var errorMsg = rule.errorMsg;</span><br><span class="line">            self.cache.push(function()&#123;</span><br><span class="line">                var strategy = strategyAry.shift();</span><br><span class="line">                strategyAry.unshift(dom.value);</span><br><span class="line">                strategyAry.push(errorMsg);</span><br><span class="line">                return strategies[strategy].apply(dom, strategyAry);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)(rule)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Validator.prototype.start = function()&#123;</span><br><span class="line">    for(var i= 0,validatorFunc; validatorFunc = this.cache[i++];)&#123;</span><br><span class="line">        var errorMsg = validatorFunc();</span><br><span class="line">        if(errorMsg)&#123;</span><br><span class="line">            return errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//为表单实际添加规则 和 验证</span><br><span class="line">var registerForm = document.getElementById(&apos;registerForm&apos;);</span><br><span class="line">var validataForm = function()&#123;</span><br><span class="line">    var validator = new Validator();</span><br><span class="line">    validator.add(registerForm.userName,[&#123;</span><br><span class="line">        strategy: &apos;isNonEmpty&apos;,</span><br><span class="line">        errorMsg: &apos;不能为空&apos;</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        strategy: &apos;minLength:10&apos;,</span><br><span class="line">        errorMsg: &apos;长度不能小于10&apos;</span><br><span class="line">    &#125;])</span><br><span class="line">    validator.add(registerForm.passWord,[&#123;</span><br><span class="line">        strategy: &apos;isNonEmpty&apos;,</span><br><span class="line">        errorMsg: &apos;不能为空&apos;</span><br><span class="line">    &#125;])</span><br><span class="line"></span><br><span class="line">    var errorMsg = validator.start();</span><br><span class="line">    return errorMsg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">registerForm.onsubmit = function()&#123;</span><br><span class="line">    var errorMsg = validataForm();</span><br><span class="line">    if(errorMsg)&#123;</span><br><span class="line">        alert(errorMsg);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>改进后，这种模式很好的适应了大型项目规则验证。</p><h3 id="编写策略模式技巧"><a href="#编写策略模式技巧" class="headerlink" title="编写策略模式技巧"></a>编写策略模式技巧</h3><ul><li>将策略算法 封装成单独函数或类；</li><li>直接以算法名称 命名 函数和类，如上面经典示例一</li></ul><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>主要讲解es5装饰者模式的其中的两种实现方式：一个是定义类(构造函数)的方式，一个是修改超级函数Function原型的方式。<br>下面对这两种方式分别讲解：</p><h3 id="构造函数方式"><a href="#构造函数方式" class="headerlink" title="构造函数方式"></a>构造函数方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var Plan = function()&#123;&#125;</span><br><span class="line">Plan.prototype.fire = function()&#123;</span><br><span class="line">    console.log(&apos;发射普通子弹&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var MissleDecorator = function(plan)&#123;</span><br><span class="line">    this.plan = plan;</span><br><span class="line">&#125;</span><br><span class="line">MissleDecorator.prototype.fire = function()&#123;</span><br><span class="line">    this.plan.fire();</span><br><span class="line">    console.log(&apos;发射导弹&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var AtomDecorator = function(plan)&#123;</span><br><span class="line">    this.plan = plan;</span><br><span class="line">&#125;</span><br><span class="line">AtomDecorator.prototype.fire = function()&#123;</span><br><span class="line">    this.plan.fire();</span><br><span class="line">    console.log(&apos;发射原子弹&apos;);</span><br><span class="line">&#125;</span><br><span class="line">var plan = new Plan();</span><br><span class="line">plan = new MissleDecorator(plan);</span><br><span class="line">plan = new AtomDecorator(plan);</span><br><span class="line">plan.fire();</span><br></pre></td></tr></table></figure><h3 id="Function原型方式"><a href="#Function原型方式" class="headerlink" title="Function原型方式"></a>Function原型方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.before = function(beforefn)&#123;</span><br><span class="line">        var _self = this;//保存原函数的引用</span><br><span class="line">        return function()&#123;//返回包含类原函数和新函数的代理函数</span><br><span class="line">            beforefn.apply(this,arguments);//执行新函数，且保证this不被劫持，新函数接受的参数</span><br><span class="line">            return _self.apply(this, arguments);//执行原函数，并且返回原函数的执行结果，并且保持this不被劫持</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Function.prototype.after = function(afterfn)&#123;</span><br><span class="line">        var _self = this;</span><br><span class="line">        return function()&#123;</span><br><span class="line">            var ret = _self.apply(this,arguments);</span><br><span class="line">            afterfn.apply(this,arguments);</span><br><span class="line">            return ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var func = function(param)&#123;</span><br><span class="line">        console.log(param);</span><br><span class="line">    &#125;</span><br><span class="line">    func = func.before(function(param)&#123;</span><br><span class="line">        param.b = &apos;b&apos;;</span><br><span class="line">    &#125;)</span><br><span class="line">    func(&#123;a:&apos;a&apos;&#125;);//&#123;a:&apos;a&apos;, b:&apos;b&apos;&#125;</span><br></pre></td></tr></table></figure><h3 id="es6中的修饰器（Decorator）"><a href="#es6中的修饰器（Decorator）" class="headerlink" title="es6中的修饰器（Decorator）"></a>es6中的修饰器（Decorator）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@testable</span><br><span class="line">class MyTestableClass &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">function testable(target) &#123;</span><br><span class="line">  target.isTestable = true;</span><br><span class="line">&#125;</span><br><span class="line">MyTestableClass.isTestable // true</span><br></pre></td></tr></table></figure><p>注意，修饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，修饰器能在编译阶段运行代码。也就是说，修饰器本质就是编译时执行的函数。</p><h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><p>装饰者，经常用到的小技巧，不改变原函数情况下，增加函数功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = function()&#123;</span><br><span class="line">        alert(1)</span><br><span class="line">    &#125;</span><br><span class="line">    var _a = a;</span><br><span class="line">    a = function()&#123;</span><br><span class="line">        _a();</span><br><span class="line">        alert(2);</span><br><span class="line">    &#125;</span><br><span class="line">    a();</span><br></pre></td></tr></table></figure></p><p>在开发中，我们常用这种方式，实现页面回退，加载等等事件时，增加功能。</p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js设计模式 </tag>
            
            <tag> 单例模式 </tag>
            
            <tag> 观察者模式 </tag>
            
            <tag> 状态模式 </tag>
            
            <tag> 单一职责原则 </tag>
            
            <tag> 开放封闭原则 </tag>
            
            <tag> 舍弃高效率而取可移植性 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
