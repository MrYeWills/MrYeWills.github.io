<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>webpack笔记</title>
      <link href="/2018/12/15/webpack/"/>
      <url>/2018/12/15/webpack/</url>
      
        <content type="html"><![CDATA[<h2 id="webpack常用知识"><a href="#webpack常用知识" class="headerlink" title="webpack常用知识"></a>webpack常用知识</h2><h3 id="sourcemap的处理"><a href="#sourcemap的处理" class="headerlink" title="sourcemap的处理"></a>sourcemap的处理</h3><h4 id="css模块-sourcemap的处理"><a href="#css模块-sourcemap的处理" class="headerlink" title="css模块 sourcemap的处理"></a>css模块 sourcemap的处理</h4><p>给一下loader加上sourceMap: true，就可以做到css的sourcemap调试。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: /\.(sc|c|sa)ss$/,</span><br><span class="line">        use: [</span><br><span class="line">          &apos;style-loader&apos;, &#123;</span><br><span class="line">            loader: &apos;css-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;postcss-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              ident: &apos;postcss&apos;,</span><br><span class="line">              sourceMap: true,</span><br><span class="line">              plugins: (loader) =&gt; [require(&apos;autoprefixer&apos;)(&#123;browsers: [&apos;&gt; 0.15% in CN&apos;]&#125;)]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;sass-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><h4 id="js模块-sourcemap的处理"><a href="#js模块-sourcemap的处理" class="headerlink" title="js模块 sourcemap的处理"></a>js模块 sourcemap的处理</h4><p>很简单，加一个这个配置即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devtool: &apos;inline-source-map&apos;, // 开发阶段开启 sourcemap</span><br></pre></td></tr></table></figure></p><h3 id="给css加前缀-postcss-loader"><a href="#给css加前缀-postcss-loader" class="headerlink" title="给css加前缀  postcss-loader"></a>给css加前缀  postcss-loader</h3><p><a href="https://www.webpackjs.com/loaders/postcss-loader/#options" target="_blank" rel="noopener">postcss-loader</a>有很多用处，其中之一就是给各个浏览器添加css3兼容样式。</p><p>安装 postcss-loader 和 autoprefixer。 使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: /\.(sc|c|sa)ss$/,</span><br><span class="line">        use: [</span><br><span class="line">          &apos;style-loader&apos;, &#123;</span><br><span class="line">            loader: &apos;css-loader&apos;,</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;postcss-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              ident: &apos;postcss&apos;,//这里一定要定义一个唯一的名字，一般喜欢定义为postcss，你也可以定义任意其他唯一名字</span><br><span class="line">              //&gt; 0.15% in CN 大致是指兼容什么范围内的浏览器，这样写就行，一定要设置，否则可能不加前缀，</span><br><span class="line">              //且数值一定要设置合适，否则设置浏览器太新，也可能不会生成前缀</span><br><span class="line">              plugins: (loader) =&gt; [require(&apos;autoprefixer&apos;)(&#123;browsers: [&apos;&gt; 0.15% in CN&apos;]&#125;)]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;sass-loader&apos;,</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><h3 id="抽离css样式文件"><a href="#抽离css样式文件" class="headerlink" title="抽离css样式文件"></a>抽离css样式文件</h3><p>注意：1.webpack4开始使用mini-css-extract-plugin ，1-3版本可以用 extract-text-webpack-plugin。<br>     2.只有 mode: ‘production’ 插件才生效。<br>     3.开发阶段使用style-loader就行了<br>方法：<br>1.mode: ‘production’<br>2.抽离只需将原先style-loader的对象换成mini-css-extract-plugin；<br>3.配置plugins；</p><p>配置代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">const MiniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;);</span><br><span class="line">...</span><br><span class="line">mode: &apos;production&apos;,</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">        test: /\.(sc|c|sa)ss$/,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader, &#123;</span><br><span class="line">            loader: &apos;css-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;postcss-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              ident: &apos;postcss&apos;,</span><br><span class="line">              sourceMap: true,</span><br><span class="line">              plugins: (loader) =&gt; [require(&apos;autoprefixer&apos;)(&#123;browsers: [&apos;&gt; 0.15% in CN&apos;]&#125;)]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;sass-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line"> ....</span><br><span class="line"> plugins: [</span><br><span class="line">   new MiniCssExtractPlugin(&#123;</span><br><span class="line">     filename: &apos;[name][hash].css&apos;, // 设置最终输出的文件名，这个name最终根据output.filename一致。</span><br><span class="line">     chunkFilename: &apos;[id][hash].css&apos;</span><br><span class="line">   &#125;)</span><br><span class="line"> ],</span><br></pre></td></tr></table></figure><p>以下是css未从html上抽离的原先配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: /\.(sc|c|sa)ss$/,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &apos;style-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,&#123;</span><br><span class="line">            loader: &apos;css-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &apos;postcss-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              ident: &apos;postcss&apos;,</span><br><span class="line">              sourceMap: true,</span><br><span class="line">              plugins: (loader) =&gt; [require(&apos;autoprefixer&apos;)(&#123;browsers: [&apos;&gt; 0.15% in CN&apos;]&#125;)]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;sass-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="压缩css"><a href="#压缩css" class="headerlink" title="压缩css"></a>压缩css</h3><p>所谓压缩代码，就是把css压缩成紧凑的一行。<br>注意：1.webpack5内置压缩 ，4版本可以设置插件optimize-css-assets-webpack-plugin即可。<br>     2.只有 mode: ‘production’ 。<br>配置代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const OptimizeCSSAssetsPlugin = require(&apos;optimize-css-assets-webpack-plugin&apos;);</span><br><span class="line">...</span><br><span class="line">mode: &apos;production&apos;</span><br><span class="line">...</span><br><span class="line">optimization: &#123;</span><br><span class="line">    minimizer: [</span><br><span class="line">      new OptimizeCSSAssetsPlugin(&#123;&#125;), // 压缩CSS插件</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="解决css文件或者js文件名字哈希值变化的问题"><a href="#解决css文件或者js文件名字哈希值变化的问题" class="headerlink" title="解决css文件或者js文件名字哈希值变化的问题"></a>解决css文件或者js文件名字哈希值变化的问题</h3><p>html-webpack-plugin插件，可以把打包后的css或js文件引用直接注入到HTML模板中，这样就不用每次手动修改文件引用了。<br>因此，只要项目中使用了hash，就必须配套使用html-webpack-plugin。<br>另外如果要使用模板html，也必须配套使用html-webpack-plugin。<br>当然，你也可以不使用模板，就算有哈希值，你不怕麻烦，当然也可以不适用html-webpack-plugin,你自己手写html，然后将打包生成的js\css文件手动引用也是可以的。<br>配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">new HtmlWebpackPlugin(&#123;</span><br><span class="line">  title: &apos;AICODER test&apos;, // 默认值：Webpack App</span><br><span class="line">  filename: &apos;index.html&apos;, // 默认值： &apos;index.html&apos;</span><br><span class="line">  template: path.resolve(__dirname, &apos;src/main.html&apos;),</span><br><span class="line">  minify: &#123;</span><br><span class="line">    collapseWhitespace: true, // 折叠空白</span><br><span class="line">    removeComments: true, // 是否移除注释</span><br><span class="line">    removeAttributeQuotes: true // 移除属性的引号</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="每次打包自动清除上一个dist目录"><a href="#每次打包自动清除上一个dist目录" class="headerlink" title="每次打包自动清除上一个dist目录"></a>每次打包自动清除上一个dist目录</h3><p>使用插件：clean-webpack-plugin，配置如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;);</span><br><span class="line">plugins: [</span><br><span class="line">    new CleanWebpackPlugin([&apos;dist&apos;])</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="压缩图片"><a href="#压缩图片" class="headerlink" title="压缩图片"></a>压缩图片</h3><p>使用loader：image-webpack-loader，一定在url-loader之前执行image-webpack-loader。<br>image-webpack-loader可以让原来90kb的图片，变成70kb，而不怎么影响质量。<br>配置如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: /\.(png|svg|jpg|gif|jpeg)$/,</span><br><span class="line">        include: [path.resolve(__dirname, &apos;src/&apos;)],</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &apos;url-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: 10000</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;image-webpack-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              mozjpeg: &#123;</span><br><span class="line">                progressive: true,</span><br><span class="line">                quality: 65</span><br><span class="line">              &#125;,</span><br><span class="line">              optipng: &#123;</span><br><span class="line">                enabled: false</span><br><span class="line">              &#125;,</span><br><span class="line">              pngquant: &#123;</span><br><span class="line">                quality: &apos;65-90&apos;,</span><br><span class="line">                speed: 4</span><br><span class="line">              &#125;,</span><br><span class="line">              gifsicle: &#123;</span><br><span class="line">                interlaced: false</span><br><span class="line">              &#125;,</span><br><span class="line">              webp: &#123;</span><br><span class="line">                quality: 75</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><h3 id="file-loader-与-url-loader-异同"><a href="#file-loader-与-url-loader-异同" class="headerlink" title="file-loader 与 url-loader 异同"></a>file-loader 与 url-loader 异同</h3><p>他们都是用来处理项目中图片的。<br>file-loader 有的功能，基本上url-loader都用；<br>而且url-loader还可以将图片进行base64压缩的功能（你可以不使用此功能）；<br>因此，项目中使用url-loader而不适用file-loader。<br>url-loader 配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: /\.(png|svg|jpg|gif|jpeg)$/,</span><br><span class="line">        include: [path.resolve(__dirname, &apos;src/&apos;)],</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &apos;url-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: 10000 //1kb以内的图片将被base64压缩</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><p>url-loader将图片进行base64压缩后就是一串DataURL：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    background: url(data:image/png;base64,UklGRkYwAABXRUJQVlA4WAoAAAAQAAAA/QIA8AAAQUxQSMAcAAABb…KnjLJNbGNAMFRe2WQhUfMAAAA19AAAkbAAAAAAAAAAAAAAABrYAAAAAD0gAAAAAAAAAAAAAAAA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在基本上常用的浏览器和移动端都可很好兼容DataURL，所以可以放心使用。<br>base64压缩图片为一串DataURL的好处在于减少html页面的http请求。缺点在于会加大打包文件大小。<br>一般网页性能优化时：<br>对于小图片，会使用base64压缩，减少http请求；<br>对于大图片，还是使用http请求。</p><h3 id="字体文件处理"><a href="#字体文件处理" class="headerlink" title="字体文件处理"></a>字体文件处理</h3><p>字体文件处理同图片文件处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: /\.(woff|woff2|eot|ttf|otf)$/,</span><br><span class="line">    include: [path.resolve(__dirname, &apos;src/&apos;)],</span><br><span class="line">    use: [</span><br><span class="line">      &#123;</span><br><span class="line">        loader: &apos;file-loader&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="代理proxy的几张图片"><a href="#代理proxy的几张图片" class="headerlink" title="代理proxy的几张图片"></a>代理proxy的几张图片</h3><p>备用，以后再分析<br><figure class="image-box">                <img src="/image/webpack/proxy1.jpg" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/proxy2.jpg" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/proxy3.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="外部扩展-externals"><a href="#外部扩展-externals" class="headerlink" title="外部扩展(externals)"></a>外部扩展(externals)</h3><p> 把一个模块做成外部依赖也就是用cdn的方式依赖，不会打包到 js文件中。<br> 例如lodash,jquery基本上每个页面都要用到，这个时候把它们放在index.html模板中，<br> 每个组件都可以通过externals定义的名称进行引用。<br> 从而可以减少打包后js的大小。<br> 配置如下：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//index.html模板中</span><br><span class="line">&lt;script</span><br><span class="line">  src=&quot;https://code.jquery.com/jquery-3.1.0.js&quot;</span><br><span class="line">  integrity=&quot;sha256-slogkvB1K3VOkzAI8QITxV3VzpOnkeNVsKvtkYLMjfk=&quot;</span><br><span class="line">  crossorigin=&quot;anonymous&quot;&gt;</span><br><span class="line"></span><br><span class="line">  //webpack.config.js</span><br><span class="line">   externals: &#123;  // 把一个模块做成外部依赖，不会打包到 js文件中。</span><br><span class="line">      jquery: &apos;jQuery&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    //index.js使用jquery</span><br><span class="line">    import $ from &apos;jquery&apos;; //注意是小写</span><br></pre></td></tr></table></figure></p><h3 id="webpack-bundle-analyzer统计分析"><a href="#webpack-bundle-analyzer统计分析" class="headerlink" title="webpack-bundle-analyzer统计分析"></a>webpack-bundle-analyzer统计分析</h3><p>注意，这个是在开发环境下使用,配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const BundleAnalyzerPlugin = require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin;</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">   new BundleAnalyzerPlugin(), // 打包模块报表</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure></p><p>配置好后，执行npm start ，会自动在浏览器打开分析页面：<br><figure class="image-box">                <img src="/image/webpack/analyzer.png" alt="" title="" class="">                <p></p>            </figure><br>由图看出，loadsh.js的体积最大，经过分析，可以将loadsh.js做成外部依赖，从而减少打包后js的体积。</p><h3 id="分离-库与业务代码"><a href="#分离-库与业务代码" class="headerlink" title="分离 库与业务代码"></a>分离 库与业务代码</h3><h4 id="配置方法一"><a href="#配置方法一" class="headerlink" title="配置方法一"></a>配置方法一</h4><p>配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">   filename: &apos;[name].[hash].js&apos;, //定义库代码以外的代码打包成的js appIndex.54c949dd739536531ad5.js</span><br><span class="line">   chunkFilename: &apos;[name].chunk.js&apos;,//定义库代码打包成的js customChunkNameQQ.chunk.js</span><br><span class="line">   path: path.resolve(__dirname, &apos;dist&apos;) //打包后输出的路径</span><br><span class="line"> &#125;,</span><br><span class="line">optimization: &#123;</span><br><span class="line">   splitChunks: &#123;</span><br><span class="line">           cacheGroups: &#123;</span><br><span class="line">             commons: &#123;</span><br><span class="line">                chunks: &apos;initial&apos;,</span><br><span class="line">                test: path.resolve(__dirname,&apos;node_modules&apos;),//匹配到的文件都将被一起打包成库js</span><br><span class="line">                enforce: true,</span><br><span class="line">                name: &apos;customChunkNameQQ&apos;,//定义打包后[name]值</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure></p><p>库与业务代码分离 使用的是splitChunks配置，其实它是一个插件，被整合到webpack4了。<br>这个插件的思路是，利用test匹配文件，只要匹配到的就打包成库js，剩下没有被匹配到的，就被打包成业务js；<br>所以如果test匹配不到任何文件，将不会有库js生成，所有的js资源都会被剩下，都被打包到业务js中。</p><p>以下就是一个例子，只有业务js生成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">   appIndex:&apos;./src/index.js&apos;</span><br><span class="line"> &#125;,</span><br><span class="line"> optimization: &#123;</span><br><span class="line">   splitChunks: &#123;</span><br><span class="line">           cacheGroups: &#123;</span><br><span class="line">             commons: &#123;</span><br><span class="line">                chunks: &apos;initial&apos;,</span><br><span class="line">                test: path.resolve(__dirname,&apos;node_modules11&apos;),//因为项目没有node_modules11目录,将只会有一个业务js生成</span><br><span class="line">                enforce: true,</span><br><span class="line">                name: &apos;customChunkNameQQ&apos;,</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p> <strong>webpack打包的原则就是这样，如果没有插件,所有的js将被webpack系统打包成一个js，如果有插件做代码分离，插件匹配的部分将被插件打包成js，剩下的将被webpack系统打包成一个js，如果插件没有匹配到任何js，,所有的js将被webpack系统打包成一个js</strong></p><p>还有其他几种定义方法：</p><h4 id="显示配置方法-推荐"><a href="#显示配置方法-推荐" class="headerlink" title="显示配置方法(推荐)"></a>显示配置方法(推荐)</h4><p>注意下面这个示例配置有一点点问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//将&apos;lodash&apos;,&apos;axios&apos;两个库的代码合并打包成一个名字为customChunkNameQQ 的 js，文件；</span><br><span class="line">//剩下所有js包含其他依赖库和业务js将被合并打包成另个一个js。</span><br><span class="line"> entry: &#123;</span><br><span class="line">    appIndex:&apos;./src/index.js&apos;,</span><br><span class="line">    lodashAndAxios:[&apos;lodash&apos;,&apos;axios&apos;],//显示定义需要将这些依赖库打成一个js</span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">              commons: &#123;</span><br><span class="line">                 chunks: &apos;initial&apos;,</span><br><span class="line">                 test: &apos;lodashAndAxios&apos;, //一定要匹配entry对象内，key值，lodashAndAxios就是entry中的key值</span><br><span class="line">                 enforce: true,</span><br><span class="line">                 name: &apos;customChunkNameQQ&apos;,</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>上面配置有些问题，打包后，会生成三个js：<br><figure class="image-box">                <img src="/image/webpack/verder2.png" alt="" title="" class="">                <p></p>            </figure><br>所以修改以上配置，将cacheGroups.commons.name与cacheGroups.commons.test统一定义成entry中的lodashAndAxios这样生成的文件就正常了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 正确配置方法 --&gt;</span><br><span class="line"> entry: &#123;</span><br><span class="line">    appIndex:&apos;./src/index.js&apos;,</span><br><span class="line">    lodashAndAxios:[&apos;lodash&apos;,&apos;axios&apos;],//显示定义需要将这些依赖库打成一个js</span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">              commons: &#123;</span><br><span class="line">                 chunks: &apos;initial&apos;,</span><br><span class="line">                 test: &apos;lodashAndAxios&apos;, //一定要匹配entry对象内，key值，lodashAndAxios就是entry中的key值</span><br><span class="line">                 enforce: true,</span><br><span class="line">                 name: &apos;lodashAndAxios&apos;,</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>打包结果为：<br><figure class="image-box">                <img src="/image/webpack/verder2.png" alt="" title="" class="">                <p></p>            </figure></p><h4 id="直接用test匹配方法"><a href="#直接用test匹配方法" class="headerlink" title="直接用test匹配方法"></a>直接用test匹配方法</h4><p>上面的方法也可以写成如下，效果一样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//将&apos;lodash&apos;,&apos;axios&apos;两个库的代码合并打包成一个名字为customChunkNameQQ 的 js，文件；</span><br><span class="line">//剩下所有js包含其他依赖库和业务js将被合并打包成另个一个js。</span><br><span class="line"> entry: &#123;</span><br><span class="line">    appIndex:&apos;./src/index.js&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">              commons: &#123;</span><br><span class="line">                 chunks: &apos;initial&apos;,</span><br><span class="line">                 test: /lodash|axios/,  //直接使用test去匹配</span><br><span class="line">                 enforce: true,</span><br><span class="line">                 name: &apos;customChunkNameQQ&apos;,</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><h3 id="entry多种配置形式"><a href="#entry多种配置形式" class="headerlink" title="entry多种配置形式"></a>entry多种配置形式</h3><p>入口可以使用 entry 字段来进行配置，webpack 支持配置多个入口来进行构建：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &apos;./src/index.js&apos; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 上述配置等同于</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: &apos;./src/index.js&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 或者配置多个入口</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    foo: &apos;./src/page-foo.js&apos;,</span><br><span class="line">    bar: &apos;./src/page-bar.js&apos;, </span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用数组来对多个文件进行打包</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: [</span><br><span class="line">      &apos;./src/foo.js&apos;,</span><br><span class="line">      &apos;./src/bar.js&apos;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后的例子，可以理解为多个文件作为一个入口，webpack 会解析两个文件的依赖后进行打包。</p><p>还有一种形式，就是使用库与业务代码分离optimization.splitChunks时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//将&apos;lodash&apos;,&apos;axios&apos;两个库的代码合并打包成一个名字为customChunkNameQQ 的 js，文件；</span><br><span class="line">//剩下所有js包含其他依赖库和业务js将被合并打包成另个一个js。</span><br><span class="line"> entry: &#123;</span><br><span class="line">    appIndex:&apos;./src/index.js&apos;,</span><br><span class="line">    lodashAndAxios:[&apos;lodash&apos;,&apos;axios&apos;],//显示定义需要将这些依赖库打成一个js</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">  filename: &apos;[name].[hash].js&apos;,//库js剩下的，也就是所谓的业务js</span><br><span class="line">  chunkFilename: &apos;[name].chunk.js&apos;, //打包出来的库js</span><br><span class="line">  path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">&#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        commons: &#123;</span><br><span class="line">           chunks: &apos;initial&apos;,</span><br><span class="line">           test: &apos;lodashAndAxios&apos;,</span><br><span class="line">           enforce: true,</span><br><span class="line">           name: &apos;lodashAndAxios&apos;,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p><strong>entry 值可以是字符串，可以是对象；当entry为对象时，对象元素的key，value；value可以是字符串，也可以是数组。</strong></p><h3 id="生产与开发环境差异配置"><a href="#生产与开发环境差异配置" class="headerlink" title="生产与开发环境差异配置"></a>生产与开发环境差异配置</h3><p>前面提及的使用环境变量的方式可以让我们在不同的构建环境中完成不同的构建需求，这里列举一下常见的 webpack 构建差异配置：</p><ul><li>生产环境可能需要分离 CSS 成单独的文件，以便多个页面共享同一个 CSS 文件</li><li>生产环境需要压缩 HTML/CSS/JS 代码</li><li>生产环境需要压缩图片</li><li>开发环境需要生成 sourcemap 文件</li><li>开发环境需要打印 debug 信息</li><li>开发环境需要 live reload 或者 hot reload 的功能</li></ul><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ul><li>Entry: 入口。</li><li>Module: 模块。在webpack里，一切皆模块，一个模块对应一个文件，webpack会从配置的entry开始递归找出所有依赖的模块。</li><li>Chunk: 代码块。一个Chunk由多个模块组合而成，用于代码合并和分割。             </li><li>loader: 模块转换器。</li><li>Plugin: 扩展插件。</li><li>Output: 输出结果。<br>webpack 在启动后会从Entry里配置的Moule开始，递归解析Entry依赖的所有module，每找到一个module，就会根据配置的loader去找出对应的转换规则，对module进行转换后，再解析出当前module依赖的module。这些模块会以entry为单位进行分组，一个entry及其所有依赖的module被分到一个组也就是一个chunk，最后webpack会将所有chunk转换成文件输出。<br><strong>在webpack中chunk概念很重要，也很不好理解，也容易被忽视，其实webpack目的是一个打包工具，然而将整个包打成几个代码块，都是由chunk控制，所以理解chunk对理解webpack，至关重要。</strong></li></ul><h2 id="webpack-黑知识"><a href="#webpack-黑知识" class="headerlink" title="webpack 黑知识"></a>webpack 黑知识</h2><h3 id="合并两个webpack的js配置"><a href="#合并两个webpack的js配置" class="headerlink" title="合并两个webpack的js配置"></a>合并两个webpack的js配置</h3><p>使用webpack-merge即可，配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//webpack.common</span><br><span class="line">module.exports = &#123;&#125;  //module.exports是node的语法，是commonjs标准</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//webpack.dev.js</span><br><span class="line">const merge = require(&apos;webpack-merge&apos;);</span><br><span class="line">const common = require(&apos;./webpack.common&apos;);</span><br><span class="line">let devConfig = &#123;&#125;</span><br><span class="line">module.exports = merge(common, devConfig);</span><br></pre></td></tr></table></figure><h3 id="–watch-与-热更新"><a href="#–watch-与-热更新" class="headerlink" title="–watch 与 热更新"></a>–watch 与 热更新</h3><p>在命令中加入 –watch，可以达到效果：当文件改动时，会自动编译，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;watch&quot;: &quot;npx webpack --watch --config webpack.dev.js&quot;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>自动编译还是不够的，我们还想它能够编译后自动刷新页面，也就是热更新，最常见的是npm start：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;npm webpack-dev-server --config webpack.dev.js&quot;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>其中devServer.hot置为true，就可以达到热更新。</p><p>所以启动 webpack-dev-server，可以达到自动编译(–watch功能)和热更新功能。</p><h3 id="自动编译与热更新三大条件"><a href="#自动编译与热更新三大条件" class="headerlink" title="自动编译与热更新三大条件"></a>自动编译与热更新三大条件</h3><p>需要同时如下配置，才能进行自动编译与热更新：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const webpack = require(&apos;webpack&apos;);</span><br><span class="line"></span><br><span class="line">devServer: &#123;</span><br><span class="line">   hot: true, // 启用 webpack 的模块热替换特性, 这个需要配合： webpack.HotModuleReplacementPlugin插件</span><br><span class="line"> &#125;,</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  new webpack.NamedModulesPlugin(), // 更容易查看(patch)的依赖</span><br><span class="line">  new webpack.HotModuleReplacementPlugin() // 替换插件</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="webpack-dev-server黑知识"><a href="#webpack-dev-server黑知识" class="headerlink" title="webpack-dev-server黑知识"></a>webpack-dev-server黑知识</h3><p>如下，将看到以下几点黑知识：</p><h4 id="为什么是-0-0-0-0；"><a href="#为什么是-0-0-0-0；" class="headerlink" title="为什么是 0.0.0.0；"></a>为什么是 0.0.0.0；</h4><p>当然，服务器也可以设置为127.0.0.1，这个随你，注意的是设置为0.0.0.0时，可能0.0.0.0:58080有问题，在浏览器上改为127即可正常访问。</p><h4 id="npm-start后自动打开浏览器；"><a href="#npm-start后自动打开浏览器；" class="headerlink" title="npm start后自动打开浏览器；"></a>npm start后自动打开浏览器；</h4><h4 id="编译监听的防抖设置；"><a href="#编译监听的防抖设置；" class="headerlink" title="编译监听的防抖设置；"></a>编译监听的防抖设置；</h4><h4 id="忽略监控文件范围设置；"><a href="#忽略监控文件范围设置；" class="headerlink" title="忽略监控文件范围设置；"></a>忽略监控文件范围设置；</h4><h4 id="proxy的代理重写pathRewrite；"><a href="#proxy的代理重写pathRewrite；" class="headerlink" title="proxy的代理重写pathRewrite；"></a>proxy的代理重写pathRewrite；</h4><h4 id="publicPath的黑知识；"><a href="#publicPath的黑知识；" class="headerlink" title="publicPath的黑知识；"></a>publicPath的黑知识；</h4><figure class="image-box">                <img src="/image/webpack/publicPath.jpg" alt="" title="" class="">                <p></p>            </figure><p>publicPath 的优先级高于 contentBase。contentBase 用于配置提供额外静态文件内容的目录，之前提到的 publicPath 是配置构建好的结果以什么样的路径去访问，而 contentBase 是配置额外的静态文件内容的访问路径，即那些不经过 webpack 构建，但是需要在 webpack-dev-server 中提供访问的静态资源（如部分图片等）<br>你不懂contentBase publicPath为什么，没关系，先这样用着。<br>更多配置说明可参考掘金小册的第六章节。</p><p>webpack-dev-server的配置devServer 完整代码及解释如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    clientLogLevel: &apos;warning&apos;, // 可能的值有 none, error, warning 或者 info（默认值)</span><br><span class="line">    hot: true, // 启用 webpack 的模块热替换特性, 这个需要配合： webpack.HotModuleReplacementPlugin插件</span><br><span class="line">    contentBase: path.join(__dirname, &quot;dist&quot;), // 告诉服务器从哪里提供内容， 默认情况下，将使用当前工作目录作为提供内容的目录</span><br><span class="line">    compress: true, // 一切服务都启用gzip 压缩</span><br><span class="line">    host: &apos;0.0.0.0&apos;, // 指定使用一个 host。默认是 localhost。如果你希望服务器外部可访问 0.0.0.0</span><br><span class="line">    port: 58080, // 端口</span><br><span class="line">    open: true, // 是否打开浏览器</span><br><span class="line">    overlay: &#123; // 出现错误或者警告的时候，是否覆盖页面线上错误消息。</span><br><span class="line">      warnings: true,</span><br><span class="line">      errors: true</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    publicPath: &apos;/&apos;, // 此路径下的打包文件可在浏览器中访问。（注意没有特殊要求，一定就设置为&apos;/&apos;）</span><br><span class="line">    </span><br><span class="line">    proxy: &#123; // 设置代理</span><br><span class="line">      &quot;/api&quot;: &#123; // 访问api开头的请求，会跳转到  下面的target配置</span><br><span class="line">        target: &quot;http://192.168.0.102:8080&quot;,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          &quot;^/api&quot;: &quot;/mockjsdata/5/api&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        //以上配置的意思就是 /api/getuser     =&gt;  http://192.168.0.102:8080//mockjsdata/5/api/getuser</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    quiet: true, // necessary for FriendlyErrorsPlugin. 启用 quiet 后，除了初始启动信息之外的任何内容都不会被打印到控制台。这也意味着来自 webpack 的错误或警告在控制台不可见。</span><br><span class="line">    watchOptions: &#123; // 监视文件相关的控制选项</span><br><span class="line">      poll: true, // webpack 使用文件系统(file system)获取文件改动的通知。在某些情况下，不会正常工作。例如，当使用 Network File System (NFS) 时。Vagrant 也有很多问题。在这些情况下，请使用轮询. poll: true。当然 poll也可以设置成毫秒数，比如：  poll: 1000</span><br><span class="line">      ignored: /node_modules/, // 忽略监控的文件夹，正则</span><br><span class="line">      aggregateTimeout: 300 // 默认值，当第一个文件更改，会在重新构建前增加延迟，防抖的功能，如果你连续几次改的文件间隔小于300毫秒，会延迟编译</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="服务器默认读取index-html"><a href="#服务器默认读取index-html" class="headerlink" title="服务器默认读取index.html"></a>服务器默认读取index.html</h3><p>入口HTML若不是index.html则需补全：<br><figure class="image-box">                <img src="/image/webpack/index.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="resolve之默认扩展文件名"><a href="#resolve之默认扩展文件名" class="headerlink" title="resolve之默认扩展文件名"></a>resolve之默认扩展文件名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">    alias: &#123; // 配置别名</span><br><span class="line">      &apos;@&apos;: path.resolve(__dirname, &apos;src/&apos;)</span><br><span class="line">    &#125;,</span><br><span class="line">    extensions: [&quot;.js&quot;, &quot;.vue&quot;, &quot;.json&quot;] // 默认值: [&quot;.js&quot;,&quot;.json&quot;]  模块名字可以省略的后缀名</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h3 id="name-id-hash-chunkhash"><a href="#name-id-hash-chunkhash" class="headerlink" title="[name][id][hash][chunkhash]"></a>[name][id][hash][chunkhash]</h3><h4 id="name"><a href="#name" class="headerlink" title="[name]"></a>[name]</h4><p>所有的name，默认为entry中定义的，如果entry的值为字符串，则默认为main。<br>如：<br>下面代码是entry为字符串时，[name] 为默认的main<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">entry: &apos;./src/index.js&apos;,</span><br><span class="line"></span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">              commons: &#123;</span><br><span class="line">                 chunks: &apos;initial&apos;,</span><br><span class="line">                 test: path.resolve(__dirname,&apos;node_modules&apos;),</span><br><span class="line">                 enforce: true,</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"> output: &#123;</span><br><span class="line">    filename: &apos;[name].[hash].js&apos;,//main.24673fe716edfcec07a9.js</span><br><span class="line">    chunkFilename: &apos;[name].chunk.js&apos;, //commons~main.chunk.js 这里多了一个commons，是因为splitChunks的commons配置的，默认加commons</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line"> new HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: &apos;AICODER 全栈线下实习&apos;, // 默认值：Webpack App</span><br><span class="line">      filename: &apos;indexMyApp.html&apos;, // 默认值： &apos;index.html&apos;</span><br><span class="line">      template: path.resolve(__dirname, &apos;src/tempHtml.html&apos;),</span><br><span class="line">      minify: &#123;</span><br><span class="line">        collapseWhitespace: true,</span><br><span class="line">        removeComments: true, // 是否移除注释</span><br><span class="line">        removeAttributeQuotes: true // 移除属性的引号</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">  new MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: &apos;[name][hash].css&apos;, // main24673fe716edfcec07a9.css</span><br><span class="line">      chunkFilename: &apos;[id][hash].css&apos;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p><p>下面代码是entry为对象时，[name] 为entry的key值，下面的例子，[name]就是appIndex：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">  appIndex:&apos;./src/index.js&apos;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">              commons: &#123;</span><br><span class="line">                 chunks: &apos;initial&apos;,</span><br><span class="line">                 test: path.resolve(__dirname,&apos;node_modules&apos;),</span><br><span class="line">                 enforce: true,</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"> output: &#123;</span><br><span class="line">    filename: &apos;[name].[hash].js&apos;,//appIndex.90feeea169ea4a86288d.js</span><br><span class="line">    chunkFilename: &apos;[name].chunk.js&apos;, //commons~appIndex.chunk.js</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line"> new HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: &apos;AICODER 全栈线下实习&apos;, // 默认值：Webpack App</span><br><span class="line">      filename: &apos;indexMyApp.html&apos;, // 默认值： &apos;index.html&apos;</span><br><span class="line">      template: path.resolve(__dirname, &apos;src/tempHtml.html&apos;),</span><br><span class="line">      minify: &#123;</span><br><span class="line">        collapseWhitespace: true,</span><br><span class="line">        removeComments: true, // 是否移除注释</span><br><span class="line">        removeAttributeQuotes: true // 移除属性的引号</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">  new MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: &apos;[name][hash].css&apos;, // appIndex90feeea169ea4a86288d.css</span><br><span class="line">      chunkFilename: &apos;[id][hash].css&apos;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p><p>可在插件中自定义对应模块的[name]，例如定义splitChunks模块下name: ‘custom_chunkName’，他会覆盖entry中定义的name，由此splitChunks插件生成的文件将[name]值为custom_chunkName:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">entry: &#123;</span><br><span class="line">  appIndex:&apos;./src/index.js&apos;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">              commons: &#123;</span><br><span class="line">                 chunks: &apos;initial&apos;,</span><br><span class="line">                 test: path.resolve(__dirname,&apos;node_modules&apos;),</span><br><span class="line">                 enforce: true,</span><br><span class="line">                 name: &apos;custom_chunkName&apos;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"> output: &#123;</span><br><span class="line">    filename: &apos;[name].[hash].js&apos;,//appIndex.c81ab09b0bd828f71845.js</span><br><span class="line">    chunkFilename: &apos;[name].chunk.js&apos;, //customChunkNameQQ.chunk.js</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">  new MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: &apos;[name][hash].css&apos;, // appIndexc81ab09b0bd828f71845.css</span><br><span class="line">      chunkFilename: &apos;[id][hash].css&apos;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">//其他跟上面代码一样，只列与上不同的代码：</span><br></pre></td></tr></table></figure><p>当然你也可以直接通过filename定义splitChunks模块下输出文件的名字，这个优先级最高：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">  appIndex:&apos;./src/index.js&apos;</span><br><span class="line">&#125;,</span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">              commons: &#123;</span><br><span class="line">                 chunks: &apos;initial&apos;,</span><br><span class="line">                 test: path.resolve(__dirname,&apos;node_modules&apos;),</span><br><span class="line">                 enforce: true,</span><br><span class="line">                 name: &apos;customChunkNameQQ&apos;,</span><br><span class="line">                 filename: &apos;chunckNiceName.js&apos;,</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"> output: &#123;</span><br><span class="line">    filename: &apos;[name].[hash].js&apos;,//appIndex.c81ab09b0bd828f71845.js</span><br><span class="line">    chunkFilename: &apos;[name].chunk.js&apos;, //chunckNiceName.js</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">  new MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: &apos;[name][hash].css&apos;, // appIndexc81ab09b0bd828f71845.css</span><br><span class="line">      chunkFilename: &apos;[id][hash].css&apos;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">//其他跟上面代码一样，只列与上不同的代码：</span><br></pre></td></tr></table></figure><p>关于[name]小结：<br>如果entry为字符串，name值默认为main；<br>如果entry以对象形式，name值为对象的key值；<br>各个插件(如css、js处理插件)可自定义本插件生成的js的文件名，或自定name值覆盖entry中定义的name值。</p><h4 id="id"><a href="#id" class="headerlink" title="[id]"></a>[id]</h4><p>这个最简单，[id]其实就是数字1,2,3,4…..；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    filename: &apos;[name].[hash].js&apos;,</span><br><span class="line">    chunkFilename: &apos;[id].chunk.js&apos;,</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><h4 id="hash"><a href="#hash" class="headerlink" title="[hash]"></a>[hash]</h4><p>这就是一个hash码，值得注意的是，每次build的hash值都是相同的，也就是打包完成后，js\css文件名的hash值都是相同的。<br>hash一个典型特征是，只有有一个文件改变，那么重新打包后hash值将变化，所以使用hash输出文件名的都将变化，<br>所以业务js，必须使用hash，而不能使用chunkhash。</p><h4 id="chunkhash-以及与-hash-的异同"><a href="#chunkhash-以及与-hash-的异同" class="headerlink" title="[chunkhash]以及与[hash]的异同"></a>[chunkhash]以及与[hash]的异同</h4><p>依赖库的源码，我们一般单独打包成一个库js，这个js必须使用chunkhash，<br>chunkhash的原则是只要chunkhash对应的模块文件不变，就算其他文件有变化了，重新打包了，改变的是hash值，chunkhash值保持不变。<br><strong>所以为了利用http缓存，对于依赖源码库js，必须使用chunkhash，业务js必须使用hash，否则将失去库与业务代码分离的意义</strong></p><h3 id="关于chunkFilename"><a href="#关于chunkFilename" class="headerlink" title="关于chunkFilename"></a>关于chunkFilename</h3><p>chunkFilename是用来配置无入口的chunk输出的名字的。<br>1.代码如下，进行打包；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    appIndex:&apos;./src/index.js&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mode: &apos;production&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &apos;[name].[hash].js&apos;,</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        commons: &#123;</span><br><span class="line">           chunks: &apos;initial&apos;,</span><br><span class="line">           test: path.resolve(__dirname,&apos;node_modules&apos;),</span><br><span class="line">           enforce: true,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>打包后生成：<br><figure class="image-box">                <img src="/image/webpack/chunkfilename1.png" alt="" title="" class="">                <p></p>            </figure><br>因为splitChunks.cacheGroups.commons没有定义name，所以输出文件，默认加 commons~….js;</p><p>2.与1其他配置不变，加上name，再打包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">    cacheGroups: &#123;</span><br><span class="line">      commons: &#123;</span><br><span class="line">        ...</span><br><span class="line">         name: &apos;lodashAndAxios&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>打包后生成，我们发现，这个分离出来的代码块，用的是output.filename的配置：<br><figure class="image-box">                <img src="/image/webpack/chunkfilename2.png" alt="" title="" class="">                <p></p>            </figure></p><p>3.与2其他配置不变，加上chunkfilename，再打包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    ...</span><br><span class="line">    chunkFilename: &apos;[name]._chunk_[chunkhash].js&apos;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>打包后生成，我们发现，这个分离出来的代码块，用的是output.chunkFilename的配置：<br><figure class="image-box">                <img src="/image/webpack/chunkfilename3.png" alt="" title="" class="">                <p></p>            </figure></p><p>这单独分离的代码，在entry中没有入口，只通过splitChunks.cacheGroups.test进行匹配，所以chunkFilename 是用来配置没有入口的名称的，<br>如果不配置chunkFilename，将会根据filename输出。不配置splitChunks.cacheGroups.name，会给输出文件名默认加commons~</p><h3 id="chunk的名称"><a href="#chunk的名称" class="headerlink" title="chunk的名称"></a>chunk的名称</h3><p>chunk的名称和entry的配置有关；</p><ul><li>如果entry是一个string或array，只会生成一个chunk，这是的chunk的名称就是main；</li><li>如果entry是一个Object，就可能会出现多个chunk,这时chunk的名称是Object键值对中健的名称。</li></ul><h3 id="从代码分离看chunk与minChunks"><a href="#从代码分离看chunk与minChunks" class="headerlink" title="从代码分离看chunk与minChunks"></a>从代码分离看chunk与minChunks</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">  a: &apos;./path/to/my/entry/file.js&apos;,</span><br><span class="line">  b: &apos;./path/to/my/entry/app.js&apos;,</span><br><span class="line">&#125;</span><br><span class="line">optimization: &#123;</span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">    cacheGroups: &#123;</span><br><span class="line">      commons: &#123;</span><br><span class="line">        &lt;!-- 如果不指定chunks，将会从现有的所有chunk中提取公共代码 --&gt;</span><br><span class="line">         chunks: [&apos;a&apos;,&apos;b&apos;],//a、b是entry中的两个chunk，从a，b中抽取公共的代码，最终会形成一个名字为appCommon的js，和a.js和b.js</span><br><span class="line">         name: &apos;appCommon&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个参数是minChunks，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">minChunks = 2;</span><br><span class="line">chunks = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;]</span><br></pre></td></tr></table></figure></p><p>只要在abcde模块中任意两个模块出现了公共代码的，都被提取。<br>minChunks主要应对，很可能abcde没有一个公共代码，在所有模块中都有的情况。</p><h3 id="dev模式禁chunkhash"><a href="#dev模式禁chunkhash" class="headerlink" title="dev模式禁chunkhash"></a>dev模式禁chunkhash</h3><p>在dev模式下，只能用hash，不能使用chunkhash，否则报错。</p><h3 id="模块解析规则与resolve"><a href="#模块解析规则与resolve" class="headerlink" title="模块解析规则与resolve"></a>模块解析规则与resolve</h3><h4 id="解析相对路径"><a href="#解析相对路径" class="headerlink" title="解析相对路径"></a>解析相对路径</h4><ul><li>查找相对当前模块的路径下是否有对应文件或文件夹</li><li>是文件则直接加载</li><li>是文件夹则继续查找文件夹下的 package.json 文件</li><li>有 package.json 文件则按照文件中 main 字段的文件名来查找文件</li><li>无 package.json 或者无 main 字段则查找 index.js 文件<h4 id="解析模块名"><a href="#解析模块名" class="headerlink" title="解析模块名"></a>解析模块名</h4>查找当前文件目录下，父级目录及以上目录下的 node_modules 文件夹，看是否有对应名称的模块<h4 id="解析绝对路径（不建议使用）"><a href="#解析绝对路径（不建议使用）" class="headerlink" title="解析绝对路径（不建议使用）"></a>解析绝对路径（不建议使用）</h4>直接查找对应路径的文件</li></ul><p>在 webpack 配置中，和模块路径解析相关的配置都在 resolve 字段下。</p><h4 id="resolve-常用配置："><a href="#resolve-常用配置：" class="headerlink" title="resolve 常用配置："></a>resolve 常用配置：</h4><p>module.exports = {<br>   resolve: {<br>      alias: { // 配置别名<br>         utils: path.resolve(<strong>dirname, ‘src/utils’), // 模糊匹配，意味着只要模块路径中携带utils 就可以被替换掉<br>         component$: path.resolve(</strong>dirname, ‘src/component’) // 只会匹配 import ‘component’， 这是精确匹配方法。<br>      },<br>      modules: [<br>        path.resolve(__dirname, ‘node_modules’), // 指定当前目录下的 node_modules 优先查找<br>        ‘node_modules’, // 如果有一些类库是放在一些奇怪的地方的，你可以添加自定义的路径或者目录<br>      ],<br>      mainFiles: [‘index’], //当目录下没有 package.json 文件时，我们说会默认使用目录下的 index.js 这个文件,就是这个字段配置的。// 你可以添加其他默认使用的文件名<br>      extensions: [“.js”, “.vue”, “.json”] // 默认值: [“.js”,”.json”]  模块名字可以省略的后缀名<br>  },<br>}</p><h3 id="loader的规则条件配置"><a href="#loader的规则条件配置" class="headerlink" title="loader的规则条件配置"></a>loader的规则条件配置</h3><p>大多数情况下，配置 loader 的匹配条件时，只要使用 test 字段就好了，很多时候都只需要匹配文件后缀名来决定使用什么 loader，但也不排除在某些特殊场景下，我们需要配置比较复杂的匹配条件。webpack 的规则提供了多种配置形式：</p><ul><li>{ test: … } 匹配特定条件</li><li>{ include: … } 匹配特定路径</li><li>{ exclude: … } 排除特定路径</li><li>{ and: […] }必须匹配数组中所有条件</li><li>{ or: […] } 匹配数组中任意一个条件</li><li><p>{ not: […] } 排除匹配数组中所有条件<br>上述的所谓条件的值可以是：</p></li><li><p>字符串：必须以提供的字符串开始，所以是字符串的话，这里我们需要提供绝对路径</p></li><li>正则表达式：调用正则的 test 方法来判断匹配</li><li>函数：(path) =&gt; boolean，返回 true 表示匹配</li><li>数组：至少包含一个条件的数组</li><li>对象：匹配所有属性值的条件</li></ul><h3 id="关于output"><a href="#关于output" class="headerlink" title="关于output"></a>关于output</h3><p>单个入口是配置方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const config = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: &apos;./path/to/my/entry/file.js&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const config = &#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &apos;bundle.js&apos;,</span><br><span class="line">    path: &apos;/home/proj/public/assets&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>多个入口时配置方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: &apos;./src/app.js&apos;,</span><br><span class="line">    search: &apos;./src/search.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &apos;[name].js&apos;,//多个时，用占位符[name]的方式定义</span><br><span class="line">    path: __dirname + &apos;/dist&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="css-js是怎么嵌入html"><a href="#css-js是怎么嵌入html" class="headerlink" title="css\js是怎么嵌入html"></a>css\js是怎么嵌入html</h3><p>无论output出来一个或多个js，html-webpack-plugin都会将js、css嵌入到html内：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">new HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: &apos;AICODER 全栈线下实习&apos;, // 默认值：Webpack App</span><br><span class="line">      filename: &apos;indexMyApp.html&apos;, // 默认值： &apos;index.html&apos;</span><br><span class="line">      template: path.resolve(__dirname, &apos;src/tempHtml.html&apos;),</span><br><span class="line">      minify: &#123;</span><br><span class="line">        collapseWhitespace: true,</span><br><span class="line">        removeComments: true, // 是否移除注释</span><br><span class="line">        removeAttributeQuotes: true // 移除属性的引号</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br></pre></td></tr></table></figure></p><h3 id="模板index-html的ejs写法与html-webpack-plugin配合"><a href="#模板index-html的ejs写法与html-webpack-plugin配合" class="headerlink" title="模板index.html的ejs写法与html-webpack-plugin配合"></a>模板index.html的ejs写法与html-webpack-plugin配合</h3><p>模板文件index.html可以写ejs，ejs语法允许写js，然后每行用&lt;%= %&gt;包起来即可:<br><figure class="image-box">                <img src="/image/webpack/tpl1.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/tpl2.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/tpl3.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/tpl4.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/tpl5.png" alt="" title="" class="">                <p></p>            </figure></p><p>注意：1.当有需求把一个js放在html 的header上，一个在body上时，可以定义模板script引用，此时必须设置inject为fasle，表示不适用插件默认嵌入。<br>2.上面ejs模板上一定要写成htmlWebpackPlugin，否则undefined，目前不知道为什么写成HtmlWebpackPlugin就可以关联到插件html-webpack-plugin</p><h3 id="多页面html的配置打包"><a href="#多页面html的配置打包" class="headerlink" title="多页面html的配置打包"></a>多页面html的配置打包</h3><p>要生成多个html，就需要在webpack.config.js中多配置几次new  html-webpack-plugin<br><figure class="image-box">                <img src="/image/webpack/mutilPage1.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/mutilPage2.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/mutilPage3.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/mutilPage4.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/mutilPage5.png" alt="" title="" class="">                <p></p>            </figure></p><h3 id="autoprefixer-配置-postcss-loader"><a href="#autoprefixer-配置-postcss-loader" class="headerlink" title="autoprefixer 配置 (postcss-loader)"></a>autoprefixer 配置 (postcss-loader)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">要生成多个html，就需要在webpack.config.js中多配置几次new  html-webpack-plugin</span><br><span class="line">&#123;</span><br><span class="line">  loader: &apos;postcss-loader&apos;,</span><br><span class="line">  options: &#123;</span><br><span class="line">    ident: &apos;postcss&apos;,</span><br><span class="line">    sourceMap: true,</span><br><span class="line">    //根据中国使用浏览器情况统计，兼容使用率大于百分之0.15的所有浏览器</span><br><span class="line">    plugins: (loader) =&gt; [require(&apos;autoprefixer&apos;)(&#123;browsers: [&apos;&gt; 0.15% in CN&apos;]&#125;)] </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">browsers: [&apos;&gt; 5% in US&apos;] //根据美国使用浏览器情况统计，兼容使用率大于百分之5的所有浏览器</span><br><span class="line">browsers: [&apos;last 5 versions&apos;] //兼容所有浏览器最新的五个版本</span><br></pre></td></tr></table></figure><p><a href="https://github.com/browserslist/browserslist#best-practices" target="_blank" rel="noopener">点击查看更多</a></p><h3 id="html内img图片引用路径"><a href="#html内img图片引用路径" class="headerlink" title="html内img图片引用路径"></a>html内img图片引用路径</h3><p>在html或ejs模板文件，此时如果写绝对路径引用图片是没问题的，如果要使用相对路径，就必须使用require，<br>这是index.html文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> &lt;div class=img&gt;</span><br><span class="line">     &lt;img src=&quot;$&#123; require(&apos;./assets/img/WechatIMG92.jpeg&apos;) &#125;&quot;  alt=&quot;标志&quot; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>这是ejs模板文件：<br><figure class="image-box">                <img src="/image/webpack/htmltpl.png" alt="" title="" class="">                <p></p>            </figure><br>不过在项目中，所以类型的，对图片的引用，使用绝对路径都没问题，只有使用相对路径才会有以上问题。<br>不过在css中，引用图片，使用相对路径和绝对路径都没问题。</p><h3 id="给图片指定生成目录"><a href="#给图片指定生成目录" class="headerlink" title="给图片指定生成目录"></a>给图片指定生成目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: /\.(png|svg|jpg|gif|jpeg)$/,</span><br><span class="line">        include: [path.resolve(__dirname, &apos;src/&apos;)],</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &apos;url-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: 10000,</span><br><span class="line">              //name既可以定义文件名字，也可以定义css生成路径，占位符[ext]是扩展externals的简写指图片扩展名</span><br><span class="line">              name: &apos;image/[name]_image.[ext]&apos;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="带ejs的入口index-html模板文件示例"><a href="#带ejs的入口index-html模板文件示例" class="headerlink" title="带ejs的入口index.html模板文件示例"></a>带ejs的入口index.html模板文件示例</h3><p>对ejs的一点解释</p><ol><li>&lt;%  %&gt; 不输出显示到浏览器上的写法，专门用来运算js；</li><li>&lt;%=  %&gt; 加了一个=后，输出显示到浏览器上的写法；<br>完整示例看 看<a href="https://github.com/YeWills/webpack-code/tree/ejsHtml" target="_blank" rel="noopener">github 仓库中的 ejsHtml 分支 demo </a>，对应的tag发布版本为ejsHtmlV1.0</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">  &lt;script</span><br><span class="line">  src=&quot;https://code.jquery.com/jquery-3.1.0.js&quot;</span><br><span class="line">  integrity=&quot;sha256-slogkvB1K3VOkzAI8QITxV3VzpOnkeNVsKvtkYLMjfk=&quot;</span><br><span class="line">  crossorigin=&quot;anonymous&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"> &lt;% for (var key of htmlWebpackPlugin.files.css) &#123; %&gt;</span><br><span class="line">  &lt;link href=&quot;&lt;%= key %&gt;&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line"> &lt;% &#125; %&gt; </span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;dmo&quot;&gt;我是模板文件自带的内容1&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;% for (var key in htmlWebpackPlugin.files) &#123; %&gt;</span><br><span class="line">        &lt;%= key %&gt; : &lt;%= JSON.stringify(htmlWebpackPlugin.files.css) %&gt; </span><br><span class="line">    &lt;% &#125; %&gt; </span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=img&gt;</span><br><span class="line">      &lt;img src=&quot;$&#123; require(&apos;./assets/img/WechatIMG92.jpeg&apos;) &#125;&quot;  alt=&quot;标志&quot; /&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">  &lt;script</span><br><span class="line">  src=&quot;&lt;%= htmlWebpackPlugin.files.chunks.appIndex.entry %&gt;&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script</span><br><span class="line">  src=&quot;&lt;%= htmlWebpackPlugin.files.chunks.lodashAndAxios.entry %&gt;&quot;&gt;&lt;/script&gt;</span><br><span class="line">  </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="两个横杠命令"><a href="#两个横杠命令" class="headerlink" title="两个横杠命令"></a>两个横杠命令</h3><p>webpack –devtool source-map;<br>发现凡是带两个–的命令，都是配置 webpack 的配置项。</p><h2 id="构建与性能优化"><a href="#构建与性能优化" class="headerlink" title="构建与性能优化"></a>构建与性能优化</h2><h3 id="升级到最新的webpack稳定版本"><a href="#升级到最新的webpack稳定版本" class="headerlink" title="升级到最新的webpack稳定版本"></a>升级到最新的webpack稳定版本</h3><p>这无疑是性能显著提升的</p><h3 id="babel-loader-的优化"><a href="#babel-loader-的优化" class="headerlink" title="babel-loader 的优化"></a>babel-loader 的优化</h3><p>把 loader 应用的文件范围缩小,也就是说，配置loader的include来限定查询范围<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rules: [ </span><br><span class="line">  &#123;</span><br><span class="line">    test: /\.jsx?/,</span><br><span class="line">    include: [ </span><br><span class="line">      path.resolve(__dirname, &apos;src&apos;), </span><br><span class="line">      // 限定只在 src 目录下的 js/jsx 文件需要经 babel-loader 处理</span><br><span class="line">      // 通常我们需要 loader 处理的文件都是存放在 src 目录</span><br><span class="line">    ],</span><br><span class="line">    use: &apos;babel-loader&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">  // ...</span><br><span class="line">],</span><br></pre></td></tr></table></figure></p><h4 id="设置exclude"><a href="#设置exclude" class="headerlink" title="设置exclude"></a>设置exclude</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  modules: [</span><br><span class="line">    path.resolve(__dirname, &apos;node_modules&apos;), // 使用绝对路径指定 node_modules，不做过多查询</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  // 删除不必要的后缀自动补全，少了文件后缀的自动匹配，即减少了文件路径查询的工作</span><br><span class="line">  // 其他文件可以在编码时指定后缀，如 import(&apos;./index.scss&apos;)</span><br><span class="line">  extensions: [&quot;.js&quot;], </span><br><span class="line"></span><br><span class="line">  // 避免新增默认文件，编码时使用详细的文件路径，代码会更容易解读，也有益于提高构建速度</span><br><span class="line">  mainFiles: [&apos;index&apos;],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="启用缓存"><a href="#启用缓存" class="headerlink" title="启用缓存"></a>启用缓存</h4><p>总代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: /\.js$/,</span><br><span class="line">    exclude: /(node_modules)/, // 加快编译速度，不包含node_modules文件夹内容</span><br><span class="line">    use: &#123;</span><br><span class="line">      loader: &apos;babel-loader&apos;,</span><br><span class="line">      options: &#123;</span><br><span class="line">        cacheDirectory: true // 启用缓存，提高编译速度，生成和开发都要如此设置</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="生产下公共代码抽离-待研究"><a href="#生产下公共代码抽离-待研究" class="headerlink" title="生产下公共代码抽离 (待研究)"></a>生产下公共代码抽离 (待研究)</h3><p>假如一个组件使用了lodash，另外一个组件页面也用到了loadash，这个就是公共代码，将公共代码抽离可提高性能。<br>安装好babel-plugin-transform-runtime 和 babel-runtime，然后修改..babelrc文件如下即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [&quot;env&quot;],</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    [&quot;transform-runtime&quot;, &#123;</span><br><span class="line">      &quot;helpers&quot;: true,</span><br><span class="line">      &quot;polyfill&quot;: true,</span><br><span class="line">      &quot;regenerator&quot;: true,</span><br><span class="line">      &quot;moduleName&quot;: &quot;babel-runtime&quot;</span><br><span class="line">    &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="使用花括号-进行import"><a href="#使用花括号-进行import" class="headerlink" title="使用花括号{}进行import"></a>使用花括号{}进行import</h3><p>例如 使用lodash，推荐这种写法import { filter } from ‘lodash’;<br>用什么就花括号，取什么。</p><h3 id="依赖包和业务js分离"><a href="#依赖包和业务js分离" class="headerlink" title="依赖包和业务js分离"></a>依赖包和业务js分离</h3><p>一般依赖包如loadsh，jq这些很少改变，而一般只改变业务js，分开打包后，依赖包js文件名，每次发布版本都是一样的，<br>浏览器的http请求缓存机制，浏览器不会重复请求，直接拿浏览器缓存的依赖包js即可，可提高性能，减少流量。每次发布版本，<br>只需要请求业务js。</p><h3 id="设置外部依赖"><a href="#设置外部依赖" class="headerlink" title="设置外部依赖"></a>设置外部依赖</h3><p>将笨重的很多页面都用到的js通过externals设置成外部依赖。</p><h3 id="利用浏览器http缓解机制"><a href="#利用浏览器http缓解机制" class="headerlink" title="利用浏览器http缓解机制"></a>利用浏览器http缓解机制</h3><p>利用浏览器http缓解机制，库与js代码分离，可以提高速度，减少流量。(这个应该属于 项目性能优化范畴)</p><h3 id="ContextReplacementPlugin"><a href="#ContextReplacementPlugin" class="headerlink" title="ContextReplacementPlugin"></a>ContextReplacementPlugin</h3><p>配置ContextReplacementPlugin，是优化配置，下面章节《其他常用插件》有讲</p><h3 id="webpack-NormalModuleReplacementPlugin"><a href="#webpack-NormalModuleReplacementPlugin" class="headerlink" title="webpack.NormalModuleReplacementPlugin"></a>webpack.NormalModuleReplacementPlugin</h3><p>webpack.NormalModuleReplacementPlugin(a,b)编译时，第一个参数通常是正则，第一个参数正则匹配到文件后，会将此文件替换为第二个参数，从而达到生产或开发时，编译不同文件的目的，比如生产和开发时编译不同的路由文件。<br>所以配置时，在webpack.config.plugins中，位于最前面，保证webpack执行编译时，首先启用此插件替换文件。<br>注意的是，此插件的第一个参数一般都设置为正则。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">  new webpack.NormalModuleReplacementPlugin(</span><br><span class="line">    /some\/path\/config\.development\.js/,</span><br><span class="line">    &apos;./config.production.js&apos;</span><br><span class="line">  ),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="webpack-optimize-OccurrenceOrderPlugin"><a href="#webpack-optimize-OccurrenceOrderPlugin" class="headerlink" title="webpack.optimize.OccurrenceOrderPlugin"></a>webpack.optimize.OccurrenceOrderPlugin</h3><p>OccurrenceOrderPlugin插件：根据出现次数为每一个模块或者chunk设置id,经常使用的模块则会获取到较短的id(和前缀树类似)，这可以使id可预测并有效减少文件大小，建议使用在生产环境中～<br><a href="https://www.cnblogs.com/xuepei/p/7992423.html" target="_blank" rel="noopener">参考</a><br>有些说是可以优化排序输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">  new webpack.optimize.OccurrenceOrderPlugin(),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="减少不必要的plugin"><a href="#减少不必要的plugin" class="headerlink" title="减少不必要的plugin"></a>减少不必要的plugin</h3><h2 id="其他常用插件"><a href="#其他常用插件" class="headerlink" title="其他常用插件"></a>其他常用插件</h2><h3 id="ContextReplacementPlugin-1"><a href="#ContextReplacementPlugin-1" class="headerlink" title="ContextReplacementPlugin"></a>ContextReplacementPlugin</h3><p>当项目用到moment时，务必使用此插件，可减少打包体积，以下代码为例，匹配moment/locale路径，只加载编译此路径下的/zh-cn|zh-hk|en/的文件。<br>new webpack.ContextReplacementPlugin(/moment[/\]locale$/, /zh-cn|zh-hk|en/)</p><h3 id="webpack-NormalModuleReplacementPlugin-1"><a href="#webpack-NormalModuleReplacementPlugin-1" class="headerlink" title="webpack.NormalModuleReplacementPlugin"></a>webpack.NormalModuleReplacementPlugin</h3><p>用法请看章节《构建与性能优化》</p><h3 id="webpack-DefinePlugin"><a href="#webpack-DefinePlugin" class="headerlink" title="webpack.DefinePlugin"></a>webpack.DefinePlugin</h3><p>此插件定义值时，都需加JSON.stringify。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    new webpack.DefinePlugin(&#123;</span><br><span class="line">      &apos;process.env.ASSET_PATH&apos;: JSON.stringify(&quot;5fa3b9&quot;),</span><br><span class="line">      &apos;process.env.FLAG&apos;: JSON.stringify(true)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p><h3 id="ProvidePlugin"><a href="#ProvidePlugin" class="headerlink" title="ProvidePlugin"></a>ProvidePlugin</h3><p>配置全局变量，自动加载模块，不必到处import或require：<br>例如设置$为全局变量，指向jq。<br>new webpack.ProvidePlugin({<br>  $: ‘jquery’,<br>  jQuery: ‘jquery’<br>})</p><h3 id="webpack-optimize-OccurrenceOrderPlugin-1"><a href="#webpack-optimize-OccurrenceOrderPlugin-1" class="headerlink" title="webpack.optimize.OccurrenceOrderPlugin"></a>webpack.optimize.OccurrenceOrderPlugin</h3><p>用法请看章节《构建与性能优化》</p><h2 id="webpack-版本变化"><a href="#webpack-版本变化" class="headerlink" title="webpack 版本变化"></a>webpack 版本变化</h2><h3 id="css分离插件"><a href="#css分离插件" class="headerlink" title="css分离插件"></a>css分离插件</h3><p>webpack4.x弃用了extract-text-webpack-plugin，使用mini-css-extract-plugin代替，来做css从html中分离单独成一个css文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">const MiniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;);</span><br><span class="line"> module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(sc|c|sa)ss$/,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader, &#123;</span><br><span class="line">            loader: &apos;css-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;postcss-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              ident: &apos;postcss&apos;,</span><br><span class="line">              sourceMap: true,</span><br><span class="line">              plugins: (loader) =&gt; [require(&apos;autoprefixer&apos;)(&#123;browsers: [&apos;&gt; 0.15% in CN&apos;]&#125;)]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;sass-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: &apos;[name][hash].css&apos;, // 设置最终输出的文件名</span><br><span class="line">      chunkFilename: &apos;[id][hash].css&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure></p><h3 id="webpack注意事项"><a href="#webpack注意事项" class="headerlink" title="webpack注意事项"></a>webpack注意事项</h3><ul><li>不要在生产环境下使用inline模式的source map，因为这会使js文件变得很大，而且会泄露源码。</li><li>尽量写全名称，扩展名也写上 const common = require(‘./webpack.common.js’);不要写成require(‘./webpack.common’)，不利于编译查询。</li><li>线上发布，或CDN优化配置，大部分与合理配置publicpath有关。</li></ul>]]></content>
      
      
      <categories>
          
          <category> nihaocategories </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nihaotag </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>待写</title>
      <link href="/2018/12/15/111/"/>
      <url>/2018/12/15/111/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><p>hexo用法：<br>hexo g 更新public最新编译，而不删除git文件，发布文章的时候用这个最好</p>]]></content>
      
      
      
    </entry>
    
  
  
</search>
