<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>js设计模式</title>
      <link href="/2019/01/27/js_design_main/"/>
      <url>/2019/01/27/js_design_main/</url>
      
        <content type="html"><![CDATA[<p>js设计模式分两篇来写，此为下篇，上篇为 《js设计模式序(面向对象、闭包、命名空间)》。<br>主要讲设计原则与设计模式两部分。</p><h1 id="js设计原则"><a href="#js设计原则" class="headerlink" title="js设计原则"></a>js设计原则</h1><p>js设计原则有四五个，但真正在js编程中的用得最多的差不多就两个：单一职责原则、开放封闭原则。<br>另外在本节的最后部分，附上《unix／linux 设计哲学》书中提到的几个linux的编码准则，列举其中对js编码有启发意义的几个。</p><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>单一职责原则：一个对象（方法）只做一件事情。<br>单一职责原则要求我们在写复杂方法时，将方法进行抽象，分离颗粒化成多个方法，让每个方法只做一件事情。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：让一个方法只做一个事情，将复杂职责分解为多个职责，后期维护代码的时候，修改其中一个职责，也就不会影响其他职责，这样代码可读性、可维护性、可扩张、可移植性更好，也更符合开放封闭原则。<br>缺点：增加编写代码的复杂度（能写出单一职责设计原则代码的程序员，也是要求他有一定编程水平才能写出的），当我们按照职责把对象分解成更小粒度之后，实际上也增大了这些对象之间相互联系的难度。</p><p>单一职责原则是js编写代码最重要的两个准则之一，在它的优点面前，它的缺点不值得一提。</p><h2 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>开放封闭原则：对扩展开放，对修改封闭。<br>开放封闭原则要求我们写出来的方法，当对程序方法进行扩展时，更加方便，不要修改原来的行为方法。</p><p>通过一段代码来体现 开放封闭原则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 这是原代码，此代码相比之下，每次扩展都需要修改makeSound方法，违反了开放封闭原则</span><br><span class="line">//每次扩展时，因为要修改公共方法makeSound，你还要担心有回归测试的一些问题，还要去测试Duck和Chicken</span><br><span class="line">var makeSound = function(animal)&#123;</span><br><span class="line">  if(animal instanceof Duck)&#123;</span><br><span class="line">    console.log(&apos;嘎嘎嘎&apos;);</span><br><span class="line">  &#125;else if(animal instanceof Chicken)&#123;</span><br><span class="line">    console.log(&apos;咯咯咯&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var Duck = function()&#123;&#125;</span><br><span class="line">var Chicken = function()&#123;&#125;</span><br><span class="line">makeSound(new Duck);</span><br><span class="line">makeSound(new Chicken);</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 这是改良后代码，此代码相比之下，每次扩展都不用修改makeSound方法，更加易于扩展，而且makeSound是一个公共的方法，</span><br><span class="line">//每次扩展时，因为不用修改公共方法makeSound，就不会担心有回归测试的一些问题，不用担心还要去测试Duck和Chicken</span><br><span class="line">var makeSound = function(animal)&#123;</span><br><span class="line">  animal.sound();</span><br><span class="line">&#125;</span><br><span class="line">var Duck = function()&#123;&#125;</span><br><span class="line">Duck.prototype.sound = function()&#123;</span><br><span class="line">  console.log(&apos;嘎嘎嘎&apos;);</span><br><span class="line">&#125;</span><br><span class="line">var Chicken = function()&#123;&#125;</span><br><span class="line">Chicken.prototype.sound = function()&#123;</span><br><span class="line">  console.log(&apos;咯咯咯&apos;);</span><br><span class="line">&#125;</span><br><span class="line">makeSound(new Duck);</span><br><span class="line">makeSound(new Chicken);</span><br><span class="line"></span><br><span class="line">//增加新需求，添加一个Dog行为</span><br><span class="line">var Dog = function()&#123;&#125;</span><br><span class="line">Dog.prototype.sound = function()&#123;</span><br><span class="line">  console.log(&apos;汪汪汪&apos;);</span><br><span class="line">&#125;</span><br><span class="line">makeSound(new Dog);</span><br></pre></td></tr></table></figure><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：从上面代码例子中看到，开放封闭原则的代码，后期可维护性更高，扩展性更强，但有扩展新功能时，风险更小，要做的回归测试问题更少，因此维护、扩展成本更低。<br>缺点：在项目刚开始时，因为业务不熟，或业务不稳定，因此你很难抽象出 方法中永远变化的部分和永远不变化的部分进行封装。</p><h3 id="接受第一次愚弄"><a href="#接受第一次愚弄" class="headerlink" title="接受第一次愚弄"></a>接受第一次愚弄</h3><p>为了解决上面说的缺点，一种现实的做法是，在项目刚开始时，我们假设方法的所有部分都是不变化的，不对方法进行开放封闭进行抽象封装处理，项目初期快速编码完成需求，不影响项目进度。<br>当后期变化发生时，再来回过头来封装这些变化地方，确保下一次不会掉进同一个坑里。<br>我们将这条编码经验称之为 ‘接受第一次愚弄’，但永远不会被同样的招数击倒第二次。</p><h2 id="unix／linux-设计哲学-的-几条准则"><a href="#unix／linux-设计哲学-的-几条准则" class="headerlink" title="unix／linux 设计哲学 的 几条准则"></a>unix／linux 设计哲学 的 几条准则</h2><p>准则1:小即是美<br>准则2:让每个程序只做好一件事情<br>准则3:快速建立原型（快速更早将功能骨架做好，先让用户用起来，然后客户边用边反馈，开发根据这个实施开发客户反馈需求）<br>准则4:舍弃高效率而取可移植性（硬件升级或浏览器内核升级后，原来不高效的写法，因为计算机硬件提高，原来不高效写法不影响效率了）<br>准则5:充分地抽象封装程序，以此达到程序复用性</p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js设计模式 </tag>
            
            <tag> 单例模式 </tag>
            
            <tag> 观察者模式 </tag>
            
            <tag> 状态模式 </tag>
            
            <tag> 单一职责原则 </tag>
            
            <tag> 开放封闭原则 </tag>
            
            <tag> 舍弃高效率而取可移植性 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2019/01/24/test/"/>
      <url>/2019/01/24/test/</url>
      
        <content type="html"><![CDATA[<html>    <head><meta name="generator" content="Hexo 3.8.0">            <title>222</title>            <script>var makeSound = function(animal){  if(animal instanceof Duck){    console.log('嘎嘎嘎');  }else if(animal instanceof Chicken){    console.log('咯咯咯');  }}var Duck = function(){}var Chicken = function(){}makeSound(new Duck);makeSound(new Chicken);var makeSound = function(animal){  animal.sound();}var Duck = function(){}Duck.prototype.sound = function(){  console.log('嘎嘎嘎');}var Chicken = function(){}Chicken.prototype.sound = function(){  console.log('咯咯咯');}makeSound(new Duck);makeSound(new Chicken);var Dog = function(){}Dog.prototype.sound = function(){  console.log('汪汪汪');}makeSound(new Dog);                        </script>    </head>    <body>        <div>            6666        </div>    </body></html>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>js设计模式序(面向对象、闭包、命名空间)</title>
      <link href="/2019/01/23/js_design_start/"/>
      <url>/2019/01/23/js_design_start/</url>
      
        <content type="html"><![CDATA[<p>js设计模式分两篇来写，此为上篇。下篇为《js设计模式》。<br>js设计模式之前需要了解js的面向对象编程、闭包、命名空间编程模式的概念。</p><h1 id="js的面向对象编程"><a href="#js的面向对象编程" class="headerlink" title="js的面向对象编程"></a>js的面向对象编程</h1><p>注意，这里说的是js的面向对象编程，非java面向对象编程。js的面向对象编程与java是有区别的。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>js面向对象编程的核心概念是 类 和 实例(对象)。<br>类 在es6上就是 class类，在es5中就是构造函数中定义一系列的propoty原型<br>实例 就是 new class类，或者 new 构造函数。实例就是对象。<br>而定义类，最后实例化这个类，都是为了得到这个实例对象。重点最终是对象。这就是面向对象的编程。</p><p>简单说，js面向对象编程，就是熟悉使用 class类 来进行js编程。<br>由于react框架的流行，组件都是通过class类编程，因此熟练使用 js的面向对象编程变得更加重要。</p><p>注意的是，js的面向对象编程与java是有区别的。</p><h2 id="new-的理解"><a href="#new-的理解" class="headerlink" title="new 的理解"></a>new 的理解</h2><p>关于new 的理解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Base();</span><br><span class="line">//new操作符具体干了什么呢?其实很简单，就干了三件事情：</span><br><span class="line">var obj  = &#123;&#125;;</span><br><span class="line">obj.__proto__ = Base.prototype;</span><br><span class="line">Base.call(obj);</span><br></pre></td></tr></table></figure><p>下面将讲 面向对象编程三大特征 多态，继承，封装</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>js的多态与java的面向对象多态不同。</p><p>js的多态定义：对同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。<br>以上通俗点的定义就是：对同一个函数作用于不同对象时（也就是同一个函数，接受不同的对象作为参数时），函数执行的结果不同。</p><p>列举多态的几个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//最简单的：</span><br><span class="line">var  a  =  5;</span><br><span class="line">console.log(a);</span><br><span class="line">a=&quot;str&quot;;</span><br><span class="line">console.log(a)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//最经典的：</span><br><span class="line">var makeSound = function(animal) &#123; // 把不变的部分隔离出来</span><br><span class="line">    animal.sound();</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">var Duck = function() &#123;&#125;;</span><br><span class="line">Duck.prototype.sound = function() &#123;</span><br><span class="line">    console.log(&quot;嘎嘎嘎&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">var Chicken = function() &#123;&#125;;</span><br><span class="line">Chicken.prototype.sound = function() &#123;</span><br><span class="line">    console.log(&quot;咯咯咯&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">makeSound( new Duck() ); // 嘎嘎嘎</span><br><span class="line">makeSound( new Chicken() ); // 咯咯咯</span><br></pre></td></tr></table></figure><p>多态的思想实际上是把“做什么”和“谁去做”分离开来，达到 开放-封闭的设计原则。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="原型浅拷贝的痛点"><a href="#原型浅拷贝的痛点" class="headerlink" title="原型浅拷贝的痛点"></a>原型浅拷贝的痛点</h3><p>所有new实例将指向构造函数原型上的引用类型，造成浅拷贝问题，一个实例修改了此引用类型，其他所有实例受此影响。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> function Super()&#123;</span><br><span class="line">    this.colors = [&apos;red&apos;,&apos;blue&apos;,&apos;green&apos;];</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.apples = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">function newF(o, constructor)&#123;</span><br><span class="line">    o.__proto__ = constructor.prototype;</span><br><span class="line">    constructor.call(o); </span><br><span class="line">&#125;</span><br><span class="line">var aa = &#123;&#125;;</span><br><span class="line">var bb = &#123;&#125;;</span><br><span class="line">newF(aa, Super);</span><br><span class="line">newF(bb, Super);</span><br><span class="line">console.log(aa.apples === bb.apples)//true</span><br><span class="line">console.log(aa.colors === bb.colors)//false</span><br></pre></td></tr></table></figure></p><p>以上过程代码等效于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> function Super()&#123;</span><br><span class="line">    this.colors = [&apos;red&apos;,&apos;blue&apos;,&apos;green&apos;];</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.apples = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">var aa = new Super();</span><br><span class="line">var bb = new Super();</span><br><span class="line">console.log(aa.apples === bb.apples)//true</span><br><span class="line">console.log(aa.colors === bb.colors)//false</span><br></pre></td></tr></table></figure></p><p>以上说明了，构造函数 new出来的所有实例，他们会针对同一个构造函数prototype对象被赋值，如果prototype对象里面有引用类型，那么将相互影响，结合上面代码，这情况等同于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> Super.prototype = &#123;apples:&#123;&#125;&#125;;</span><br><span class="line">aa.__proto__ = Super.prototype </span><br><span class="line">//等同于</span><br><span class="line">aa.apples = Super.prototype.apples</span><br></pre></td></tr></table></figure></p><h3 id="es5继承"><a href="#es5继承" class="headerlink" title="es5继承"></a>es5继承</h3><h4 id="套路"><a href="#套路" class="headerlink" title="套路"></a>套路</h4><p>es5继承方法有类继承和原型继承，我们不用去管他们叫什么名字和概念是什么，他们的套路无非三种：<br>1、代理函数(proxy)的构造函数内让父构造函数call一次，就会重写覆盖父构造函数内属性，以此来避免浅拷贝问题。<br>2、将父函数的new 实例对象 赋值给代理函数的prototype。<br>3、将父函数的prototype 赋值给代理函数的prototype。</p><h4 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h4><p>通过以上套路，大致有以下两种方式实现继承：<br>方式一<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//方式一，将父函数的new 实例对象 赋值给代理函数的prototype，弊端 会执行两次父函数</span><br><span class="line"> function Super()&#123;</span><br><span class="line">    this.colors = [&apos;red&apos;,&apos;blue&apos;,&apos;green&apos;];</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.apples = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">function proxy()&#123;</span><br><span class="line">    //执行一次父函数Super</span><br><span class="line">     Super.call(this);</span><br><span class="line">&#125;</span><br><span class="line">//方式一 proxy.prototype直接赋值 new 构造函数</span><br><span class="line">proxy.prototype = new Super();//执行第二次父函数Super</span><br><span class="line">var aa = new proxy();//次步代码 会 重写覆盖父构造函数内属性</span><br><span class="line">var bb = new proxy();</span><br><span class="line">console.log(aa.colors === bb.colors)//true</span><br></pre></td></tr></table></figure></p><p>方式二、此方式与方式一一样，其他代码与方式一都一样，只有一句不同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//方式二，相比方式二的好处在于 父函数 只执行一遍</span><br><span class="line"> ...</span><br><span class="line">proxy.prototype = Super.prototype</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><h4 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h4><p>以上方式都无法解决 prototype 对象的 浅拷贝问题。原因见 《所有new实例将浅拷贝原型上的引用类型 》</p><h4 id="es5最佳继承方式一：与深拷贝函数结合"><a href="#es5最佳继承方式一：与深拷贝函数结合" class="headerlink" title="es5最佳继承方式一：与深拷贝函数结合"></a>es5最佳继承方式一：与深拷贝函数结合</h4><p>传统的继承方式都无法解决prototype的浅拷贝问题，只能引入深拷贝函数，如下代码的deepcopy深拷贝方法，网上有很多，可以去找。<br>所以es5方法写继承最佳方式：父函数.call + proxy.prototype = deepcopy(Super.prototype).<br>简言之 call + 原型赋原型 + 深拷贝<br>作用：<br>call 拷贝 构造函数内属性<br>原型赋原型 拷贝原型方法，避免执行一次父函数<br>深拷贝 避免原型浅拷贝问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Super(name)&#123;</span><br><span class="line">    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.apples = &#123;&#125;;</span><br><span class="line">function Sub(name)&#123;</span><br><span class="line">    Super.call(this);</span><br><span class="line">&#125;</span><br><span class="line">Sub.prototype = deepcopy(Super.prototype);</span><br></pre></td></tr></table></figure><h4 id="es5最佳继承方式二：引用对象不写入父原型上"><a href="#es5最佳继承方式二：引用对象不写入父原型上" class="headerlink" title="es5最佳继承方式二：引用对象不写入父原型上"></a>es5最佳继承方式二：引用对象不写入父原型上</h4><p>es5继承的痛点是无法原型浅拷贝问题，如果能引用对象不写入父原型上，则可放心继承。</p><h3 id="最终极方式：es6-class"><a href="#最终极方式：es6-class" class="headerlink" title="最终极方式：es6 class"></a>最终极方式：es6 class</h3><p>class是es6 的api，是一个语法糖，使用class进行继承，能够轻松进行继承，且无浅拷贝问题。<br>因此推荐使用es6的class类继承方式，代码优雅而简洁，不推荐使用es5。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Super &#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    this.colors = [];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Sub extends Super&#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var instance1 = new Sub();</span><br><span class="line">var instance2 = new Sub();</span><br><span class="line">console.log(instance1.colors === instance2.colors);//false</span><br></pre></td></tr></table></figure><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装这个最好理解，直白的说就是：<br>封装说的就类。类由一系列的方法和属性组成，将一系列的方法和属性封装起来，封装成一个类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class People &#123;</span><br><span class="line">    constructor(name, age) &#123;</span><br><span class="line">        this.name = name</span><br><span class="line">        this.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    eat() &#123;</span><br><span class="line">        alert(`$&#123;this.name&#125; eat something`)</span><br><span class="line">    &#125;</span><br><span class="line">    speak() &#123;</span><br><span class="line">        alert(`My name is $&#123;this.name&#125;, age $&#123;this.age&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p><a href="https://blog.csdn.net/ybdt1201/article/details/53366613" target="_blank" rel="noopener">关于闭包详细知识，可参考我在几年前写的一篇博客，这里只摘取一些必要知识</a>，以下内容基本摘至这篇博客，如有疑问，点击进入了解。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>官方对闭包的定义：所谓“闭包”，指的是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。</p><p>还有一种对闭包更直接明了的说法：<a href="https://www.cnblogs.com/tinkbell/p/3173293.html" target="_blank" rel="noopener">闭包就是有权访问另一个函数作用域中变量的函数。</a><br>分析这句话:<br>　　1.闭包是定义在函数中的函数.<br>　　2.闭包能访问函数内的私有变量.<br>　　3.即使包含函数执行完了, 被闭包引用的变量也得不到释放.</p><p>满足以上定义的，都可称之为闭包。</p><h2 id="三种定义方式"><a href="#三种定义方式" class="headerlink" title="三种定义方式"></a>三种定义方式</h2><p>闭包有三种定义方式，一种就是经典的return方式，一种就是new的方式，一种就是对象方式。<br>我目前看到的闭包就这三种，基本这三种满足了工作中绝大部分需求了。<br>网上有很多人列举了很多闭包方式，其实本质上都是对这三种方式的发展延伸而已。</p><h3 id="return方式"><a href="#return方式" class="headerlink" title="return方式"></a>return方式</h3><p>这种方式最经典，也最为常用，推荐这种写法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function a() &#123;</span><br><span class="line">    var num = 1;</span><br><span class="line">    return function ()&#123;</span><br><span class="line">        num++;</span><br><span class="line">        console.log(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="new-方式"><a href="#new-方式" class="headerlink" title="new 方式"></a>new 方式</h3><p>这种方式之所以被认定为闭包，是因为以下两点理由，下面代码中：<br>1、a是母函数<br>2、inc是a执行后返回，相当于return的函数，此函数绑定了a的私有变量n， 这是决定inc是否为闭包的重要依据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function a()&#123;</span><br><span class="line">  var n = 0;</span><br><span class="line">  this.inc = function () &#123;</span><br><span class="line">    n++;</span><br><span class="line">    console.log(n);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var cc = new a();</span><br><span class="line">cc.inc()//1</span><br><span class="line">cc.inc()//2</span><br></pre></td></tr></table></figure></p><h3 id="对象方式"><a href="#对象方式" class="headerlink" title="对象方式"></a>对象方式</h3><p>下面两个闭包例子，套路都一样，外层定义个对象，然后在母函数内部给这个对象定义一个函数，此函数绑定了私有变量，即为闭包函数。<br>我们姑且称这种定义闭包的方式为对象方式吧。<br>以下方式之所以被认定为闭包，是因为以下两点理由，下面代码中：<br>1、有母函数（下面两个例子母函数是匿名函数，当然也可以定义为非匿名函数）<br>2、母函数执行后，给函数绑定了母函数的私有变量n， 这是决定内部函数是否为闭包的重要依据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">(function() &#123;</span><br><span class="line">    var n = 1;</span><br><span class="line">    obj.count = function () &#123;</span><br><span class="line">                    n++;</span><br><span class="line">                    console.log(n);</span><br><span class="line">                 &#125;;</span><br><span class="line">    </span><br><span class="line">&#125;)()</span><br><span class="line">obj.count();//2</span><br><span class="line">obj.count();//3</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var divDom = $(&apos;#name&apos;);</span><br><span class="line">(function() &#123;</span><br><span class="line">    var n = 1;</span><br><span class="line">    divDom.onclick = function () &#123;</span><br><span class="line">                    n++;</span><br><span class="line">                    console.log(n);</span><br><span class="line">                 &#125;;</span><br><span class="line">    </span><br><span class="line">&#125;)()</span><br><span class="line">divDom.onclick();//2</span><br><span class="line">divDom.onclick();//3</span><br></pre></td></tr></table></figure><h2 id="不是闭包的设计"><a href="#不是闭包的设计" class="headerlink" title="不是闭包的设计"></a>不是闭包的设计</h2><p>列举一下非闭包的设计方式，以此加深对闭包的理解<br>很多人认为自运行匿名函数、命名空间设计模式和原型定义方式都是闭包，我觉得是不对的。</p><h3 id="自运行匿名函数："><a href="#自运行匿名函数：" class="headerlink" title="自运行匿名函数："></a>自运行匿名函数：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//这不是闭包</span><br><span class="line">(function fn()&#123;</span><br><span class="line">          var n = 8;</span><br><span class="line">           console.log(n) ;</span><br><span class="line">      &#125;)();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//这一种是闭包的设计，但并不是因为它是自运行匿名函数的原因，而是因为匿名函数内部return了一个函数的原因，</span><br><span class="line">//这其实就是上面讲的两种闭包设计模式的第一种 return方式</span><br><span class="line">(function fn()&#123;</span><br><span class="line">      var n = 8;</span><br><span class="line">      return function()&#123;</span><br><span class="line">          console.log(n) ;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)();</span><br></pre></td></tr></table></figure><h3 id="js的命名空间写法"><a href="#js的命名空间写法" class="headerlink" title="js的命名空间写法"></a>js的命名空间写法</h3><p>js的命名空间写法不能称之为闭包，它最多是使用了js关于引用对象一处改变，都受改变的特性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//这是命名空间的写法，但不是闭包</span><br><span class="line">var obj = &#123;</span><br><span class="line">  n:8,</span><br><span class="line">  count:function()&#123;</span><br><span class="line">    this.n++;</span><br><span class="line">    console.log(this.n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.count()//9</span><br><span class="line">obj.count()//10</span><br></pre></td></tr></table></figure></p><h3 id="原型定义方式"><a href="#原型定义方式" class="headerlink" title="原型定义方式"></a>原型定义方式</h3><p>还有一些把函数定义在原型上，这本质上也是运用了引用对象的特性，不是闭包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//这不是闭包，是运用了引用对象的特性，才有对象元素值叠加的效果</span><br><span class="line">function a()&#123;</span><br><span class="line">  this.n = 8;</span><br><span class="line">&#125;</span><br><span class="line">a.prototype.count=function()&#123;</span><br><span class="line">  this.n++;</span><br><span class="line">  console.log(this.n);</span><br><span class="line">&#125;</span><br><span class="line">var obj = new a();</span><br><span class="line">obj.count()//9</span><br><span class="line">obj.count()//10</span><br></pre></td></tr></table></figure></p><p> 如果稍微换一下，就行不通了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//这不是闭包</span><br><span class="line">function a()&#123;</span><br><span class="line">  this.n = 8;</span><br><span class="line">&#125;</span><br><span class="line">a.prototype.count=function()&#123;</span><br><span class="line">  this.n++;</span><br><span class="line">  console.log(this.n);</span><br><span class="line">&#125;</span><br><span class="line">var newCount = (new a()).count;</span><br><span class="line">newCount()//NaN</span><br><span class="line">newCount()//NaN</span><br></pre></td></tr></table></figure></p><h2 id="闭包的用处"><a href="#闭包的用处" class="headerlink" title="闭包的用处"></a>闭包的用处</h2><h3 id="定义私有变量"><a href="#定义私有变量" class="headerlink" title="定义私有变量"></a>定义私有变量</h3><p>若不想某些变量被其他函数访问，就可以写一个闭包设计，将变量定义为私有变量，只有闭包函数可以访问，达到其他函数无法访问的目的。</p><h3 id="保存变量值"><a href="#保存变量值" class="headerlink" title="保存变量值"></a>保存变量值</h3><p>这是闭包最经典和关键意义所在，也是闭包函数存在的意义。闭包函数绑定了母函数的变量，每次执行完，此变量不销毁，达到保存变量值的目的。</p><h2 id="运用场景"><a href="#运用场景" class="headerlink" title="运用场景"></a>运用场景</h2><h3 id="保存变量值。"><a href="#保存变量值。" class="headerlink" title="保存变量值。"></a>保存变量值。</h3><h3 id="进行前后两次执行时的比较。"><a href="#进行前后两次执行时的比较。" class="headerlink" title="进行前后两次执行时的比较。"></a>进行前后两次执行时的比较。</h3><h4 id="react-redux的props状态比较"><a href="#react-redux的props状态比较" class="headerlink" title="react-redux的props状态比较"></a>react-redux的props状态比较</h4><p>比如react-redux就是通过闭包的这个特性，保存prop上一次状态，然后跟当前props比较。</p><h4 id="节流和防抖"><a href="#节流和防抖" class="headerlink" title="节流和防抖"></a>节流和防抖</h4><p>这是性能优化经常使用的手段，可以网上查阅，都是用闭包来进行。</p><h4 id="for循环的使用"><a href="#for循环的使用" class="headerlink" title="for循环的使用"></a>for循环的使用</h4><p>错误写法，这种for达不到预期<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//错误写法</span><br><span class="line">function foo()&#123;</span><br><span class="line">    var arr = [];</span><br><span class="line">    for(var i = 0; i &lt; 2; i++)&#123;</span><br><span class="line">        arr[i] = function()&#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">var bar = foo();</span><br><span class="line">console.log(bar[0]());//2</span><br></pre></td></tr></table></figure></p><p>正确写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//正确写法</span><br><span class="line">//为什么能记住当时值，是因为是自运行的函数，每次都会执行一次</span><br><span class="line">function foo()&#123;</span><br><span class="line">    var arr = [];</span><br><span class="line">    for(var i = 0; i &lt; 2; i++)&#123;</span><br><span class="line">        arr[i] = (function fn(j)&#123;</span><br><span class="line">            return function test()&#123;</span><br><span class="line">                return j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">var bar = foo();</span><br><span class="line">console.log(bar[0]());//0</span><br></pre></td></tr></table></figure></p><p>换一种写法，可能更容易理解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//正确写法</span><br><span class="line">function foo()&#123;</span><br><span class="line">    var arr = [];</span><br><span class="line">    for(var i = 0; i &lt; 2; i++)&#123;</span><br><span class="line">        arr[i] = (function fn(j)&#123;</span><br><span class="line">            var _j = j;//定义一个变量，更容易理解</span><br><span class="line">            return function test()&#123;</span><br><span class="line">                return _j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">var bar = foo();</span><br><span class="line">console.log(bar[0]());//0</span><br></pre></td></tr></table></figure></p><h2 id="对闭包的误解"><a href="#对闭包的误解" class="headerlink" title="对闭包的误解"></a>对闭包的误解</h2><p>很多人认为闭包会增加内存，导致内存泄漏，这是错误的，是对闭包的误解。<br>如果你不把变量定义为闭包访问的私有变量，你也一定会把这些变量定义在全局作用域上，全局作用上下文也是不销毁的，一样也是增加了内存。<br>所以闭包并没有增加内存，更没有内存泄漏。<br>如果增加了内存和内存泄漏，其实都是编码水平有待提高导致。</p><h1 id="命名空间模式"><a href="#命名空间模式" class="headerlink" title="命名空间模式"></a>命名空间模式</h1><p>js使用命名空间模式设计，主要是为了避免命名冲突。<br>命名空间设计模式有很多，工作中最常用的是 对象字面量表示法 的设计模式。其他命名空间模式，我觉得应该用的不多，知道一下即可，这里不展开，可以网上查，<a href="https://www.cnblogs.com/syfwhu/p/4885628.html" target="_blank" rel="noopener">也可参考此篇文章</a>。</p><h2 id="对象字面量表示法"><a href="#对象字面量表示法" class="headerlink" title="对象字面量表示法"></a>对象字面量表示法</h2><p>对象字面量表示法是命名空间设计模式的一种，用得最广，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//对象字面量表示法 的命名空间设计模式</span><br><span class="line">var myApplication = &#123;</span><br><span class="line">    // 可以很容易的为对象字面量定义功能</span><br><span class="line">    getInfo:function() &#123;</span><br><span class="line">        // ***</span><br><span class="line">    &#125;,</span><br><span class="line">    // 可以进一步支撑对象命名空间</span><br><span class="line">    models:&#123;&#125;,</span><br><span class="line">    views:&#123;</span><br><span class="line">        pages:&#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    collections:&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="命名空间与设计模式区别"><a href="#命名空间与设计模式区别" class="headerlink" title="命名空间与设计模式区别"></a>命名空间与设计模式区别</h2><p>很多人命名空间的设计模式，是js 单例的设计模式，其实二者完全是两样东西。<br>命名空间偏向于是一种编程规范的设计；<br>js的一些设计模式，例如单例、观察者模式，更多的偏向功能实现方案的js设计模式。如设计绑定和监听时，选择观察者设计模式。<br>所以说，命名空间是一种编程规范，设计模式(如单例，以下设计模式都为这种含义)是一种功能实现的设计方案。</p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js设计模式 </tag>
            
            <tag> 命名空间 </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> 闭包 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React Router</title>
      <link href="/2019/01/13/react_router/"/>
      <url>/2019/01/13/react_router/</url>
      
        <content type="html"><![CDATA[<h2 id="React-Router常见知识"><a href="#React-Router常见知识" class="headerlink" title="React Router常见知识"></a>React Router常见知识</h2><h3 id="HashRouter-还是-BrowserRouter-以及-Router-Route-讲解"><a href="#HashRouter-还是-BrowserRouter-以及-Router-Route-讲解" class="headerlink" title="HashRouter 还是 BrowserRouter 以及 Router  Route 讲解"></a>HashRouter 还是 BrowserRouter 以及 Router  Route 讲解</h3><p>简言之如果项目服务端做了服务端渲染，可以选择BrowserRouter，否则请选择HashRouter，因此一般项目都是HashRouter，因为大多项目么有做服务端渲染。<br>详细见下面（还讲了：利用服务器解析机制，服务器不会解析路由#以后的部分）：<br>摘自《React 实战：设计模式和最佳实践》第15章；<br>react-router 的工作方式，是在组件树顶层放一个 Router 组件，然后在组件树中散落着很多 Route 组件（注意比 Router 少一个“r”），顶层的 Router 组件负责分析监听 URL 的变化，在它保护伞之下的 Route 组件可以直接读取这些信息。</p><p>很明显，Router 和 Route 的配合，就是之前我们介绍过的“提供者模式”，Router 是“提供者”，Route是“消费者”。</p><p>更进一步，Router 其实也是一层抽象，让下面的 Route 无需各种不同 URL 设计的细节，不要以为 URL 就一种设计方法，至少可以分为两种。</p><p>第一种很自然，比如 / 对应 Home 页，/about 对应 About 页，但是这样的设计需要服务器端渲染，因为用户可能直接访问任何一个 URL，服务器端必须能对 /的访问返回 HTML，也要对 /about 的访问返回 HTML。</p><p>第二种看起来不自然，但是实现更简单。<strong>只有一个路径 /，通过 URL 后面的 # 部分来决定路由，/#/ 对应 Home 页，/#/about 对应 About 页。因为 URL 中#之后的部分是不会发送给服务器的，所以，无论哪个 URL，最后都是访问服务器的 / 路径，服务器也只需要返回同样一份 HTML 就可以，然后由浏览器端解析 # 后的部分，完成浏览器端渲染。</strong></p><p>在 react-router，有 BrowserRouter 支持第一种 URL，有 HashRouter 支持第二种 URL。</p><p>因为 create-react-app 产生的应用默认不支持服务器端渲染，为了简单起见，我们在下面的例子中使用 HashRouter，在实际产品中，其实最好还是用 BrowserRouter，这样用户体验更好。</p><p>修改index.js文件，增加下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123;HashRouter&#125; from &apos;react-router-dom&apos;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;HashRouter&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;/HashRouter&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>把 Router 用在 React 组件树的最顶层，这是最佳实践。因为将来我们如果想把 HashRouter 换成 BrowserRouter，组件 App 以下几乎不用任何改变。</p><h3 id="带-与不带-的路由的区别"><a href="#带-与不带-的路由的区别" class="headerlink" title="带#与不带#的路由的区别"></a>带#与不带#的路由的区别</h3><p>利用服务器解析机制，服务器不会解析路由#以后的部分，详细见本章第《HashRouter 还是 BrowserRouter 以及 Router  Route 讲解》</p><h3 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h3><p>摘自《React 实战：设计模式和最佳实践》第15章；<br>我们来看 Content 这个组件，这里会用到 react-router 最常用的两个组件 Route 和 Switch。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const Content = () =&gt; (</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;Switch&gt;</span><br><span class="line">      &lt;Route exact path=&apos;/&apos; component=&#123;Home&#125;/&gt;</span><br><span class="line">      &lt;Route path=&apos;/about&apos; component=&#123;About&#125;/&gt;</span><br><span class="line">    &lt;/Switch&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>Route 组件的 path 属性用于匹配路径，因为我们需要匹配 / 到 Home，匹配 /about 到 About，所以肯定需要两个 Route，但是，我们不能这么写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&apos;/&apos; component=&#123;Home&#125;/&gt;</span><br><span class="line">&lt;Route path=&apos;/about&apos; component=&#123;About&#125;/&gt;</span><br></pre></td></tr></table></figure></p><p>如果按照上面这么写，当访问 /about 页面时，不光匹配 /about，也配中 /，界面上会把 Home 和 About 都渲染出来的。</p><p>解决方法，可以在想要精确匹配的 Route 上加一个属性 exact，或者使用 Switch 组件。</p><p>可以把 Switch 组件看做是 JavaScript 的 switch 语句，像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">switch (条件) &#123;</span><br><span class="line">  case 1: 渲染1; break;</span><br><span class="line">  case 2: 渲染2; break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上往下找第一个匹配的 Route，匹配中了之后，立刻就 break，不继续这个 Switch 下其他的 Route 匹配了。</p><p>可以看到，react-router 巧妙地用 React 组件实现了路由的所有逻辑，印证了那句话：React 世界里一切都是组件。</p><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>摘自《React 实战：设计模式和最佳实践》第15章；<br>在了解了 react-router的基本路由功能之后，再来理解“动态路由”就容易了。</p><p>假设，我们增加一个新的页面叫 Product，对应路径为 /product，但是只有用户登录了之后才显示。如果用静态路由，我们在渲染之前就确定这条路由规则，这样即使用户没有登录，也可以访问 product，我们还不得不在 Product 组件中做用户是否登录的检查。</p><p>如果用动态路由，则只需要在代码中的一处涉及这个逻辑：</p><pre><code>&lt;Switch&gt;  &lt;Route exact path=&apos;/&apos; component={Home}/&gt;  {    isUserLogin() &amp;&amp;    &lt;Route exact path=&apos;/product&apos; component={Product}/&gt;,  }    &lt;Route path=&apos;/about&apos; component={About}/&gt;&lt;/Switch&gt;</code></pre><p>可以用任何条件决定 Route 组件实例是否渲染，比如，可以根据页面宽度、设备类型决定路由规则，动态路由有了最大的自由度。</p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
          <category> React Router </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo笔记</title>
      <link href="/2019/01/13/hexo/"/>
      <url>/2019/01/13/hexo/</url>
      
        <content type="html"><![CDATA[<h2 id="hexo-常用知识"><a href="#hexo-常用知识" class="headerlink" title="hexo 常用知识"></a>hexo 常用知识</h2><h3 id="编译源码的github放置和hexo-g命令"><a href="#编译源码的github放置和hexo-g命令" class="headerlink" title="编译源码的github放置和hexo g命令"></a>编译源码的github放置和hexo g命令</h3><p>编译后源码会在public目录：YeWills.github.io/public/<br>将git仓库放在public中，<br>每次需要发布时，执行hexo g，然后在public目录下 git push;<br>hexo d 并不会删除publc目录的.git文件夹，只会增量叠加。<br>注意，不要执行hexo clean，它会删除public目录</p><h3 id="写的文章放在哪里与-posts目录"><a href="#写的文章放在哪里与-posts目录" class="headerlink" title="写的文章放在哪里与_posts目录"></a>写的文章放在哪里与_posts目录</h3><p>YeWills.github.io/source/_posts/<br>所有的文章都放置于_posts目录下。</p><h3 id="创建tag与categories相关事情"><a href="#创建tag与categories相关事情" class="headerlink" title="创建tag与categories相关事情"></a>创建tag与categories相关事情</h3><p>二者配置一样，以categories为例：<br>hexo new page categories<br>生成目录和文件：<br>YeWills.github.io/source/categories/index.md<br>修改index.md元数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">layout: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>同时修改<br>YeWills.github.io/scaffolds/draft.md<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">tags: &#123;&#123; tags &#125;&#125;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>YeWills.github.io/scaffolds/page.md<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>YeWills.github.io/scaffolds/post.md<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags: &#123;&#123; tags &#125;&#125;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>如此便可以配置出categories的all或全部 的选项卡内容，如果没有以上步骤，也可以生成categories，但无法生产categories的all或全部 的选项卡内容；<br>且点击本主题左侧菜单栏categories会报404错误。</p><p>这一步的配置内容，可看commit 哈希值 cbb06710ce7a40ade93</p><h3 id="categories、tags两种配置方式"><a href="#categories、tags两种配置方式" class="headerlink" title="categories、tags两种配置方式"></a>categories、tags两种配置方式</h3><p>categories:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 推荐使用方法 method one,双横杠方式，可以配置多级，</span><br><span class="line">categories: </span><br><span class="line">- react</span><br><span class="line">- react读书笔记</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// method two,只能配置一个值</span><br><span class="line">categories: &quot;react&quot;</span><br></pre></td></tr></table></figure><p>tags:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// method one</span><br><span class="line">tags:[react, react读书笔记]</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// method two,只能配置一个值</span><br><span class="line">tags: react</span><br></pre></td></tr></table></figure><h3 id="博客菜单栏左侧内容修改"><a href="#博客菜单栏左侧内容修改" class="headerlink" title="博客菜单栏左侧内容修改"></a>博客菜单栏左侧内容修改</h3><p>比如修改qq号码，名字，git地址，都可在这里修改YeWills.github.io/themes/mellow/_config.yml</p><h3 id="博客菜单栏左侧菜单增减"><a href="#博客菜单栏左侧菜单增减" class="headerlink" title="博客菜单栏左侧菜单增减"></a>博客菜单栏左侧菜单增减</h3><p>比如修改qq号码，名字，git地址，都可在这里修改YeWills.github.io/themes/mellow/_config.yml<br>修改改文件的menu部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home:</span><br><span class="line">    text: HOME</span><br><span class="line">    url: /</span><br><span class="line">    icon: home</span><br><span class="line">  th-list:</span><br><span class="line">    text: CATEGORIES</span><br><span class="line">    url: /categories</span><br><span class="line">    icon: th-list</span><br><span class="line">  tags:</span><br><span class="line">    text: TAGS</span><br><span class="line">    url: /tags</span><br><span class="line">    icon: tags</span><br><span class="line">  archives:</span><br><span class="line">    text: ARCHIVES</span><br><span class="line">    url: /archives</span><br><span class="line">    icon: archives</span><br></pre></td></tr></table></figure></p><p>如上，menu.th-list配置的是categories目录</p>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>webpack笔记</title>
      <link href="/2019/01/12/webpack/"/>
      <url>/2019/01/12/webpack/</url>
      
        <content type="html"><![CDATA[<h2 id="webpack常用知识"><a href="#webpack常用知识" class="headerlink" title="webpack常用知识"></a>webpack常用知识</h2><h3 id="sourcemap的处理"><a href="#sourcemap的处理" class="headerlink" title="sourcemap的处理"></a>sourcemap的处理</h3><h4 id="css模块-sourcemap的处理"><a href="#css模块-sourcemap的处理" class="headerlink" title="css模块 sourcemap的处理"></a>css模块 sourcemap的处理</h4><p>给一下loader加上sourceMap: true，就可以做到css的sourcemap调试。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: /\.(sc|c|sa)ss$/,</span><br><span class="line">        use: [</span><br><span class="line">          &apos;style-loader&apos;, &#123;</span><br><span class="line">            loader: &apos;css-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;postcss-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              ident: &apos;postcss&apos;,</span><br><span class="line">              sourceMap: true,</span><br><span class="line">              plugins: (loader) =&gt; [require(&apos;autoprefixer&apos;)(&#123;browsers: [&apos;&gt; 0.15% in CN&apos;]&#125;)]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;sass-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><h4 id="js模块-sourcemap的处理"><a href="#js模块-sourcemap的处理" class="headerlink" title="js模块 sourcemap的处理"></a>js模块 sourcemap的处理</h4><p>很简单，加一个这个配置即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devtool: &apos;inline-source-map&apos;, // 开发阶段开启 sourcemap</span><br></pre></td></tr></table></figure></p><h3 id="给css加前缀-postcss-loader"><a href="#给css加前缀-postcss-loader" class="headerlink" title="给css加前缀  postcss-loader"></a>给css加前缀  postcss-loader</h3><p><a href="https://www.webpackjs.com/loaders/postcss-loader/#options" target="_blank" rel="noopener">postcss-loader</a>有很多用处，其中之一就是给各个浏览器添加css3兼容样式。</p><p>安装 postcss-loader 和 autoprefixer。 使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: /\.(sc|c|sa)ss$/,</span><br><span class="line">        use: [</span><br><span class="line">          &apos;style-loader&apos;, &#123;</span><br><span class="line">            loader: &apos;css-loader&apos;,</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;postcss-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              ident: &apos;postcss&apos;,//这里一定要定义一个唯一的名字，一般喜欢定义为postcss，你也可以定义任意其他唯一名字</span><br><span class="line">              //&gt; 0.15% in CN 大致是指兼容什么范围内的浏览器，这样写就行，一定要设置，否则可能不加前缀，</span><br><span class="line">              //且数值一定要设置合适，否则设置浏览器太新，也可能不会生成前缀</span><br><span class="line">              plugins: (loader) =&gt; [require(&apos;autoprefixer&apos;)(&#123;browsers: [&apos;&gt; 0.15% in CN&apos;]&#125;)]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;sass-loader&apos;,</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><h3 id="抽离css样式文件"><a href="#抽离css样式文件" class="headerlink" title="抽离css样式文件"></a>抽离css样式文件</h3><p>注意：1.webpack4开始使用mini-css-extract-plugin ，1-3版本可以用 extract-text-webpack-plugin。<br>     2.只有 mode: ‘production’ 插件才生效。<br>     3.开发阶段使用style-loader就行了<br>方法：<br>1.mode: ‘production’<br>2.抽离只需将原先style-loader的对象换成mini-css-extract-plugin；<br>3.配置plugins；</p><p>配置代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">const MiniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;);</span><br><span class="line">...</span><br><span class="line">mode: &apos;production&apos;,</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">        test: /\.(sc|c|sa)ss$/,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader, &#123;</span><br><span class="line">            loader: &apos;css-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;postcss-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              ident: &apos;postcss&apos;,</span><br><span class="line">              sourceMap: true,</span><br><span class="line">              plugins: (loader) =&gt; [require(&apos;autoprefixer&apos;)(&#123;browsers: [&apos;&gt; 0.15% in CN&apos;]&#125;)]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;sass-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line"> ....</span><br><span class="line"> plugins: [</span><br><span class="line">   new MiniCssExtractPlugin(&#123;</span><br><span class="line">     filename: &apos;[name][hash].css&apos;, // 设置最终输出的文件名，这个name最终根据output.filename一致。</span><br><span class="line">     chunkFilename: &apos;[id][hash].css&apos;</span><br><span class="line">   &#125;)</span><br><span class="line"> ],</span><br></pre></td></tr></table></figure><p>以下是css未从html上抽离的原先配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: /\.(sc|c|sa)ss$/,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &apos;style-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,&#123;</span><br><span class="line">            loader: &apos;css-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &apos;postcss-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              ident: &apos;postcss&apos;,</span><br><span class="line">              sourceMap: true,</span><br><span class="line">              plugins: (loader) =&gt; [require(&apos;autoprefixer&apos;)(&#123;browsers: [&apos;&gt; 0.15% in CN&apos;]&#125;)]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;sass-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="压缩css"><a href="#压缩css" class="headerlink" title="压缩css"></a>压缩css</h3><p>所谓压缩代码，就是把css压缩成紧凑的一行。<br>注意：1.webpack5内置压缩 ，4版本可以设置插件optimize-css-assets-webpack-plugin即可。<br>     2.只有 mode: ‘production’ 。<br>配置代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const OptimizeCSSAssetsPlugin = require(&apos;optimize-css-assets-webpack-plugin&apos;);</span><br><span class="line">...</span><br><span class="line">mode: &apos;production&apos;</span><br><span class="line">...</span><br><span class="line">optimization: &#123;</span><br><span class="line">    minimizer: [</span><br><span class="line">      new OptimizeCSSAssetsPlugin(&#123;&#125;), // 压缩CSS插件</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="解决css文件或者js文件名字哈希值变化的问题"><a href="#解决css文件或者js文件名字哈希值变化的问题" class="headerlink" title="解决css文件或者js文件名字哈希值变化的问题"></a>解决css文件或者js文件名字哈希值变化的问题</h3><p>html-webpack-plugin插件，可以把打包后的css或js文件引用直接注入到HTML模板中，这样就不用每次手动修改文件引用了。<br>因此，只要项目中使用了hash，就必须配套使用html-webpack-plugin。<br>另外如果要使用模板html，也必须配套使用html-webpack-plugin。<br>当然，你也可以不使用模板，就算有哈希值，你不怕麻烦，当然也可以不适用html-webpack-plugin,你自己手写html，然后将打包生成的js\css文件手动引用也是可以的。<br>配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">new HtmlWebpackPlugin(&#123;</span><br><span class="line">  title: &apos;AICODER test&apos;, // 默认值：Webpack App</span><br><span class="line">  filename: &apos;index.html&apos;, // 默认值： &apos;index.html&apos;</span><br><span class="line">  template: path.resolve(__dirname, &apos;src/main.html&apos;),</span><br><span class="line">  minify: &#123;</span><br><span class="line">    collapseWhitespace: true, // 折叠空白</span><br><span class="line">    removeComments: true, // 是否移除注释</span><br><span class="line">    removeAttributeQuotes: true // 移除属性的引号</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="每次打包自动清除上一个dist目录"><a href="#每次打包自动清除上一个dist目录" class="headerlink" title="每次打包自动清除上一个dist目录"></a>每次打包自动清除上一个dist目录</h3><p>使用插件：clean-webpack-plugin，配置如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;);</span><br><span class="line">plugins: [</span><br><span class="line">    new CleanWebpackPlugin([&apos;dist&apos;])</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="压缩图片"><a href="#压缩图片" class="headerlink" title="压缩图片"></a>压缩图片</h3><p>使用loader：image-webpack-loader，一定在url-loader之前执行image-webpack-loader。<br>image-webpack-loader可以让原来90kb的图片，变成70kb，而不怎么影响质量。<br>配置如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: /\.(png|svg|jpg|gif|jpeg)$/,</span><br><span class="line">        include: [path.resolve(__dirname, &apos;src/&apos;)],</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &apos;url-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: 10000</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;image-webpack-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              mozjpeg: &#123;</span><br><span class="line">                progressive: true,</span><br><span class="line">                quality: 65</span><br><span class="line">              &#125;,</span><br><span class="line">              optipng: &#123;</span><br><span class="line">                enabled: false</span><br><span class="line">              &#125;,</span><br><span class="line">              pngquant: &#123;</span><br><span class="line">                quality: &apos;65-90&apos;,</span><br><span class="line">                speed: 4</span><br><span class="line">              &#125;,</span><br><span class="line">              gifsicle: &#123;</span><br><span class="line">                interlaced: false</span><br><span class="line">              &#125;,</span><br><span class="line">              webp: &#123;</span><br><span class="line">                quality: 75</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><h3 id="file-loader-与-url-loader-异同"><a href="#file-loader-与-url-loader-异同" class="headerlink" title="file-loader 与 url-loader 异同"></a>file-loader 与 url-loader 异同</h3><p>他们都是用来处理项目中图片的。<br>file-loader 有的功能，基本上url-loader都用；<br>而且url-loader还可以将图片进行base64压缩的功能（你可以不使用此功能）；<br>因此，项目中使用url-loader而不适用file-loader。<br>url-loader 配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: /\.(png|svg|jpg|gif|jpeg)$/,</span><br><span class="line">        include: [path.resolve(__dirname, &apos;src/&apos;)],</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &apos;url-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: 10000 //1kb以内的图片将被base64压缩</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><p>url-loader将图片进行base64压缩后就是一串DataURL：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    background: url(data:image/png;base64,UklGRkYwAABXRUJQVlA4WAoAAAAQAAAA/QIA8AAAQUxQSMAcAAABb…KnjLJNbGNAMFRe2WQhUfMAAAA19AAAkbAAAAAAAAAAAAAAABrYAAAAAD0gAAAAAAAAAAAAAAAA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在基本上常用的浏览器和移动端都可很好兼容DataURL，所以可以放心使用。<br>base64压缩图片为一串DataURL的好处在于减少html页面的http请求。缺点在于会加大打包文件大小。<br>一般网页性能优化时：<br>对于小图片，会使用base64压缩，减少http请求；<br>对于大图片，还是使用http请求。</p><h3 id="字体文件处理"><a href="#字体文件处理" class="headerlink" title="字体文件处理"></a>字体文件处理</h3><p>字体文件处理同图片文件处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: /\.(woff|woff2|eot|ttf|otf)$/,</span><br><span class="line">    include: [path.resolve(__dirname, &apos;src/&apos;)],</span><br><span class="line">    use: [</span><br><span class="line">      &#123;</span><br><span class="line">        loader: &apos;file-loader&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="代理proxy的几张图片"><a href="#代理proxy的几张图片" class="headerlink" title="代理proxy的几张图片"></a>代理proxy的几张图片</h3><p>备用，以后再分析<br><figure class="image-box">                <img src="/image/webpack/proxy1.jpg" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/proxy2.jpg" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/proxy3.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="外部扩展-externals"><a href="#外部扩展-externals" class="headerlink" title="外部扩展(externals)"></a>外部扩展(externals)</h3><p> 把一个模块做成外部依赖也就是用cdn的方式依赖，不会打包到 js文件中。<br> 例如lodash,jquery基本上每个页面都要用到，这个时候把它们放在index.html模板中，<br> 每个组件都可以通过externals定义的名称进行引用。<br> 从而可以减少打包后js的大小。<br> 配置如下：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//index.html模板中</span><br><span class="line">&lt;script</span><br><span class="line">  src=&quot;https://code.jquery.com/jquery-3.1.0.js&quot;</span><br><span class="line">  integrity=&quot;sha256-slogkvB1K3VOkzAI8QITxV3VzpOnkeNVsKvtkYLMjfk=&quot;</span><br><span class="line">  crossorigin=&quot;anonymous&quot;&gt;</span><br><span class="line"></span><br><span class="line">  //webpack.config.js</span><br><span class="line">   externals: &#123;  // 把一个模块做成外部依赖，不会打包到 js文件中。</span><br><span class="line">      jquery: &apos;jQuery&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    //index.js使用jquery</span><br><span class="line">    import $ from &apos;jquery&apos;; //注意是小写</span><br></pre></td></tr></table></figure></p><h3 id="webpack-bundle-analyzer统计分析"><a href="#webpack-bundle-analyzer统计分析" class="headerlink" title="webpack-bundle-analyzer统计分析"></a>webpack-bundle-analyzer统计分析</h3><p>注意，这个是在开发环境下使用,配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const BundleAnalyzerPlugin = require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin;</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">   new BundleAnalyzerPlugin(), // 打包模块报表</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure></p><p>配置好后，执行npm start ，会自动在浏览器打开分析页面：<br><figure class="image-box">                <img src="/image/webpack/analyzer.png" alt="" title="" class="">                <p></p>            </figure><br>由图看出，loadsh.js的体积最大，经过分析，可以将loadsh.js做成外部依赖，从而减少打包后js的体积。</p><h3 id="分离-库与业务代码"><a href="#分离-库与业务代码" class="headerlink" title="分离 库与业务代码"></a>分离 库与业务代码</h3><h4 id="配置方法一"><a href="#配置方法一" class="headerlink" title="配置方法一"></a>配置方法一</h4><p>配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">   filename: &apos;[name].[hash].js&apos;, //定义库代码以外的代码打包成的js appIndex.54c949dd739536531ad5.js</span><br><span class="line">   chunkFilename: &apos;[name].chunk.js&apos;,//定义库代码打包成的js customChunkNameQQ.chunk.js</span><br><span class="line">   path: path.resolve(__dirname, &apos;dist&apos;) //打包后输出的路径</span><br><span class="line"> &#125;,</span><br><span class="line">optimization: &#123;</span><br><span class="line">   splitChunks: &#123;</span><br><span class="line">           cacheGroups: &#123;</span><br><span class="line">             commons: &#123;</span><br><span class="line">                chunks: &apos;initial&apos;,</span><br><span class="line">                test: path.resolve(__dirname,&apos;node_modules&apos;),//匹配到的文件都将被一起打包成库js</span><br><span class="line">                enforce: true,</span><br><span class="line">                name: &apos;customChunkNameQQ&apos;,//定义打包后[name]值</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure></p><p>库与业务代码分离 使用的是splitChunks配置，其实它是一个插件，被整合到webpack4了。<br>这个插件的思路是，利用test匹配文件，只要匹配到的就打包成库js，剩下没有被匹配到的，就被打包成业务js；<br>所以如果test匹配不到任何文件，将不会有库js生成，所有的js资源都会被剩下，都被打包到业务js中。</p><p>以下就是一个例子，只有业务js生成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">   appIndex:&apos;./src/index.js&apos;</span><br><span class="line"> &#125;,</span><br><span class="line"> optimization: &#123;</span><br><span class="line">   splitChunks: &#123;</span><br><span class="line">           cacheGroups: &#123;</span><br><span class="line">             commons: &#123;</span><br><span class="line">                chunks: &apos;initial&apos;,</span><br><span class="line">                test: path.resolve(__dirname,&apos;node_modules11&apos;),//因为项目没有node_modules11目录,将只会有一个业务js生成</span><br><span class="line">                enforce: true,</span><br><span class="line">                name: &apos;customChunkNameQQ&apos;,</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p> <strong>webpack打包的原则就是这样，如果没有插件,所有的js将被webpack系统打包成一个js，如果有插件做代码分离，插件匹配的部分将被插件打包成js，剩下的将被webpack系统打包成一个js，如果插件没有匹配到任何js，,所有的js将被webpack系统打包成一个js</strong></p><p>还有其他几种定义方法：</p><h4 id="显示配置方法-推荐"><a href="#显示配置方法-推荐" class="headerlink" title="显示配置方法(推荐)"></a>显示配置方法(推荐)</h4><p>注意下面这个示例配置有一点点问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//将&apos;lodash&apos;,&apos;axios&apos;两个库的代码合并打包成一个名字为customChunkNameQQ 的 js，文件；</span><br><span class="line">//剩下所有js包含其他依赖库和业务js将被合并打包成另个一个js。</span><br><span class="line"> entry: &#123;</span><br><span class="line">    appIndex:&apos;./src/index.js&apos;,</span><br><span class="line">    lodashAndAxios:[&apos;lodash&apos;,&apos;axios&apos;],//显示定义需要将这些依赖库打成一个js</span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">              commons: &#123;</span><br><span class="line">                 chunks: &apos;initial&apos;,</span><br><span class="line">                 test: &apos;lodashAndAxios&apos;, //一定要匹配entry对象内，key值，lodashAndAxios就是entry中的key值</span><br><span class="line">                 enforce: true,</span><br><span class="line">                 name: &apos;customChunkNameQQ&apos;,</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>上面配置有些问题，打包后，会生成三个js：<br><figure class="image-box">                <img src="/image/webpack/verder2.png" alt="" title="" class="">                <p></p>            </figure><br>所以修改以上配置，将cacheGroups.commons.name与cacheGroups.commons.test统一定义成entry中的lodashAndAxios这样生成的文件就正常了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 正确配置方法 --&gt;</span><br><span class="line"> entry: &#123;</span><br><span class="line">    appIndex:&apos;./src/index.js&apos;,</span><br><span class="line">    lodashAndAxios:[&apos;lodash&apos;,&apos;axios&apos;],//显示定义需要将这些依赖库打成一个js</span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">              commons: &#123;</span><br><span class="line">                 chunks: &apos;initial&apos;,</span><br><span class="line">                 test: &apos;lodashAndAxios&apos;, //一定要匹配entry对象内，key值，lodashAndAxios就是entry中的key值</span><br><span class="line">                 enforce: true,</span><br><span class="line">                 name: &apos;lodashAndAxios&apos;,</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>打包结果为：<br><figure class="image-box">                <img src="/image/webpack/verder2.png" alt="" title="" class="">                <p></p>            </figure></p><h4 id="直接用test匹配方法"><a href="#直接用test匹配方法" class="headerlink" title="直接用test匹配方法"></a>直接用test匹配方法</h4><p>上面的方法也可以写成如下，效果一样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//将&apos;lodash&apos;,&apos;axios&apos;两个库的代码合并打包成一个名字为customChunkNameQQ 的 js，文件；</span><br><span class="line">//剩下所有js包含其他依赖库和业务js将被合并打包成另个一个js。</span><br><span class="line"> entry: &#123;</span><br><span class="line">    appIndex:&apos;./src/index.js&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">              commons: &#123;</span><br><span class="line">                 chunks: &apos;initial&apos;,</span><br><span class="line">                 test: /lodash|axios/,  //直接使用test去匹配</span><br><span class="line">                 enforce: true,</span><br><span class="line">                 name: &apos;customChunkNameQQ&apos;,</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><h3 id="entry多种配置形式"><a href="#entry多种配置形式" class="headerlink" title="entry多种配置形式"></a>entry多种配置形式</h3><p>入口可以使用 entry 字段来进行配置，webpack 支持配置多个入口来进行构建：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &apos;./src/index.js&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 上述配置等同于</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: &apos;./src/index.js&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 或者配置多个入口</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    foo: &apos;./src/page-foo.js&apos;,</span><br><span class="line">    bar: &apos;./src/page-bar.js&apos;,</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用数组来对多个文件进行打包</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: [</span><br><span class="line">      &apos;./src/foo.js&apos;,</span><br><span class="line">      &apos;./src/bar.js&apos;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后的例子，可以理解为多个文件作为一个入口，webpack 会解析两个文件的依赖后进行打包。</p><p>还有一种形式，就是使用库与业务代码分离optimization.splitChunks时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//将&apos;lodash&apos;,&apos;axios&apos;两个库的代码合并打包成一个名字为customChunkNameQQ 的 js，文件；</span><br><span class="line">//剩下所有js包含其他依赖库和业务js将被合并打包成另个一个js。</span><br><span class="line"> entry: &#123;</span><br><span class="line">    appIndex:&apos;./src/index.js&apos;,</span><br><span class="line">    lodashAndAxios:[&apos;lodash&apos;,&apos;axios&apos;],//显示定义需要将这些依赖库打成一个js</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">  filename: &apos;[name].[hash].js&apos;,//库js剩下的，也就是所谓的业务js</span><br><span class="line">  chunkFilename: &apos;[name].chunk.js&apos;, //打包出来的库js</span><br><span class="line">  path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">&#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        commons: &#123;</span><br><span class="line">           chunks: &apos;initial&apos;,</span><br><span class="line">           test: &apos;lodashAndAxios&apos;,</span><br><span class="line">           enforce: true,</span><br><span class="line">           name: &apos;lodashAndAxios&apos;,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p><strong>entry 值可以是字符串，可以是对象；当entry为对象时，对象元素的key，value；value可以是字符串，也可以是数组。</strong></p><h3 id="生产与开发环境差异配置"><a href="#生产与开发环境差异配置" class="headerlink" title="生产与开发环境差异配置"></a>生产与开发环境差异配置</h3><p>前面提及的使用环境变量的方式可以让我们在不同的构建环境中完成不同的构建需求，这里列举一下常见的 webpack 构建差异配置：</p><ul><li>生产环境可能需要分离 CSS 成单独的文件，以便多个页面共享同一个 CSS 文件</li><li>生产环境需要压缩 HTML/CSS/JS 代码</li><li>生产环境需要压缩图片</li><li>开发环境需要生成 sourcemap 文件</li><li>开发环境需要打印 debug 信息</li><li>开发环境需要 live reload 或者 hot reload 的功能</li></ul><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ul><li>Entry: 入口。</li><li>Module: 模块。在webpack里，一切皆模块，一个模块对应一个文件，webpack会从配置的entry开始递归找出所有依赖的模块。</li><li>Chunk: 代码块。一个Chunk由多个模块组合而成，用于代码合并和分割。</li><li>loader: 模块转换器。</li><li>Plugin: 扩展插件。</li><li>Output: 输出结果。<br>webpack 在启动后会从Entry里配置的Moule开始，递归解析Entry依赖的所有module，每找到一个module，就会根据配置的loader去找出对应的转换规则，对module进行转换后，再解析出当前module依赖的module。这些模块会以entry为单位进行分组，一个entry及其所有依赖的module被分到一个组也就是一个chunk，最后webpack会将所有chunk转换成文件输出。<br><strong>在webpack中chunk概念很重要，也很不好理解，也容易被忽视，其实webpack目的是一个打包工具，然而将整个包打成几个代码块，都是由chunk控制，所以理解chunk对理解webpack，至关重要。</strong></li></ul><h2 id="webpack-黑知识"><a href="#webpack-黑知识" class="headerlink" title="webpack 黑知识"></a>webpack 黑知识</h2><h3 id="合并两个webpack的js配置"><a href="#合并两个webpack的js配置" class="headerlink" title="合并两个webpack的js配置"></a>合并两个webpack的js配置</h3><p>使用webpack-merge即可，配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//webpack.common</span><br><span class="line">module.exports = &#123;&#125;  //module.exports是node的语法，是commonjs标准</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//webpack.dev.js</span><br><span class="line">const merge = require(&apos;webpack-merge&apos;);</span><br><span class="line">const common = require(&apos;./webpack.common&apos;);</span><br><span class="line">let devConfig = &#123;&#125;</span><br><span class="line">module.exports = merge(common, devConfig);</span><br></pre></td></tr></table></figure><h3 id="–watch-与-热更新"><a href="#–watch-与-热更新" class="headerlink" title="–watch 与 热更新"></a>–watch 与 热更新</h3><p>在命令中加入 –watch，可以达到效果：当文件改动时，会自动编译，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;watch&quot;: &quot;npx webpack --watch --config webpack.dev.js&quot;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>自动编译还是不够的，我们还想它能够编译后自动刷新页面，也就是热更新，最常见的是npm start：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;npm webpack-dev-server --config webpack.dev.js&quot;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>其中devServer.hot置为true，就可以达到热更新。</p><p>所以启动 webpack-dev-server，可以达到自动编译(–watch功能)和热更新功能。</p><h3 id="自动编译与热更新三大条件"><a href="#自动编译与热更新三大条件" class="headerlink" title="自动编译与热更新三大条件"></a>自动编译与热更新三大条件</h3><p>需要同时如下配置，才能进行自动编译与热更新：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const webpack = require(&apos;webpack&apos;);</span><br><span class="line"></span><br><span class="line">devServer: &#123;</span><br><span class="line">   hot: true, // 启用 webpack 的模块热替换特性, 这个需要配合： webpack.HotModuleReplacementPlugin插件</span><br><span class="line"> &#125;,</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  new webpack.NamedModulesPlugin(), // 更容易查看(patch)的依赖</span><br><span class="line">  new webpack.HotModuleReplacementPlugin() // 替换插件</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="webpack-dev-server黑知识"><a href="#webpack-dev-server黑知识" class="headerlink" title="webpack-dev-server黑知识"></a>webpack-dev-server黑知识</h3><p>如下，将看到以下几点黑知识：</p><h4 id="为什么是-0-0-0-0；"><a href="#为什么是-0-0-0-0；" class="headerlink" title="为什么是 0.0.0.0；"></a>为什么是 0.0.0.0；</h4><p>当然，服务器也可以设置为127.0.0.1，这个随你，注意的是设置为0.0.0.0时，可能0.0.0.0:58080有问题，在浏览器上改为127即可正常访问。</p><h4 id="npm-start后自动打开浏览器；"><a href="#npm-start后自动打开浏览器；" class="headerlink" title="npm start后自动打开浏览器；"></a>npm start后自动打开浏览器；</h4><h4 id="编译监听的防抖设置；"><a href="#编译监听的防抖设置；" class="headerlink" title="编译监听的防抖设置；"></a>编译监听的防抖设置；</h4><h4 id="忽略监控文件范围设置；"><a href="#忽略监控文件范围设置；" class="headerlink" title="忽略监控文件范围设置；"></a>忽略监控文件范围设置；</h4><h4 id="proxy的代理重写pathRewrite；"><a href="#proxy的代理重写pathRewrite；" class="headerlink" title="proxy的代理重写pathRewrite；"></a>proxy的代理重写pathRewrite；</h4><h4 id="publicPath的黑知识；"><a href="#publicPath的黑知识；" class="headerlink" title="publicPath的黑知识；"></a>publicPath的黑知识；</h4><figure class="image-box">                <img src="/image/webpack/publicPath.jpg" alt="" title="" class="">                <p></p>            </figure><p>publicPath 的优先级高于 contentBase。contentBase 用于配置提供额外静态文件内容的目录，之前提到的 publicPath 是配置构建好的结果以什么样的路径去访问，而 contentBase 是配置额外的静态文件内容的访问路径，即那些不经过 webpack 构建，但是需要在 webpack-dev-server 中提供访问的静态资源（如部分图片等）<br>你不懂contentBase publicPath为什么，没关系，先这样用着。<br>更多配置说明可参考掘金小册的第六章节。</p><p>webpack-dev-server的配置devServer 完整代码及解释如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    clientLogLevel: &apos;warning&apos;, // 可能的值有 none, error, warning 或者 info（默认值)</span><br><span class="line">    hot: true, // 启用 webpack 的模块热替换特性, 这个需要配合： webpack.HotModuleReplacementPlugin插件</span><br><span class="line">    contentBase: path.join(__dirname, &quot;dist&quot;), // 告诉服务器从哪里提供内容， 默认情况下，将使用当前工作目录作为提供内容的目录</span><br><span class="line">    compress: true, // 一切服务都启用gzip 压缩</span><br><span class="line">    host: &apos;0.0.0.0&apos;, // 指定使用一个 host。默认是 localhost。如果你希望服务器外部可访问 0.0.0.0</span><br><span class="line">    port: 58080, // 端口</span><br><span class="line">    open: true, // 是否打开浏览器</span><br><span class="line">    overlay: &#123; // 出现错误或者警告的时候，是否覆盖页面线上错误消息。</span><br><span class="line">      warnings: true,</span><br><span class="line">      errors: true</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    publicPath: &apos;/&apos;, // 此路径下的打包文件可在浏览器中访问。（注意没有特殊要求，一定就设置为&apos;/&apos;）</span><br><span class="line"></span><br><span class="line">    proxy: &#123; // 设置代理</span><br><span class="line">      &quot;/api&quot;: &#123; // 访问api开头的请求，会跳转到  下面的target配置</span><br><span class="line">        target: &quot;http://192.168.0.102:8080&quot;,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          &quot;^/api&quot;: &quot;/mockjsdata/5/api&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        //以上配置的意思就是 /api/getuser     =&gt;  http://192.168.0.102:8080//mockjsdata/5/api/getuser</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    quiet: true, // necessary for FriendlyErrorsPlugin. 启用 quiet 后，除了初始启动信息之外的任何内容都不会被打印到控制台。这也意味着来自 webpack 的错误或警告在控制台不可见。</span><br><span class="line">    watchOptions: &#123; // 监视文件相关的控制选项</span><br><span class="line">      poll: true, // webpack 使用文件系统(file system)获取文件改动的通知。在某些情况下，不会正常工作。例如，当使用 Network File System (NFS) 时。Vagrant 也有很多问题。在这些情况下，请使用轮询. poll: true。当然 poll也可以设置成毫秒数，比如：  poll: 1000</span><br><span class="line">      ignored: /node_modules/, // 忽略监控的文件夹，正则</span><br><span class="line">      aggregateTimeout: 300 // 默认值，当第一个文件更改，会在重新构建前增加延迟，防抖的功能，如果你连续几次改的文件间隔小于300毫秒，会延迟编译</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="服务器默认读取index-html"><a href="#服务器默认读取index-html" class="headerlink" title="服务器默认读取index.html"></a>服务器默认读取index.html</h3><p>入口HTML若不是index.html则需补全：<br><figure class="image-box">                <img src="/image/webpack/index.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="resolve之默认扩展文件名"><a href="#resolve之默认扩展文件名" class="headerlink" title="resolve之默认扩展文件名"></a>resolve之默认扩展文件名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">    alias: &#123; // 配置别名</span><br><span class="line">      &apos;@&apos;: path.resolve(__dirname, &apos;src/&apos;)</span><br><span class="line">    &#125;,</span><br><span class="line">    extensions: [&quot;.js&quot;, &quot;.vue&quot;, &quot;.json&quot;] // 默认值: [&quot;.js&quot;,&quot;.json&quot;]  模块名字可以省略的后缀名</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h3 id="name-id-hash-chunkhash"><a href="#name-id-hash-chunkhash" class="headerlink" title="[name][id][hash][chunkhash]"></a>[name][id][hash][chunkhash]</h3><h4 id="name"><a href="#name" class="headerlink" title="[name]"></a>[name]</h4><p>所有的name，默认为entry中定义的，如果entry的值为字符串，则默认为main。<br>如：<br>下面代码是entry为字符串时，[name] 为默认的main<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">entry: &apos;./src/index.js&apos;,</span><br><span class="line"></span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">              commons: &#123;</span><br><span class="line">                 chunks: &apos;initial&apos;,</span><br><span class="line">                 test: path.resolve(__dirname,&apos;node_modules&apos;),</span><br><span class="line">                 enforce: true,</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"> output: &#123;</span><br><span class="line">    filename: &apos;[name].[hash].js&apos;,//main.24673fe716edfcec07a9.js</span><br><span class="line">    chunkFilename: &apos;[name].chunk.js&apos;, //commons~main.chunk.js 这里多了一个commons，是因为splitChunks的commons配置的，默认加commons</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line"> new HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: &apos;AICODER 全栈线下实习&apos;, // 默认值：Webpack App</span><br><span class="line">      filename: &apos;indexMyApp.html&apos;, // 默认值： &apos;index.html&apos;</span><br><span class="line">      template: path.resolve(__dirname, &apos;src/tempHtml.html&apos;),</span><br><span class="line">      minify: &#123;</span><br><span class="line">        collapseWhitespace: true,</span><br><span class="line">        removeComments: true, // 是否移除注释</span><br><span class="line">        removeAttributeQuotes: true // 移除属性的引号</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">  new MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: &apos;[name][hash].css&apos;, // main24673fe716edfcec07a9.css</span><br><span class="line">      chunkFilename: &apos;[id][hash].css&apos;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p><p>下面代码是entry为对象时，[name] 为entry的key值，下面的例子，[name]就是appIndex：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">  appIndex:&apos;./src/index.js&apos;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">              commons: &#123;</span><br><span class="line">                 chunks: &apos;initial&apos;,</span><br><span class="line">                 test: path.resolve(__dirname,&apos;node_modules&apos;),</span><br><span class="line">                 enforce: true,</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"> output: &#123;</span><br><span class="line">    filename: &apos;[name].[hash].js&apos;,//appIndex.90feeea169ea4a86288d.js</span><br><span class="line">    chunkFilename: &apos;[name].chunk.js&apos;, //commons~appIndex.chunk.js</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line"> new HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: &apos;AICODER 全栈线下实习&apos;, // 默认值：Webpack App</span><br><span class="line">      filename: &apos;indexMyApp.html&apos;, // 默认值： &apos;index.html&apos;</span><br><span class="line">      template: path.resolve(__dirname, &apos;src/tempHtml.html&apos;),</span><br><span class="line">      minify: &#123;</span><br><span class="line">        collapseWhitespace: true,</span><br><span class="line">        removeComments: true, // 是否移除注释</span><br><span class="line">        removeAttributeQuotes: true // 移除属性的引号</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">  new MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: &apos;[name][hash].css&apos;, // appIndex90feeea169ea4a86288d.css</span><br><span class="line">      chunkFilename: &apos;[id][hash].css&apos;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p><p>可在插件中自定义对应模块的[name]，例如定义splitChunks模块下name: ‘custom_chunkName’，他会覆盖entry中定义的name，由此splitChunks插件生成的文件将[name]值为custom_chunkName:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">entry: &#123;</span><br><span class="line">  appIndex:&apos;./src/index.js&apos;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">              commons: &#123;</span><br><span class="line">                 chunks: &apos;initial&apos;,</span><br><span class="line">                 test: path.resolve(__dirname,&apos;node_modules&apos;),</span><br><span class="line">                 enforce: true,</span><br><span class="line">                 name: &apos;custom_chunkName&apos;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"> output: &#123;</span><br><span class="line">    filename: &apos;[name].[hash].js&apos;,//appIndex.c81ab09b0bd828f71845.js</span><br><span class="line">    chunkFilename: &apos;[name].chunk.js&apos;, //customChunkNameQQ.chunk.js</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">  new MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: &apos;[name][hash].css&apos;, // appIndexc81ab09b0bd828f71845.css</span><br><span class="line">      chunkFilename: &apos;[id][hash].css&apos;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">//其他跟上面代码一样，只列与上不同的代码：</span><br></pre></td></tr></table></figure><p>当然你也可以直接通过filename定义splitChunks模块下输出文件的名字，这个优先级最高：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">  appIndex:&apos;./src/index.js&apos;</span><br><span class="line">&#125;,</span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">              commons: &#123;</span><br><span class="line">                 chunks: &apos;initial&apos;,</span><br><span class="line">                 test: path.resolve(__dirname,&apos;node_modules&apos;),</span><br><span class="line">                 enforce: true,</span><br><span class="line">                 name: &apos;customChunkNameQQ&apos;,</span><br><span class="line">                 filename: &apos;chunckNiceName.js&apos;,</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"> output: &#123;</span><br><span class="line">    filename: &apos;[name].[hash].js&apos;,//appIndex.c81ab09b0bd828f71845.js</span><br><span class="line">    chunkFilename: &apos;[name].chunk.js&apos;, //chunckNiceName.js</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">  new MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: &apos;[name][hash].css&apos;, // appIndexc81ab09b0bd828f71845.css</span><br><span class="line">      chunkFilename: &apos;[id][hash].css&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">//其他跟上面代码一样，只列与上不同的代码：</span><br></pre></td></tr></table></figure><p>关于[name]小结：<br>如果entry为字符串，name值默认为main；<br>如果entry以对象形式，name值为对象的key值；<br>各个插件(如css、js处理插件)可自定义本插件生成的js的文件名，或自定name值覆盖entry中定义的name值。</p><h4 id="id"><a href="#id" class="headerlink" title="[id]"></a>[id]</h4><p>这个最简单，[id]其实就是数字1,2,3,4…..；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    filename: &apos;[name].[hash].js&apos;,</span><br><span class="line">    chunkFilename: &apos;[id].chunk.js&apos;,</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><h4 id="hash"><a href="#hash" class="headerlink" title="[hash]"></a>[hash]</h4><p>这就是一个hash码，值得注意的是，每次build的hash值都是相同的，也就是打包完成后，js\css文件名的hash值都是相同的。<br>hash一个典型特征是，只有有一个文件改变，那么重新打包后hash值将变化，所以使用hash输出文件名的都将变化，<br>所以业务js，必须使用hash，而不能使用chunkhash。</p><h4 id="chunkhash-及-chunkhash-与-hash-的异同"><a href="#chunkhash-及-chunkhash-与-hash-的异同" class="headerlink" title="[chunkhash]及 [chunkhash]与[hash]的异同"></a>[chunkhash]及 [chunkhash]与[hash]的异同</h4><p>依赖库的源码，我们一般单独打包成一个库js，这个js必须使用chunkhash，<br>chunkhash的原则是只要chunkhash对应的模块文件不变，就算其他文件有变化了，重新打包了，改变的是hash值，chunkhash值保持不变。<br><strong>需特别注意的是，在一般情况下，修改文件和增加文件，webpack编译生成chunkhash的策略是不同的，上面所说的只适合修改文件的情况，如果增加文件或删除文件，就算库文件不变，还是会产生不同的chunkhash，原因在与webpack会根据总体文件，为每个文件设置一个index进行编译，增加或删除文件都会改变整体的index，从而导致chunkhash改变，为了防止这一情况，可配置webpack.HashedModuleIdsPlugin</strong><br>关于chunkhash的规则，更多请看章节3.12:《构建与性能优化 之 webpack.HashedModuleIdsPlugin》<br>对于 chunkhash与HashedModuleIdsPlugin 看参看 <a href="https://www.cnblogs.com/zhishaofei/p/8590627.html" target="_blank" rel="noopener">这里</a><br><strong>所以为了利用http缓存，对于依赖源码库js，必须使用chunkhash，业务js必须使用hash，否则将失去库与业务代码分离的意义</strong></p><h3 id="关于chunkFilename"><a href="#关于chunkFilename" class="headerlink" title="关于chunkFilename"></a>关于chunkFilename</h3><p>chunkFilename是用来配置无入口的chunk输出的名字的。<br>1.代码如下，进行打包；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    appIndex:&apos;./src/index.js&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mode: &apos;production&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &apos;[name].[hash].js&apos;,</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        commons: &#123;</span><br><span class="line">           chunks: &apos;initial&apos;,</span><br><span class="line">           test: path.resolve(__dirname,&apos;node_modules&apos;),</span><br><span class="line">           enforce: true,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>打包后生成：<br><figure class="image-box">                <img src="/image/webpack/chunkfilename1.png" alt="" title="" class="">                <p></p>            </figure><br>因为splitChunks.cacheGroups.commons没有定义name，所以输出文件，默认加 commons~….js;</p><p>2.与1其他配置不变，加上name，再打包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">    cacheGroups: &#123;</span><br><span class="line">      commons: &#123;</span><br><span class="line">        ...</span><br><span class="line">         name: &apos;lodashAndAxios&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>打包后生成，我们发现，这个分离出来的代码块，用的是output.filename的配置：<br><figure class="image-box">                <img src="/image/webpack/chunkfilename2.png" alt="" title="" class="">                <p></p>            </figure></p><p>3.与2其他配置不变，加上chunkfilename，再打包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    ...</span><br><span class="line">    chunkFilename: &apos;[name]._chunk_[chunkhash].js&apos;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>打包后生成，我们发现，这个分离出来的代码块，用的是output.chunkFilename的配置：<br><figure class="image-box">                <img src="/image/webpack/chunkfilename3.png" alt="" title="" class="">                <p></p>            </figure></p><p>这单独分离的代码，在entry中没有入口，只通过splitChunks.cacheGroups.test进行匹配，所以chunkFilename 是用来配置没有入口的名称的，<br>如果不配置chunkFilename，将会根据filename输出。不配置splitChunks.cacheGroups.name，会给输出文件名默认加commons~</p><h3 id="chunk的名称"><a href="#chunk的名称" class="headerlink" title="chunk的名称"></a>chunk的名称</h3><p>chunk的名称和entry的配置有关；</p><ul><li>如果entry是一个string或array，只会生成一个chunk，这是的chunk的名称就是main；</li><li>如果entry是一个Object，就可能会出现多个chunk,这时chunk的名称是Object键值对中健的名称。</li></ul><h3 id="从代码分离看chunk与minChunks"><a href="#从代码分离看chunk与minChunks" class="headerlink" title="从代码分离看chunk与minChunks"></a>从代码分离看chunk与minChunks</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">  a: &apos;./path/to/my/entry/file.js&apos;,</span><br><span class="line">  b: &apos;./path/to/my/entry/app.js&apos;,</span><br><span class="line">&#125;</span><br><span class="line">optimization: &#123;</span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">    cacheGroups: &#123;</span><br><span class="line">      commons: &#123;</span><br><span class="line">        &lt;!-- 如果不指定chunks，将会从现有的所有chunk中提取公共代码 --&gt;</span><br><span class="line">         chunks: [&apos;a&apos;,&apos;b&apos;],//a、b是entry中的两个chunk，从a，b中抽取公共的代码，最终会形成一个名字为appCommon的js，和a.js和b.js</span><br><span class="line">         name: &apos;appCommon&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个参数是minChunks，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">minChunks = 2;</span><br><span class="line">chunks = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;]</span><br></pre></td></tr></table></figure></p><p>只要在abcde模块中任意两个模块出现了公共代码的，都被提取。<br>minChunks主要应对，很可能abcde没有一个公共代码，在所有模块中都有的情况。</p><h3 id="dev模式禁chunkhash"><a href="#dev模式禁chunkhash" class="headerlink" title="dev模式禁chunkhash"></a>dev模式禁chunkhash</h3><p>在dev模式下，只能用hash，不能使用chunkhash，否则报错。</p><h3 id="模块解析规则与resolve"><a href="#模块解析规则与resolve" class="headerlink" title="模块解析规则与resolve"></a>模块解析规则与resolve</h3><h4 id="解析相对路径"><a href="#解析相对路径" class="headerlink" title="解析相对路径"></a>解析相对路径</h4><ul><li>查找相对当前模块的路径下是否有对应文件或文件夹</li><li>是文件则直接加载</li><li>是文件夹则继续查找文件夹下的 package.json 文件</li><li>有 package.json 文件则按照文件中 main 字段的文件名来查找文件</li><li>无 package.json 或者无 main 字段则查找 index.js 文件<h4 id="解析模块名"><a href="#解析模块名" class="headerlink" title="解析模块名"></a>解析模块名</h4>查找当前文件目录下，父级目录及以上目录下的 node_modules 文件夹，看是否有对应名称的模块<h4 id="解析绝对路径（不建议使用）"><a href="#解析绝对路径（不建议使用）" class="headerlink" title="解析绝对路径（不建议使用）"></a>解析绝对路径（不建议使用）</h4>直接查找对应路径的文件</li></ul><p>在 webpack 配置中，和模块路径解析相关的配置都在 resolve 字段下。</p><h4 id="resolve-常用配置："><a href="#resolve-常用配置：" class="headerlink" title="resolve 常用配置："></a>resolve 常用配置：</h4><p>module.exports = {<br>   resolve: {<br>      alias: { // 配置别名<br>         utils: path.resolve(<strong>dirname, ‘src/utils’), // 模糊匹配，意味着只要模块路径中携带utils 就可以被替换掉<br>         component$: path.resolve(</strong>dirname, ‘src/component’) // 只会匹配 import ‘component’， 这是精确匹配方法。<br>      },<br>      modules: [<br>        path.resolve(__dirname, ‘node_modules’), // 指定当前目录下的 node_modules 优先查找<br>        ‘node_modules’, // 如果有一些类库是放在一些奇怪的地方的，你可以添加自定义的路径或者目录<br>      ],<br>      mainFiles: [‘index’], //当目录下没有 package.json 文件时，我们说会默认使用目录下的 index.js 这个文件,就是这个字段配置的。// 你可以添加其他默认使用的文件名<br>      extensions: [“.js”, “.vue”, “.json”] // 默认值: [“.js”,”.json”]  模块名字可以省略的后缀名<br>  },<br>}</p><h3 id="loader的规则条件配置"><a href="#loader的规则条件配置" class="headerlink" title="loader的规则条件配置"></a>loader的规则条件配置</h3><p>大多数情况下，配置 loader 的匹配条件时，只要使用 test 字段就好了，很多时候都只需要匹配文件后缀名来决定使用什么 loader，但也不排除在某些特殊场景下，我们需要配置比较复杂的匹配条件。webpack 的规则提供了多种配置形式：</p><ul><li>{ test: … } 匹配特定条件</li><li>{ include: … } 匹配特定路径</li><li>{ exclude: … } 排除特定路径</li><li>{ and: […] }必须匹配数组中所有条件</li><li>{ or: […] } 匹配数组中任意一个条件</li><li><p>{ not: […] } 排除匹配数组中所有条件<br>上述的所谓条件的值可以是：</p></li><li><p>字符串：必须以提供的字符串开始，所以是字符串的话，这里我们需要提供绝对路径</p></li><li>正则表达式：调用正则的 test 方法来判断匹配</li><li>函数：(path) =&gt; boolean，返回 true 表示匹配</li><li>数组：至少包含一个条件的数组</li><li>对象：匹配所有属性值的条件</li></ul><h3 id="关于output"><a href="#关于output" class="headerlink" title="关于output"></a>关于output</h3><p>单个入口是配置方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const config = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: &apos;./path/to/my/entry/file.js&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const config = &#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &apos;bundle.js&apos;,</span><br><span class="line">    path: &apos;/home/proj/public/assets&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>多个入口时配置方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: &apos;./src/app.js&apos;,</span><br><span class="line">    search: &apos;./src/search.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &apos;[name].js&apos;,//多个时，用占位符[name]的方式定义</span><br><span class="line">    path: __dirname + &apos;/dist&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="css-js是怎么嵌入html"><a href="#css-js是怎么嵌入html" class="headerlink" title="css\js是怎么嵌入html"></a>css\js是怎么嵌入html</h3><p>无论output出来一个或多个js，html-webpack-plugin都会将js、css嵌入到html内：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">new HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: &apos;AICODER 全栈线下实习&apos;, // 默认值：Webpack App</span><br><span class="line">      filename: &apos;indexMyApp.html&apos;, // 默认值： &apos;index.html&apos;</span><br><span class="line">      template: path.resolve(__dirname, &apos;src/tempHtml.html&apos;),</span><br><span class="line">      minify: &#123;</span><br><span class="line">        collapseWhitespace: true,</span><br><span class="line">        removeComments: true, // 是否移除注释</span><br><span class="line">        removeAttributeQuotes: true // 移除属性的引号</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br></pre></td></tr></table></figure></p><h3 id="模板index-html的ejs写法与html-webpack-plugin配合"><a href="#模板index-html的ejs写法与html-webpack-plugin配合" class="headerlink" title="模板index.html的ejs写法与html-webpack-plugin配合"></a>模板index.html的ejs写法与html-webpack-plugin配合</h3><p>模板文件index.html可以写ejs，ejs语法允许写js，然后每行用&lt;%= %&gt;包起来即可:<br><figure class="image-box">                <img src="/image/webpack/tpl1.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/tpl2.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/tpl3.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/tpl4.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/tpl5.png" alt="" title="" class="">                <p></p>            </figure></p><p>注意：1.当有需求把一个js放在html 的header上，一个在body上时，可以定义模板script引用，此时必须设置inject为fasle，表示不适用插件默认嵌入。<br>2.上面ejs模板上一定要写成htmlWebpackPlugin，否则undefined，目前不知道为什么写成HtmlWebpackPlugin就可以关联到插件html-webpack-plugin</p><h3 id="多页面html的配置打包"><a href="#多页面html的配置打包" class="headerlink" title="多页面html的配置打包"></a>多页面html的配置打包</h3><p>要生成多个html，就需要在webpack.config.js中多配置几次new  html-webpack-plugin<br><figure class="image-box">                <img src="/image/webpack/mutilPage1.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/mutilPage2.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/mutilPage3.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/mutilPage4.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/mutilPage5.png" alt="" title="" class="">                <p></p>            </figure></p><h3 id="autoprefixer-配置-postcss-loader"><a href="#autoprefixer-配置-postcss-loader" class="headerlink" title="autoprefixer 配置 (postcss-loader)"></a>autoprefixer 配置 (postcss-loader)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">要生成多个html，就需要在webpack.config.js中多配置几次new  html-webpack-plugin</span><br><span class="line">&#123;</span><br><span class="line">  loader: &apos;postcss-loader&apos;,</span><br><span class="line">  options: &#123;</span><br><span class="line">    ident: &apos;postcss&apos;,</span><br><span class="line">    sourceMap: true,</span><br><span class="line">    //根据中国使用浏览器情况统计，兼容使用率大于百分之0.15的所有浏览器</span><br><span class="line">    plugins: (loader) =&gt; [require(&apos;autoprefixer&apos;)(&#123;browsers: [&apos;&gt; 0.15% in CN&apos;]&#125;)]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">browsers: [&apos;&gt; 5% in US&apos;] //根据美国使用浏览器情况统计，兼容使用率大于百分之5的所有浏览器</span><br><span class="line">browsers: [&apos;last 5 versions&apos;] //兼容所有浏览器最新的五个版本</span><br></pre></td></tr></table></figure><p><a href="https://github.com/browserslist/browserslist#best-practices" target="_blank" rel="noopener">点击查看更多</a></p><h3 id="html内img图片引用路径"><a href="#html内img图片引用路径" class="headerlink" title="html内img图片引用路径"></a>html内img图片引用路径</h3><p>在html或ejs模板文件，此时如果写绝对路径引用图片是没问题的，如果要使用相对路径，就必须使用require，<br>这是index.html文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> &lt;div class=img&gt;</span><br><span class="line">     &lt;img src=&quot;$&#123; require(&apos;./assets/img/WechatIMG92.jpeg&apos;) &#125;&quot;  alt=&quot;标志&quot; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>这是ejs模板文件：<br><figure class="image-box">                <img src="/image/webpack/htmltpl.png" alt="" title="" class="">                <p></p>            </figure><br>不过在项目中，所以类型的，对图片的引用，使用绝对路径都没问题，只有使用相对路径才会有以上问题。<br>不过在css中，引用图片，使用相对路径和绝对路径都没问题。</p><h3 id="给图片指定生成目录"><a href="#给图片指定生成目录" class="headerlink" title="给图片指定生成目录"></a>给图片指定生成目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: /\.(png|svg|jpg|gif|jpeg)$/,</span><br><span class="line">        include: [path.resolve(__dirname, &apos;src/&apos;)],</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &apos;url-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: 10000,</span><br><span class="line">              //name既可以定义文件名字，也可以定义css生成路径，占位符[ext]是扩展externals的简写指图片扩展名</span><br><span class="line">              name: &apos;image/[name]_image.[ext]&apos;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="带ejs的入口index-html模板文件示例"><a href="#带ejs的入口index-html模板文件示例" class="headerlink" title="带ejs的入口index.html模板文件示例"></a>带ejs的入口index.html模板文件示例</h3><p>对ejs的一点解释</p><ol><li>&lt;%  %&gt; 不输出显示到浏览器上的写法，专门用来运算js；</li><li>&lt;%=  %&gt; 加了一个=后，输出显示到浏览器上的写法；<br>完整示例看 看<a href="https://github.com/YeWills/webpack-code/tree/ejsHtml" target="_blank" rel="noopener">github 仓库中的 ejsHtml 分支 demo </a>，对应的tag发布版本为ejsHtmlV1.0</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">  &lt;script</span><br><span class="line">  src=&quot;https://code.jquery.com/jquery-3.1.0.js&quot;</span><br><span class="line">  integrity=&quot;sha256-slogkvB1K3VOkzAI8QITxV3VzpOnkeNVsKvtkYLMjfk=&quot;</span><br><span class="line">  crossorigin=&quot;anonymous&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"> &lt;% for (var key of htmlWebpackPlugin.files.css) &#123; %&gt;</span><br><span class="line">  &lt;link href=&quot;&lt;%= key %&gt;&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line"> &lt;% &#125; %&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;dmo&quot;&gt;我是模板文件自带的内容1&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;% for (var key in htmlWebpackPlugin.files) &#123; %&gt;</span><br><span class="line">        &lt;%= key %&gt; : &lt;%= JSON.stringify(htmlWebpackPlugin.files.css) %&gt;</span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=img&gt;</span><br><span class="line">      &lt;img src=&quot;$&#123; require(&apos;./assets/img/WechatIMG92.jpeg&apos;) &#125;&quot;  alt=&quot;标志&quot; /&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">  &lt;script</span><br><span class="line">  src=&quot;&lt;%= htmlWebpackPlugin.files.chunks.appIndex.entry %&gt;&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script</span><br><span class="line">  src=&quot;&lt;%= htmlWebpackPlugin.files.chunks.lodashAndAxios.entry %&gt;&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="两个横杠命令"><a href="#两个横杠命令" class="headerlink" title="两个横杠命令"></a>两个横杠命令</h3><p>webpack –devtool source-map;<br>发现凡是带两个–的命令，都是配置 webpack 的配置项。</p><h2 id="构建与性能优化"><a href="#构建与性能优化" class="headerlink" title="构建与性能优化"></a>构建与性能优化</h2><p>构建与性能优化很多思路受益于kangshen，膜拜下大神。</p><h3 id="升级到最新的webpack稳定版本"><a href="#升级到最新的webpack稳定版本" class="headerlink" title="升级到最新的webpack稳定版本"></a>升级到最新的webpack稳定版本</h3><p>这无疑是性能显著提升的</p><h3 id="babel-loader-的优化"><a href="#babel-loader-的优化" class="headerlink" title="babel-loader 的优化"></a>babel-loader 的优化</h3><p>把 loader 应用的文件范围缩小,也就是说，配置loader的include来限定查询范围<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rules: [ </span><br><span class="line">  &#123;</span><br><span class="line">    test: /\.jsx?/,</span><br><span class="line">    include: [ </span><br><span class="line">      path.resolve(__dirname, &apos;src&apos;), </span><br><span class="line">      // 限定只在 src 目录下的 js/jsx 文件需要经 babel-loader 处理</span><br><span class="line">      // 通常我们需要 loader 处理的文件都是存放在 src 目录</span><br><span class="line">    ],</span><br><span class="line">    use: &apos;babel-loader&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">  // ...</span><br><span class="line">],</span><br></pre></td></tr></table></figure></p><h4 id="设置exclude"><a href="#设置exclude" class="headerlink" title="设置exclude"></a>设置exclude</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  modules: [</span><br><span class="line">    path.resolve(__dirname, &apos;node_modules&apos;), // 使用绝对路径指定 node_modules，不做过多查询</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  // 删除不必要的后缀自动补全，少了文件后缀的自动匹配，即减少了文件路径查询的工作</span><br><span class="line">  // 其他文件可以在编码时指定后缀，如 import(&apos;./index.scss&apos;)</span><br><span class="line">  extensions: [&quot;.js&quot;], </span><br><span class="line"></span><br><span class="line">  // 避免新增默认文件，编码时使用详细的文件路径，代码会更容易解读，也有益于提高构建速度</span><br><span class="line">  mainFiles: [&apos;index&apos;],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="启用缓存"><a href="#启用缓存" class="headerlink" title="启用缓存"></a>启用缓存</h4><p>总代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: /\.js$/,</span><br><span class="line">    exclude: /(node_modules)/, // 加快编译速度，不包含node_modules文件夹内容</span><br><span class="line">    use: &#123;</span><br><span class="line">      loader: &apos;babel-loader&apos;,</span><br><span class="line">      options: &#123;</span><br><span class="line">        cacheDirectory: true // 启用缓存，提高编译速度，生成和开发都要如此设置</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="生产下库与业务js分离"><a href="#生产下库与业务js分离" class="headerlink" title="生产下库与业务js分离"></a>生产下库与业务js分离</h3><p>对于单页面应用 生产下库与业务js分离，可以利用浏览器http请求缓存机制，提高下一次访问速度。<br>对于多页面应用 生产下库与业务js分离，可以利用浏览器http请求缓存机制，提高访问下一页的速度。</p><p>更多详细库与业务js分离配置方法 请看 1.13章节 《webpack常用知识–分离 库与业务代码》</p><p>更多信息，看<a href="https://github.com/YeWills/webpack-code/tree/master" target="_blank" rel="noopener">demo示例</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        commons: &#123;</span><br><span class="line">           chunks: &apos;initial&apos;,</span><br><span class="line">           test: &apos;lodashAndAxios&apos;,</span><br><span class="line">           enforce: true,</span><br><span class="line">           name: &apos;lodashAndAxios&apos;,//对应覆盖entry.chunkFilename中的name占位符[name]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>optimization.splitChunks.cacheGroups.chunks也可以是函数，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        styles: &#123;</span><br><span class="line">           chunks: &apos;all&apos;,</span><br><span class="line">           test: /\.(sc|c|sa)ss$/,</span><br><span class="line">           enforce: true,</span><br><span class="line">           name: &apos;styles&apos;,//对应覆盖entry.chunkFilename中的name占位符[name]</span><br><span class="line">        &#125;,</span><br><span class="line">        commons: &#123;</span><br><span class="line">           chunks: (chunk) =&gt; &#123;</span><br><span class="line">             return chunk.name !== &apos;styles&apos;;//避开上面定义的styles chunk</span><br><span class="line">           &#125;,</span><br><span class="line">           test: &apos;lodashAndAxios&apos;,</span><br><span class="line">           enforce: true,</span><br><span class="line">           name: &apos;lodashAndAxios&apos;,//对应覆盖entry.chunkFilename中的name占位符[name]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="使用花括号-进行import"><a href="#使用花括号-进行import" class="headerlink" title="使用花括号{}进行import"></a>使用花括号{}进行import</h3><p>例如 使用lodash，推荐这种写法import { filter } from ‘lodash’;<br>用什么就花括号，取什么。</p><h3 id="依赖包和业务js分离"><a href="#依赖包和业务js分离" class="headerlink" title="依赖包和业务js分离"></a>依赖包和业务js分离</h3><p>一般依赖包如loadsh，jq这些很少改变，而一般只改变业务js，分开打包后，依赖包js文件名，每次发布版本都是一样的，<br>浏览器的http请求缓存机制，浏览器不会重复请求，直接拿浏览器缓存的依赖包js即可，可提高性能，减少流量。每次发布版本，<br>只需要请求业务js。</p><h3 id="设置外部依赖"><a href="#设置外部依赖" class="headerlink" title="设置外部依赖"></a>设置外部依赖</h3><p>将笨重的很多页面都用到的js通过externals设置成外部依赖。</p><h3 id="利用浏览器http缓解机制"><a href="#利用浏览器http缓解机制" class="headerlink" title="利用浏览器http缓解机制"></a>利用浏览器http缓解机制</h3><p>利用浏览器http缓解机制，库与js代码分离，可以提高速度，减少流量。(这个应该属于 项目性能优化范畴)</p><h3 id="autodll-webpack-plugin"><a href="#autodll-webpack-plugin" class="headerlink" title="autodll-webpack-plugin"></a>autodll-webpack-plugin</h3><p>该插件能够快速打包，能把第三方依赖的文件能提前进行预编译打包到一个文件里面去。提高了构建速度。因为很多第三方插件我们并不需要改动它，所以我们想这些第三方库在我们每次编译的时候不要再次构建它就好,可以非常明显提高rebuild速度<br>该插件有两个作用：<br>1、可以明显提高rebuild的速度；<br>2、可以调试库源码；</p><p>更多信息，看<a href="https://github.com/YeWills/webpack-code/tree/master" target="_blank" rel="noopener">demo示例</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const AutoDllPlugin = require(&apos;autodll-webpack-plugin&apos;);</span><br><span class="line"> new AutoDllPlugin(&#123;</span><br><span class="line">      filename: &apos;[name]_chunk.js&apos;,</span><br><span class="line">      // 如果需要调试库源码，将inherit设置为true，是调试源码的尖刀利器，不过会影响rebuild速度</span><br><span class="line">      inherit: false,//当为false时，速度更快；当为true时，可以打开webpack没有压缩过的源码sourcemap调试</span><br><span class="line">      inject: true,</span><br><span class="line">      debug: true,</span><br><span class="line">      entry: &#123;</span><br><span class="line">        appVendor: [</span><br><span class="line">          &apos;axios&apos;,</span><br><span class="line">          &apos;lodash&apos;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br></pre></td></tr></table></figure><h3 id="happypack"><a href="#happypack" class="headerlink" title="happypack"></a>happypack</h3><p>webpack 只能一个loader处理完后处理下一个loader，这样，速度就慢，为了同时进行多线程loader，同时处理多个loader，可以使用happypack；<br>配置happypack可以明显提高构建速度。</p><ul><li>其他的都好配置，就postcss-loader 比较特殊，必须要另外新建 postcss.config.js 否则报错；</li><li>happypack 重写原来loader配置时，基本上就是复制，不改变，只有postcss可能稍微改动下</li></ul><p>更多信息，看<a href="https://github.com/YeWills/webpack-code/tree/master" target="_blank" rel="noopener">demo示例</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const HappyPack = require(&apos;happypack&apos;);</span><br><span class="line"> module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(sc|c|sa)ss$/,</span><br><span class="line">        loader: &apos;happypack/loader?id=handerStyle&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"> new HappyPack(&#123;</span><br><span class="line">      id:&apos;handerStyle&apos;,</span><br><span class="line">      loaders:[</span><br><span class="line">        &apos;style-loader&apos;, </span><br><span class="line">        &#123;</span><br><span class="line">          loader: &apos;css-loader&apos;,</span><br><span class="line">          options: &#123;</span><br><span class="line">            sourceMap: true</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &apos;postcss-loader&apos;, </span><br><span class="line">        &#123;</span><br><span class="line">          loader: &apos;sass-loader&apos;,</span><br><span class="line">          options: &#123;</span><br><span class="line">            sourceMap: true</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//postcss.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  ident: &apos;postcss&apos;,</span><br><span class="line">  sourceMap: true,</span><br><span class="line">  plugins: &#123;</span><br><span class="line">    &apos;autoprefixer&apos;: &#123;</span><br><span class="line">      browsers: [&apos;&gt; 0.15% in CN&apos;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="webpack-parallel-uglify-plugin"><a href="#webpack-parallel-uglify-plugin" class="headerlink" title="webpack-parallel-uglify-plugin"></a>webpack-parallel-uglify-plugin</h3><p>生产环境配置。<br>happypack是多线程操作loader进行多线程转译文件；与此相似，webpack-parallel-uglify-plugin是多线程进行压缩js，提高生产环境下的打包速度。<br>更多信息，看<a href="https://github.com/YeWills/webpack-code/tree/master" target="_blank" rel="noopener">demo示例</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    // 使用 ParallelUglifyPlugin 并行压缩输出JS代码</span><br><span class="line">    new ParallelUglifyPlugin(&#123;</span><br><span class="line">      // 传递给 UglifyJS的参数如下：</span><br><span class="line">      uglifyJS: &#123;</span><br><span class="line">        output: &#123;</span><br><span class="line">          /*</span><br><span class="line">           是否输出可读性较强的代码，即会保留空格和制表符，默认为输出，为了达到更好的压缩效果，</span><br><span class="line">           可以设置为false</span><br><span class="line">          */</span><br><span class="line">          beautify: false,</span><br><span class="line">          /*</span><br><span class="line">           是否保留代码中的注释，默认为保留，为了达到更好的压缩效果，可以设置为false</span><br><span class="line">          */</span><br><span class="line">          comments: false</span><br><span class="line">        &#125;,</span><br><span class="line">        compress: &#123;</span><br><span class="line">          /*</span><br><span class="line">           是否在UglifyJS删除没有用到的代码时输出警告信息，默认为输出，可以设置为false关闭这些作用</span><br><span class="line">           不大的警告</span><br><span class="line">          */</span><br><span class="line">          warnings: false,</span><br><span class="line"></span><br><span class="line">          /*</span><br><span class="line">           是否删除代码中所有的console语句，默认为不删除，开启后，会删除所有的console语句</span><br><span class="line">          */</span><br><span class="line">          drop_console: true,</span><br><span class="line"></span><br><span class="line">          /*</span><br><span class="line">           是否内嵌虽然已经定义了，但是只用到一次的变量，比如将 var x = 1; y = x, 转换成 y = 5, 默认为不</span><br><span class="line">           转换，为了达到更好的压缩效果，可以设置为false</span><br><span class="line">          */</span><br><span class="line">          collapse_vars: true,</span><br><span class="line"></span><br><span class="line">          /*</span><br><span class="line">           是否提取出现了多次但是没有定义成变量去引用的静态值，比如将 x = &apos;xxx&apos;; y = &apos;xxx&apos;  转换成</span><br><span class="line">           var a = &apos;xxxx&apos;; x = a; y = a; 默认为不转换，为了达到更好的压缩效果，可以设置为false</span><br><span class="line">          */</span><br><span class="line">          reduce_vars: true</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="ContextReplacementPlugin"><a href="#ContextReplacementPlugin" class="headerlink" title="ContextReplacementPlugin"></a>ContextReplacementPlugin</h3><p>配置ContextReplacementPlugin，是优化配置，下面章节《其他常用插件》有讲</p><h3 id="webpack-HashedModuleIdsPlugin"><a href="#webpack-HashedModuleIdsPlugin" class="headerlink" title="webpack.HashedModuleIdsPlugin"></a>webpack.HashedModuleIdsPlugin</h3><p>打包中chunkhash的规则：<br>当没有删除或增加文件，如果对于chunk的代码没有变化，chunkhash值不会变，可以起到浏览器缓存的作用；<br>但当有删除或增加文件是，如果对应chunk的代码没有变化，打包是，chunkhash还是会变，这不是我们想要的结果，我们只希望对应chunk代码如果没变化，<br>无论其他代码文件删除或增加，chunkhash都不变。<br>（为什么会变，webpack自带打包策略是给每个文件配置了一个数字index，无论增加或删除一个文件，都会打乱整个 index，导致chunkhash变化，<br>HashedModuleIdsPlugin，改变策略为，根据文件路径配置，所以达到了稳定chunkhash）<br>为了达到以上效果，请配置HashedModuleIdsPlugin插件：<br>new webpack.HashedModuleIdsPlugin({<br>  hashDigestLength：20<br>})</p><p>该插件会根据模块的相对路径生成一个四位数的hash作为模块id, 建议用于生产环境。<br>用 HashedModuleIdsPlugin 可以轻松地实现 chunkhash 的稳定化，可以实现持久化缓存。<br>建议生产配置使用，如果使用到了chunkhash，则最好配置HashedModuleIdsPlugin。<br>更多请看章节2.7.4:《webpack 黑知识 之 [name][id][hash][chunkhash][name]》<br>或看官网<br>对于 chunkhash与HashedModuleIdsPlugin 看参看 <a href="https://www.cnblogs.com/zhishaofei/p/8590627.html" target="_blank" rel="noopener">这里</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  new webpack.HashedModuleIdsPlugin(&#123;</span><br><span class="line">    hashDigestLength: 20</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="webpack-NormalModuleReplacementPlugin"><a href="#webpack-NormalModuleReplacementPlugin" class="headerlink" title="webpack.NormalModuleReplacementPlugin"></a>webpack.NormalModuleReplacementPlugin</h3><p>webpack.NormalModuleReplacementPlugin(a,b)编译时，第一个参数通常是正则，第一个参数正则匹配到文件后，会将此文件替换为第二个参数，从而达到生产或开发时，编译不同文件的目的，比如生产和开发时编译不同的路由文件。<br>所以配置时，在webpack.config.plugins中，位于最前面，保证webpack执行编译时，首先启用此插件替换文件。<br>注意的是，此插件的第一个参数一般都设置为正则。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">  new webpack.NormalModuleReplacementPlugin(</span><br><span class="line">    /some\/path\/config\.development\.js/,</span><br><span class="line">    &apos;./config.production.js&apos;</span><br><span class="line">  ),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="webpack-optimize-OccurrenceOrderPlugin"><a href="#webpack-optimize-OccurrenceOrderPlugin" class="headerlink" title="webpack.optimize.OccurrenceOrderPlugin"></a>webpack.optimize.OccurrenceOrderPlugin</h3><p>OccurrenceOrderPlugin插件：根据出现次数为每一个模块或者chunk设置id,经常使用的模块则会获取到较短的id(和前缀树类似)，这可以使id可预测并有效减少文件大小，建议使用在生产环境中～<br><a href="https://www.cnblogs.com/xuepei/p/7992423.html" target="_blank" rel="noopener">参考</a><br>有些说是可以优化排序输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">  new webpack.optimize.OccurrenceOrderPlugin(),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="webpack-optimize-AggressiveMergingPlugin"><a href="#webpack-optimize-AggressiveMergingPlugin" class="headerlink" title="webpack.optimize.AggressiveMergingPlugin"></a>webpack.optimize.AggressiveMergingPlugin</h3><p>AggressiveMergingPlugin用于合并块。<br>AggressiveMergingPlugin用于解决如路由分配不合理，会打包出很多很小的文件，每个文件或许只有几k，却多了很多网络请求，得不偿失。<br>用法很简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">  new webpack.optimize.AggressiveMergingPlugin(),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="react-loadable-懒加载优化生产模式构建速度以及页面访问速度"><a href="#react-loadable-懒加载优化生产模式构建速度以及页面访问速度" class="headerlink" title="react-loadable 懒加载优化生产模式构建速度以及页面访问速度"></a>react-loadable 懒加载优化生产模式构建速度以及页面访问速度</h3><p>这条优化经验受kangshen启发，表示对大神的膜拜，具体思路是：<br>利用react-loadable懒加载，将生产模式下的路由配合react-loadable懒加载，显示哪个路由页面，就编译加载某个路由页面，这样既提高webpack编译速度，又提高页面访问速度。<br>将路由进行懒加载有一个弊端是只能看到你打开页面的报错，没有打开的页面报错你无法看到。</p><p>react-loadable 是2017年5月左右才出现，到如今，GitHub上已经有一万多颗star，是可以比拟react-redux的插件，非常棒，项目中如果有用到懒加载，用这个框架非常好react-loadable</p><h3 id="减少不必要的plugin"><a href="#减少不必要的plugin" class="headerlink" title="减少不必要的plugin"></a>减少不必要的plugin</h3><h2 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h2><h3 id="ContextReplacementPlugin-1"><a href="#ContextReplacementPlugin-1" class="headerlink" title="ContextReplacementPlugin"></a>ContextReplacementPlugin</h3><p>当项目用到moment时，务必使用此插件，可减少打包体积，以下代码为例，匹配moment/locale路径，只加载编译此路径下的/zh-cn|zh-hk|en/的文件。<br>new webpack.ContextReplacementPlugin(/moment[/\]locale$/, /zh-cn|zh-hk|en/)</p><h3 id="webpack-NormalModuleReplacementPlugin-1"><a href="#webpack-NormalModuleReplacementPlugin-1" class="headerlink" title="webpack.NormalModuleReplacementPlugin"></a>webpack.NormalModuleReplacementPlugin</h3><p>用法请看章节《构建与性能优化》</p><h3 id="webpack-DefinePlugin"><a href="#webpack-DefinePlugin" class="headerlink" title="webpack.DefinePlugin"></a>webpack.DefinePlugin</h3><p>此插件定义值时，都需加JSON.stringify。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    new webpack.DefinePlugin(&#123;</span><br><span class="line">      &apos;process.env.ASSET_PATH&apos;: JSON.stringify(&quot;5fa3b9&quot;),</span><br><span class="line">      &apos;process.env.FLAG&apos;: JSON.stringify(true)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p><h3 id="ProvidePlugin"><a href="#ProvidePlugin" class="headerlink" title="ProvidePlugin"></a>ProvidePlugin</h3><p>配置全局变量，自动加载模块，不必到处import或require：<br>例如设置$为全局变量，指向jq。<br>new webpack.ProvidePlugin({<br>  $: ‘jquery’,<br>  jQuery: ‘jquery’<br>})</p><h3 id="webpack-optimize-OccurrenceOrderPlugin-1"><a href="#webpack-optimize-OccurrenceOrderPlugin-1" class="headerlink" title="webpack.optimize.OccurrenceOrderPlugin"></a>webpack.optimize.OccurrenceOrderPlugin</h3><p>用法请看章节《构建与性能优化》</p><h3 id="happypack-1"><a href="#happypack-1" class="headerlink" title="happypack"></a>happypack</h3><p>用法请看章节《构建与性能优化》</p><h3 id="AutoDllPlugin"><a href="#AutoDllPlugin" class="headerlink" title="AutoDllPlugin"></a>AutoDllPlugin</h3><p>用法请看章节《构建与性能优化》</p><h3 id="webpack-parallel-uglify-plugin-1"><a href="#webpack-parallel-uglify-plugin-1" class="headerlink" title="webpack-parallel-uglify-plugin"></a>webpack-parallel-uglify-plugin</h3><p>用法请看章节《构建与性能优化》</p><h3 id="webpack-HashedModuleIdsPlugin-1"><a href="#webpack-HashedModuleIdsPlugin-1" class="headerlink" title="webpack.HashedModuleIdsPlugin"></a>webpack.HashedModuleIdsPlugin</h3><p>用法请看章节《构建与性能优化》</p><h3 id="webpack-optimize-AggressiveMergingPlugin-1"><a href="#webpack-optimize-AggressiveMergingPlugin-1" class="headerlink" title="webpack.optimize.AggressiveMergingPlugin"></a>webpack.optimize.AggressiveMergingPlugin</h3><p>用法请看章节《构建与性能优化》</p><h2 id="webpack-版本变化"><a href="#webpack-版本变化" class="headerlink" title="webpack 版本变化"></a>webpack 版本变化</h2><h3 id="css分离插件"><a href="#css分离插件" class="headerlink" title="css分离插件"></a>css分离插件</h3><p>webpack4.x弃用了extract-text-webpack-plugin，使用mini-css-extract-plugin代替，来做css从html中分离单独成一个css文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">const MiniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;);</span><br><span class="line"> module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(sc|c|sa)ss$/,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader, &#123;</span><br><span class="line">            loader: &apos;css-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;postcss-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              ident: &apos;postcss&apos;,</span><br><span class="line">              sourceMap: true,</span><br><span class="line">              plugins: (loader) =&gt; [require(&apos;autoprefixer&apos;)(&#123;browsers: [&apos;&gt; 0.15% in CN&apos;]&#125;)]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;sass-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: &apos;[name][hash].css&apos;, // 设置最终输出的文件名</span><br><span class="line">      chunkFilename: &apos;[id][hash].css&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure></p><h3 id="webpack注意事项"><a href="#webpack注意事项" class="headerlink" title="webpack注意事项"></a>webpack注意事项</h3><ul><li>不要在生产环境下使用inline模式的source map，因为这会使js文件变得很大，而且会泄露源码。</li><li>尽量写全名称，扩展名也写上 const common = require(‘./webpack.common.js’);不要写成require(‘./webpack.common’)，不利于编译查询。</li><li>线上发布，或CDN优化配置，大部分与合理配置publicpath有关。</li></ul><h2 id="参考和学习资料"><a href="#参考和学习资料" class="headerlink" title="参考和学习资料"></a>参考和学习资料</h2><p><a href="https://ke.qq.com/course/321174" target="_blank" rel="noopener">老马全栈VIP2_02_webpack4配置入门到进阶</a><br><a href="https://www.imooc.com/learn/802" target="_blank" rel="noopener">webpack深入与实战</a><br><a href="https://www.imooc.com/learn/935" target="_blank" rel="noopener">Vue+Webpack打造todo应用</a><br>掘金小册-使用webpack定制前端开发环境<br>吴浩麟-深入浅出webpack<br><a href="https://www.webpackjs.com/plugins/hashed-module-ids-plugin/" target="_blank" rel="noopener">webpack 插件官网</a><br><a href="https://segmentfault.com/a/1190000007479892" target="_blank" rel="noopener">webpack学习系列</a><br><a href="https://www.mmxiaowu.com/article/58482332d4352863efb55465" target="_blank" rel="noopener">WebPack 终极配置说明</a><br><a href="https://github.com/YeWills/webpack-code/tree/master" target="_blank" rel="noopener">原创webpack demo 主要应用分支</a><br><a href="https://github.com/YeWills/webpack-code/tree/ejsHtml" target="_blank" rel="noopener">原创webpack demo 模板ejs语法分支</a><br><a href="https://github.com/YeWills/webpack-code/tree/webpack_custom_merge_demo" target="_blank" rel="noopener">原创webpack demo 自定义merge config分支</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
