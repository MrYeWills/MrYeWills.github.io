<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>node模块</title>
      <link href="/2019/03/30/node_module/"/>
      <url>/2019/03/30/node_module/</url>
      
        <content type="html"><![CDATA[<h2 id="node好用模块"><a href="#node好用模块" class="headerlink" title="node好用模块"></a>node好用模块</h2><h3 id="nodemon"><a href="#nodemon" class="headerlink" title="nodemon"></a>nodemon</h3><p>一款用于 使用node启动的项目，监听当项目文件变动时，自动启动类似npm start命令的模块。<br><a href="https://github.com/YeWills/koa-demo/tree/master" target="_blank" rel="noopener">demo示例</a></p><h4 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h4><p>使用非常简单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//package.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;koa-book-pro&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;server/index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;nodemon ./start.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;author&quot;: &quot;YeWills&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;MIT&quot;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;koa&quot;: &quot;^2.4.1&quot;,</span><br><span class="line">    &quot;koa-bodyparser&quot;: &quot;^4.2.1&quot;,</span><br><span class="line">    &quot;koa-router&quot;: &quot;^7.4.0&quot;,</span><br><span class="line">    &quot;koa-static&quot;: &quot;^5.0.0&quot;,</span><br><span class="line">    &quot;koa2-cors&quot;: &quot;^2.0.6&quot;,</span><br><span class="line">    &quot;nodemon&quot;: &quot;^1.18.10&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>package.json 同级目录下 配置 nodemon.json<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//nodemon.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;restartable&quot;: &quot;rs&quot;,</span><br><span class="line">  &quot;ignore&quot;: [</span><br><span class="line">    &quot;.git&quot;,</span><br><span class="line">    &quot;node_modules/**/node_modules&quot;,</span><br><span class="line">    &quot;README.md&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;verbose&quot;: true,</span><br><span class="line">  &quot;execMap&quot;: &#123;</span><br><span class="line">    &quot;js&quot;: &quot;node --harmony&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;watch&quot;: [</span><br><span class="line">    &quot;server/&quot;,</span><br><span class="line">    &quot;src/&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;ext&quot;: &quot;js json&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后用npm start 启动项目，files改变时，会自动npm start，非常好用。<br><a href="http://www.cnblogs.com/JuFoFu/p/5140302.html" target="_blank" rel="noopener">关于上面代码的解释</a><br>或自行查询GitHub官网</p><h4 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h4><p>以上代码注意的是:<br>nodemon.json 中 js属性配置了 node –harmony 命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;execMap&quot;: &#123;</span><br><span class="line">   &quot;js&quot;: &quot;node --harmony&quot;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure></p><p>那么请在 package.json中 start中，把node关键字去掉<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//正确配置</span><br><span class="line"> &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;nodemon ./start.js&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//错误配置 ，配置了多余的node</span><br><span class="line"> &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;nodemon node ./start.js&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
          <category> nodemon </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node node_modules </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>koa2笔记</title>
      <link href="/2019/03/29/koa2/"/>
      <url>/2019/03/29/koa2/</url>
      
        <content type="html"><![CDATA[<h2 id="koa2常用知识"><a href="#koa2常用知识" class="headerlink" title="koa2常用知识"></a>koa2常用知识</h2><h3 id="context的别名"><a href="#context的别名" class="headerlink" title="context的别名"></a>context的别名</h3><p><a href="https://koajs.com/#introduction" target="_blank" rel="noopener">更多参看 官网 Request aliases Response aliases</a><br>摘录部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//Request aliases 下面的简写，都指的是Request</span><br><span class="line">ctx.url  -- ctx.request.url 的别名</span><br><span class="line">ctx.method  -- ctx.request.method 的别名</span><br><span class="line">ctx.header</span><br><span class="line">ctx.path</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//Response aliases 下面的简写，都指的是Request</span><br><span class="line">ctx.body  -- ctx.response.body 的别名</span><br><span class="line">ctx.status  -- ctx.response.status 的别名</span><br></pre></td></tr></table></figure><p>另外 ctx.req 是 ctx.request 的别名；<br>另外 ctx.res 是 ctx.response 的别名；</p><h3 id="POST请求参数的获取"><a href="#POST请求参数的获取" class="headerlink" title="POST请求参数的获取"></a>POST请求参数的获取</h3><p>koa 没有封装获取post请求参数的方法，要么通过ctx.req.on原生方式，要么通过koa-bodyparser</p><h4 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h4><p>使用ctx.req.on原生方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">app.use(async (ctx)=&gt;&#123;</span><br><span class="line">  let postdata=&apos;&apos;;</span><br><span class="line">  ctx.req.on(&apos;data&apos;, (data)=&gt;&#123;</span><br><span class="line">    postdata +=data;</span><br><span class="line">  &#125;)</span><br><span class="line">  ctx.req.on(&apos;end&apos;, ()=&gt;&#123;</span><br><span class="line">    console.log(postdata);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 另起一个git bash 窗口执行以下命令，注意，</span><br><span class="line">//一定用git bash， 因为cmd 没有curl命令</span><br><span class="line">curl -d &quot;param1=abc&amp;param2=qqw&quot; http://localhost:3000/</span><br><span class="line"></span><br><span class="line">// 在npm start 所在的cmd或git bash窗口，会出现 打印：</span><br><span class="line">//param1=abc&amp;param2=qqw</span><br></pre></td></tr></table></figure></p><h4 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h4><p>使用koa-bodyparser方式。koa-bodyparser的底层也是使用ctx.req.on实现的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;)</span><br><span class="line">const bodyparser = require(&apos;koa-bodyparser&apos;)</span><br><span class="line">const app = new Koa()</span><br><span class="line">app.use(bodyparser())</span><br><span class="line">app.use(async (ctx, next)=&gt;&#123;</span><br><span class="line">  let postData = ctx.request.body;</span><br><span class="line">  console.log(postData);</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(3000)</span><br><span class="line"></span><br><span class="line">// 另起一个git bash 窗口执行以下命令，</span><br><span class="line">curl -d &quot;param1=abc&amp;param2=qqw&quot; http://localhost:3000/</span><br><span class="line"></span><br><span class="line">// 在npm start 所在的cmd或git bash窗口，会出现 打印：</span><br><span class="line">//&#123; param1: &apos;abc&apos;, param2: &apos;qqw&apos; &#125;</span><br></pre></td></tr></table></figure></p><h3 id="有关content-type"><a href="#有关content-type" class="headerlink" title="有关content-type"></a>有关content-type</h3><h4 id="先来看一个实例demo，感受下："><a href="#先来看一个实例demo，感受下：" class="headerlink" title="先来看一个实例demo，感受下："></a>先来看一个实例demo，感受下：</h4><p>前端代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fetch(&apos;http://127.0.0.1:3000/test&apos;, &#123;</span><br><span class="line">    method: &apos;GET&apos;, // or &apos;PUT&apos;</span><br><span class="line">    headers: new Headers(&#123;</span><br><span class="line">      &apos;Content-Type&apos;: &apos;image/png&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(res =&gt; res.text())</span><br><span class="line">  .catch(error =&gt; console.error(&apos;Error:&apos;, error))</span><br><span class="line">  .then(response =&gt; console.log(&apos;Success:&apos;, response));</span><br></pre></td></tr></table></figure></p><p>后台代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;)</span><br><span class="line">const bodyparser = require(&apos;koa-bodyparser&apos;)</span><br><span class="line">var cors = require(&apos;koa2-cors&apos;);</span><br><span class="line"></span><br><span class="line">const app = new Koa()</span><br><span class="line">app.use(cors());</span><br><span class="line">app.use(bodyparser())</span><br><span class="line">app.use(async (ctx, next)=&gt;&#123;</span><br><span class="line">  ctx.response.type=&apos;text&apos;;</span><br><span class="line">  ctx.response.body=&apos;&lt;p/&gt;999&lt;p/&gt;&apos;;</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(3000)</span><br></pre></td></tr></table></figure></p><p>页面响应：<br><figure class="image-box">                <img src="/image/koa2/content-type.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/koa2/content-res.png" alt="" title="" class="">                <p></p>            </figure></p><p>后续操作：</p><ul><li>当切换设置不同的ctx.response.type=’text’;对应的Response Header 的 Content-type随之改变</li></ul><h4 id="另外一个实验："><a href="#另外一个实验：" class="headerlink" title="另外一个实验："></a>另外一个实验：</h4><p>前端代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fetch(&apos;http://127.0.0.1:3000/test&apos;, &#123;</span><br><span class="line">  method: &apos;GET&apos;,</span><br><span class="line">  headers: new Headers(&#123;</span><br><span class="line">    &apos;Content-Type&apos;: &apos;image/png&apos;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">.then(res =&gt; res.json())</span><br><span class="line">.catch(error =&gt; console.error(&apos;Error:&apos;, error))</span><br><span class="line">.then(response =&gt; console.log(&apos;Success:&apos;, response));</span><br></pre></td></tr></table></figure></p><p>后台代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;)</span><br><span class="line">const bodyparser = require(&apos;koa-bodyparser&apos;)</span><br><span class="line">var cors = require(&apos;koa2-cors&apos;);</span><br><span class="line"></span><br><span class="line">const app = new Koa()</span><br><span class="line">app.use(cors());</span><br><span class="line">app.use(bodyparser())</span><br><span class="line">app.use(async (ctx, next)=&gt;&#123;</span><br><span class="line">  ctx.response.type=&apos;html&apos;;</span><br><span class="line">  ctx.response.body=&#123;data:&apos;Hello World&apos;&#125;;</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(3000)</span><br></pre></td></tr></table></figure></p><p>发现的现象：</p><ul><li>设置不同的ctx.response.type=’html’时，Response Header 的 Content-type没有随之改变，还是显示为application/json</li><li>后台ctx.response.body={data:’Hello World’};改成  ctx.response.body=’<html>‘;<br>前台代码不变，发现res.json()解析报错，Unexpected token &lt; in JSON at position 0，<br>将res.json改成res.text就好了</html></li><li>后端实际的数据是json数据(ctx.response.body={data:’Hello World’})，但设置 ctx.response.type=’html’;然而并不影响前台通过res.json()正常解析到正确数据；</li><li>后端实际的数据是json数据(ctx.response.body={data:’Hello World’})，虽然前端设置了自定义Header content-type为image/png，但不影响前端正常解析，前端一样能正常获取数据。</li></ul><h4 id="得出结论："><a href="#得出结论：" class="headerlink" title="得出结论："></a>得出结论：</h4><p>结合上面页面响应的图片中：</p><ul><li>一个请求，有两个content-type,分别是Response Header 和 Request Header上的。</li><li>小区别是 Response Header 的是首字母大写的 Content-type ，Request Header 的是首字母小写的 content-type;</li><li>fetch 的 headers: new Headers({‘Content-Type’: ‘image/png’}) 设置的是 Request Header 的 content-type；</li><li>Response Header 的 Content-type 是 原则上是ctx.response.type控制设置的，但如上例，有时Response Header 的 Content-type 是 浏览器或koa自动识别ctx.response.body数据类型设置的。</li><li>fetch要想正确解析数据，需要根据后台实际数据，使用对应的解析方式，如 res.json() 、res.text()等等，如果解析方式不对，就报错。</li><li>另外注意的是，前端fetch的时候，如果自定义header，而且请求是跨域的，每发一次fetch，可能会产生两次请求，具体分析参见《koa2黑知识 – 跨域请求有时会发两次请求》：</li></ul><h4 id="常见的-content-type值–对应的ctx-response-type："><a href="#常见的-content-type值–对应的ctx-response-type：" class="headerlink" title="常见的 content-type值–对应的ctx.response.type："></a>常见的 content-type值–对应的ctx.response.type：</h4><p>application/json  – ctx.response.type=’json’<br>text/html  – ctx.response.type=’html’<br>image/png  – ctx.response.type=’image/png’<br>text/plain  – ctx.response.type=’text’  浏览器默认text/plain</p><h3 id="设置响应状态码"><a href="#设置响应状态码" class="headerlink" title="设置响应状态码"></a>设置响应状态码</h3><p>通过ctx.status设置，ctx.status是ctx.response.status的别名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;)</span><br><span class="line">const bodyparser = require(&apos;koa-bodyparser&apos;)</span><br><span class="line">var cors = require(&apos;koa2-cors&apos;);</span><br><span class="line"></span><br><span class="line">const app = new Koa()</span><br><span class="line">app.use(cors());</span><br><span class="line">app.use(bodyparser())</span><br><span class="line">app.use(async (ctx, next)=&gt;&#123;</span><br><span class="line">  ctx.response.type=&apos;text&apos;;</span><br><span class="line">  ctx.status=562;</span><br><span class="line">  ctx.response.body=&apos;&lt;p/&gt;999&lt;p/&gt;&apos;;</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(3000)</span><br></pre></td></tr></table></figure></p><p>页面响应：<br><figure class="image-box">                <img src="/image/koa2/status.png" alt="" title="" class="">                <p></p>            </figure></p><h4 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h4><p>koa-bodyparser的底层也是使用ctx.req.on实现的，所以不能同时使用 koa-bodyparser与ctx.req.on，否则，可能报错，<br>详见《koa2黑知识 – koa-bodyparser导致ctx.req.on事件失效》</p><h3 id="如何在koa使用中间件"><a href="#如何在koa使用中间件" class="headerlink" title="如何在koa使用中间件"></a>如何在koa使用中间件</h3><h4 id="中间件是由app-use加载的"><a href="#中间件是由app-use加载的" class="headerlink" title="中间件是由app.use加载的"></a>中间件是由app.use加载的</h4><p>中间件一般都通过 app.use 函数来加载中间件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const app = new Koa()</span><br><span class="line">app.use(cors());</span><br><span class="line">app.use(bodyparser())</span><br><span class="line">app.use(async (ctx, next)=&gt;&#123;</span><br><span class="line">  ctx.response.type=&apos;text&apos;;</span><br><span class="line">  ctx.response.body=&apos;&lt;p/&gt;999&lt;p/&gt;&apos;;</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(3000)</span><br></pre></td></tr></table></figure></p><h4 id="中间件执行顺序"><a href="#中间件执行顺序" class="headerlink" title="中间件执行顺序"></a>中间件执行顺序</h4><p>中间件在 koa中执行顺序，遵循洋葱模型方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](/image/koa2/middle.jpg)</span><br></pre></td></tr></table></figure></p><p>代码展示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">app.use(async (ctx, next)=&gt;&#123;</span><br><span class="line">  console.log(&apos;one start&apos;);</span><br><span class="line">  await next();</span><br><span class="line">  console.log(&apos;one end&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">app.use(async (ctx, next)=&gt;&#123;</span><br><span class="line">  console.log(&apos;two start&apos;);</span><br><span class="line">  await next();</span><br><span class="line">  console.log(&apos;two end&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">app.use(async (ctx, next)=&gt;&#123;</span><br><span class="line">  console.log(&apos;three start&apos;);</span><br><span class="line">  await next();</span><br><span class="line">  console.log(&apos;three end&apos;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// one start</span><br><span class="line">// two start</span><br><span class="line">// three start</span><br><span class="line">// three end</span><br><span class="line">// two end</span><br><span class="line">// one end</span><br></pre></td></tr></table></figure></p><h4 id="next"><a href="#next" class="headerlink" title="next()"></a>next()</h4><p>next()返回一个Promise对象，配合await使用，可以达到阻塞后面程序执行，等待 next() 返回类似reject()才最终执行nex()后面的程序。<br>每个中间件必须使用next()，否则异常。</p><h3 id="两种鉴权方式"><a href="#两种鉴权方式" class="headerlink" title="两种鉴权方式"></a>两种鉴权方式</h3><p>一种是广泛使用的Cookie认证模式；<br>一种是基于Token的认证模式, koa中可以结合jsonwebtoken 与 koa-jwt实现Token鉴权.<br><a href="https://github.com/YeWills/koa-demo/tree/router-Token" target="_blank" rel="noopener">这里是一个基于Token的鉴权demo</a></p><h3 id="写一个返回文件的接口"><a href="#写一个返回文件的接口" class="headerlink" title="写一个返回文件的接口"></a>写一个返回文件的接口</h3><h4 id="使用fs实现的方式"><a href="#使用fs实现的方式" class="headerlink" title="使用fs实现的方式"></a>使用fs实现的方式</h4><p>写一个接口，可以将本地的文件，返回给客户端,主要使用fs开完成，核心代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const extname = path.extname;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const fpath = path.join(__dirname, &apos;./files/test.xlsx&apos;);</span><br><span class="line">const fstat = await stat(fpath);</span><br><span class="line">if (fstat.isFile()) &#123;</span><br><span class="line">  ctx.type = extname(fpath);</span><br><span class="line">  ctx.body = fs.createReadStream(fpath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function stat(file) &#123;</span><br><span class="line">  return new Promise(function(resolve, reject) &#123;</span><br><span class="line">    fs.stat(file, function(err, stat) &#123;</span><br><span class="line">      if (err) &#123;</span><br><span class="line">        reject(err);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        resolve(stat);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/YeWills/koa-demo/tree/response-file" target="_blank" rel="noopener">完整demo</a>;<br>本demo 参考了 <a href="https://github.com/YeWills/examples" target="_blank" rel="noopener">koa 官网example</a>，koa 官网example挺好，展示了很多功能，如果有需求，可先到这里找示例实现。</p><h4 id="使用koa-static实现的方式"><a href="#使用koa-static实现的方式" class="headerlink" title="使用koa-static实现的方式"></a>使用koa-static实现的方式</h4><p>此方法参见《koa-static》，弊端是，无法自定义路由名称，只能以文件名称为接口url。</p><h3 id="写一个中间件"><a href="#写一个中间件" class="headerlink" title="写一个中间件"></a>写一个中间件</h3><p>这里动手写一个logger中间件小demo，用来打印日志：<br>原代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.use(async (ctx, next)=&gt;&#123;</span><br><span class="line">  console.log(ctx.method,ctx.host + ctx.url)</span><br><span class="line">  await next();</span><br><span class="line">  ctx.body = &apos;hellow world&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>动手写一个logger中间件，用于打印日志，改造后如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;)</span><br><span class="line">const app = new Koa()</span><br><span class="line">const logger = async function(ctx, next)&#123;</span><br><span class="line">  console.log(ctx.method,ctx.host + ctx.url)</span><br><span class="line">  await next();</span><br><span class="line">&#125;</span><br><span class="line">app.use(logger)</span><br><span class="line">app.use(async (ctx, next)=&gt;&#123;</span><br><span class="line">  ctx.body = &apos;hellow world&apos;</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(3000)</span><br></pre></td></tr></table></figure></p><h3 id="ctx-state"><a href="#ctx-state" class="headerlink" title="ctx.state"></a>ctx.state</h3><p>此属性，在做笔记为止，用的比较少，不用深究，用时再了解。<br>Koa 还约定了一个中间件的存储空间 ctx.state。通过 state 可以存储一些数据，比如用户数据，版本信息等。如果你使用 webpack 打包的话，可以使用中间件，将加载资源的方法作为 ctx.state 的属性传入到 view 层，方便获取资源路径。<a href="https://www.jianshu.com/p/d3afa36aa17a" target="_blank" rel="noopener">摘自此文</a></p><h2 id="koa2黑知识"><a href="#koa2黑知识" class="headerlink" title="koa2黑知识"></a>koa2黑知识</h2><h3 id="favicon-ico"><a href="#favicon-ico" class="headerlink" title="/favicon.ico"></a>/favicon.ico</h3><p>我们常加载dom时，会看到有一个/favicon.ico请求，这个是Dom渲染时，默认自带的静态资源。</p><h3 id="this-指向-ctx"><a href="#this-指向-ctx" class="headerlink" title="this 指向 ctx"></a>this 指向 ctx</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.use(async (ctx)=&gt;&#123;</span><br><span class="line"> this; //此this其实就是ctx，就是Context</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&apos;run in 3000&apos;)</span><br></pre></td></tr></table></figure><h3 id="koa-bodyparser导致ctx-req-on事件失效"><a href="#koa-bodyparser导致ctx-req-on事件失效" class="headerlink" title="koa-bodyparser导致ctx.req.on事件失效"></a>koa-bodyparser导致ctx.req.on事件失效</h3><p>下面代码会报错，因为koa-bodyparser的底层就是基于ctx.req.on实现的，如果使用了koa-bodyparser，它可能会劫持ctx.req.on这个事件，导致ctx.req.on事件失效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">app.use(bodyparser())</span><br><span class="line">app.use(async (ctx)=&gt;&#123;</span><br><span class="line">  let postdata=&apos;&apos;;</span><br><span class="line">  ctx.req.on(&apos;data&apos;, (data)=&gt;&#123;</span><br><span class="line">    postdata +=data;</span><br><span class="line">  &#125;)</span><br><span class="line">  ctx.req.on(&apos;end&apos;, ()=&gt;&#123;</span><br><span class="line">    console.log(postdata);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&apos;run in 3000&apos;)</span><br></pre></td></tr></table></figure></p><p>解决的方法也简单，koa-bodyparser本来是为了方便获取ctx.req.on,使用了koa-bodyparser就没必要使用ctx.req.on。<br>或者用kctx.req.on，就不要用koa-bodyparser；</p><h3 id="koa2-cors解决跨域"><a href="#koa2-cors解决跨域" class="headerlink" title="koa2-cors解决跨域"></a>koa2-cors解决跨域</h3><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>var cors = require(‘koa2-cors’);<br>app.use(cors());</p><h4 id="将koa2-cors放在最上面"><a href="#将koa2-cors放在最上面" class="headerlink" title="将koa2-cors放在最上面"></a>将koa2-cors放在最上面</h4><p>将koa2-cors放在最上面，让koa2-cors先于其他中间件执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">app.use(cors()) // 解决跨域，跨域代码最好放在所有中间件前面</span><br><span class="line">const views = require(&apos;koa-views&apos;)</span><br><span class="line">const serve = require(&apos;koa-static&apos;)</span><br><span class="line">const &#123; resolve &#125; = require(&apos;path&apos;)</span><br><span class="line">const handlePath = path =&gt; resolve(__dirname, path)</span><br><span class="line">app.use(serve(handlePath(&apos;../pages/static&apos;)))</span><br><span class="line">app.use(views(handlePath(&apos;../pages&apos;)), &#123;</span><br><span class="line">  extension: &apos;html&apos;</span><br><span class="line">&#125;)</span><br><span class="line">app.use(async (ctx) =&gt; &#123;</span><br><span class="line">  await ctx.render(&apos;index.html&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">app.use(bodyparser())// 解析post参数</span><br><span class="line">app.use(router.routes())// 调用路由中间件</span><br><span class="line">app.use(router.allowedMethods())// 对异常状态码处理</span><br><span class="line">app.listen(3000, ()=&gt;&#123;</span><br><span class="line">  console.log(&apos;server is running at http://localhost:3000&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="home-id-name-路由对应的url"><a href="#home-id-name-路由对应的url" class="headerlink" title="/home/:id/:name 路由对应的url"></a>/home/:id/:name 路由对应的url</h3><p>router.get(‘/home’  —对应 <a href="http://localhost:3000/home?id=01&amp;name=admin" target="_blank" rel="noopener">http://localhost:3000/home?id=01&amp;name=admin</a><br>router.get(‘/home/:id/:name’  —对应 <a href="http://localhost:3000/home/01/admin" target="_blank" rel="noopener">http://localhost:3000/home/01/admin</a></p><h3 id="跨域请求有时会发两次请求"><a href="#跨域请求有时会发两次请求" class="headerlink" title="跨域请求有时会发两次请求"></a>跨域请求有时会发两次请求</h3><p>当前端fetch自定了header时，且接口跨域时，fetch一次，可能会发两次相同请求，两次请求一次是Request Method: OPTIONS的，<br>一次是Request Method: GET的，<br>原来fetch在发送真正的请求前, 会先发送一个方法为OPTIONS的预请求(preflight request), 用于试探服务端是否能接受真正的请求<a href="https://blog.csdn.net/cc1314_/article/details/78272329" target="_blank" rel="noopener">详细原因参见这里</a>；<br>解决之道就是把自定义headers字段删掉后；<br>或者不要使用require(‘koa2-cors’)的方式解决跨域，可以通过服务端请求服务器的方式解决跨域；<br>因为跨域是浏览器的限制机制，而服务器与服务器之间不存在跨域问题，具体思路：<br>在同域名下通过 koa 截取 项目的所有fetch请求，然后使用 request 模块，通过 request 给另外域名下的服务器发请求。</p><h3 id="后台报错app有错误日志，也会报跨域错误"><a href="#后台报错app有错误日志，也会报跨域错误" class="headerlink" title="后台报错app有错误日志，也会报跨域错误"></a>后台报错app有错误日志，也会报跨域错误</h3><p>如果配置了koa2-cors解决跨域，但请求时有跨域报错，可能是app.use内部程序执行报错，会导致后台响应异常，然后前台可能显示为跨域限制错误</p><h2 id="koa2模块"><a href="#koa2模块" class="headerlink" title="koa2模块"></a>koa2模块</h2><h3 id="koa-router"><a href="#koa-router" class="headerlink" title="koa-router"></a>koa-router</h3><h4 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;)</span><br><span class="line">const bodyparser = require(&apos;koa-bodyparser&apos;)</span><br><span class="line">const router = require(&apos;koa-router&apos;)()</span><br><span class="line">var cors = require(&apos;koa2-cors&apos;);</span><br><span class="line">const app = new Koa()</span><br><span class="line"> router.get(&apos;/&apos;, async (ctx, next) =&gt; &#123;</span><br><span class="line">    ctx.response.body = `&lt;h1&gt;index page&lt;/h1&gt;`</span><br><span class="line">&#125;)</span><br><span class="line">router.get(&apos;/home&apos;, async (ctx, next) =&gt; &#123;</span><br><span class="line">    ctx.response.body = &apos;&lt;h1&gt;HOME page&lt;/h1&gt;&apos;</span><br><span class="line">&#125;)</span><br><span class="line">router.get(&apos;/404&apos;, async (ctx, next) =&gt; &#123;</span><br><span class="line">    ctx.response.body = &apos;&lt;h1&gt;404 Not Found&lt;/h1&gt;&apos;</span><br><span class="line">&#125;)</span><br><span class="line">app.use(cors()) // 解决跨域</span><br><span class="line">app.use(bodyparser())// 解析post参数</span><br><span class="line">app.use(router.routes())// 注册路由中间件</span><br><span class="line">app.use(router.allowedMethods())// 对异常状态码处理</span><br><span class="line">app.listen(3000, ()=&gt;&#123;</span><br><span class="line">  console.log(&apos;server is running at http://localhost:3000&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>关键 是在最后使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.use(router.routes())// 调用路由中间件</span><br><span class="line">app.use(router.allowedMethods())// 对异常状态码处理</span><br></pre></td></tr></table></figure></p><p>当然，如果你不想处理异常状态码，完全可以不使用router.allowedMethods(),单独使用router.routes()即可。</p><h4 id="模拟路由中间件"><a href="#模拟路由中间件" class="headerlink" title="模拟路由中间件"></a>模拟路由中间件</h4><p>下面模拟路由写的中间件，可以加深对路由中间件的理解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Router&#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    this._routers = [];</span><br><span class="line">  &#125;</span><br><span class="line">  get(url, handler)&#123;</span><br><span class="line">    this._routers.push(&#123;</span><br><span class="line">      url:url,</span><br><span class="line">      method:&apos;GET&apos;,</span><br><span class="line">      handler</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  routes()&#123;</span><br><span class="line">    return async (ctx, next) =&gt; &#123;</span><br><span class="line">      const &#123;method, url&#125; = ctx;</span><br><span class="line">      const matchedRouter = this._routers.find(r =&gt; r.method === method &amp;&amp; r.url === url);</span><br><span class="line">      if( matchedRouter &amp;&amp;</span><br><span class="line">        matchedRouter.handler)&#123;</span><br><span class="line">          await matchedRouter.handler(context, next);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">          await next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="koa-static"><a href="#koa-static" class="headerlink" title="koa-static"></a>koa-static</h3><h4 id="介绍-和-demo"><a href="#介绍-和-demo" class="headerlink" title="介绍 和 demo"></a>介绍 和 demo</h4><p>koa-static是静态资源请求中间件，这里写了一个<a href="https://github.com/YeWills/koa-demo/tree/static-views" target="_blank" rel="noopener">简单的demo</a>，可启动感受下，下面以该demo源码作为示例讲解koa-static；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(serve(handlePath(&apos;../pages/static&apos;)))</span><br></pre></td></tr></table></figure></p><p>通过图片可以看出项目静态文件目录结构<br><figure class="image-box">                <img src="/image/koa2/static.jpg" alt="" title="" class="">                <p></p>            </figure></p><p>配置上面这句代码后，你讲可以在浏览器上运行可现实文件内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:3000/css/style.css</span><br><span class="line">http://127.0.0.1:3000/img/films.jpg</span><br></pre></td></tr></table></figure></p><p>注意哦，不是 <a href="http://127.0.0.1:3000/pages/static/css/style.css" target="_blank" rel="noopener">http://127.0.0.1:3000/pages/static/css/style.css</a> !!这个地址是找不到的，很多刚用koa-static时都会犯这个错，认为就是handlePath(‘../pages/static’) 定义的url，然后就拼接成了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//这个地址是访问不到的</span><br><span class="line">http://127.0.0.1:3000/pages/static/css/style.css</span><br></pre></td></tr></table></figure></p><h4 id="理解koa-static"><a href="#理解koa-static" class="headerlink" title="理解koa-static"></a>理解koa-static</h4><p>koa-static是静态资源请求中间件，不过这样说，我们并不能直观理解koa-static是什么，原理是什么。<br>我们大可将koa-static看成是一个 为提供目录下每个文件 配置路由的中间件，<br>只要你提供一个文件的具体位置给koa-static，koa-static会结合路由的功能，为每个该文件位置下的文件配置一个 url 路由；<br>这个url路由其实就是一个普通的接口url，我们将这个普通的url输入浏览器，回车就可以看到改接口url的返回内容；</p><h4 id="koa-static是个批量配置接口url的中间件"><a href="#koa-static是个批量配置接口url的中间件" class="headerlink" title="koa-static是个批量配置接口url的中间件"></a>koa-static是个批量配置接口url的中间件</h4><p>所以，koa-static其实是一个很棒批量配置接口url的中间件，可以为你提供的文件目录下的所有文件批量配置好url接口，<br>你就可以轻松通过此url接口访问此文件。</p><h3 id="koa-views"><a href="#koa-views" class="headerlink" title="koa-views"></a>koa-views</h3><h4 id="介绍-和-demo-1"><a href="#介绍-和-demo-1" class="headerlink" title="介绍 和 demo"></a>介绍 和 demo</h4><p>如果我们只需要ctx.body只需要返回一段简单的代码如下，那么就用不到koa-views。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.response.body = &apos;&lt;h1&gt;404 Not Found&lt;/h1&gt;&apos;</span><br></pre></td></tr></table></figure></p><p>如果我们要ctx.response.body直接返回一个如下复杂的html，这个时候，再去拼接字符串太麻烦，<br>koa-views就是让body返回html变得简单，你直接单独定义好一个html，然后直接引用此html即可，非常方便。<br>koa-views可以用于<strong>普通的html文件</strong>，也可以用于模板引擎，用于模板引擎的时候，可通过ctx.state传值；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let html = `</span><br><span class="line">  &lt;h1&gt;登录&lt;\h1&gt;</span><br><span class="line">  &lt;form method = &quot;POST&quot; action= &quot;/&quot;&gt;</span><br><span class="line">  &lt;p&gt;用户名&lt;/p&gt;</span><br><span class="line">  &lt;input name=&quot;userName&quot; /&gt;&lt;br/&gt;</span><br><span class="line">  &lt;p&gt;密码&lt;/p&gt;</span><br><span class="line">  &lt;input name=&quot;password&quot; type=&quot;password&quot; /&gt;&lt;br/&gt;</span><br><span class="line">  &lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">  `</span><br><span class="line">  ctx.body=html;</span><br></pre></td></tr></table></figure></p><p>这里写了一个<a href="https://github.com/YeWills/koa-demo/tree/static-views" target="_blank" rel="noopener">简单的demo</a>，可启动感受下加深理解。<br>此demo和《koa-static》demo是同一个</p><h4 id="koa-views的使用"><a href="#koa-views的使用" class="headerlink" title="koa-views的使用"></a>koa-views的使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const views = require(&apos;koa-views&apos;)</span><br><span class="line">app.use(views(handlePath(&apos;../pages&apos;)), &#123;</span><br><span class="line">  extension: &apos;html&apos;</span><br><span class="line">&#125;)</span><br><span class="line">app.use(async (ctx) =&gt; &#123;</span><br><span class="line">  await ctx.render(&apos;index.html&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="render是koa-views集成到ctx的"><a href="#render是koa-views集成到ctx的" class="headerlink" title="render是koa-views集成到ctx的"></a>render是koa-views集成到ctx的</h4><p>如上的代码，ctx本身没有render方法，只是使用koa-views中间件后，ctx才有这个方法的</p><h4 id="index-html中静态文件的路径"><a href="#index-html中静态文件的路径" class="headerlink" title="index.html中静态文件的路径"></a>index.html中静态文件的路径</h4><p>请结合上面demo源码看(此demo和《koa-static》demo是同一个)<br>项目路径和请看参看 《koa-static》的图片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(serve(handlePath(&apos;../pages/static&apos;)))</span><br></pre></td></tr></table></figure><p>我们在《koa-static》中知道css和jpg的访问接口url是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:3000/css/style.css</span><br><span class="line">http://127.0.0.1:3000/img/films.jpg</span><br></pre></td></tr></table></figure></p><p>此时，index.html的css和img的路径应该配置为如下，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;</span><br><span class="line">  &lt;title&gt;东成西就&lt;/title&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/style.css&quot;&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;films&quot;&gt;东成西就就是棒！&lt;/div&gt;</span><br><span class="line">  &lt;img src=&quot;/img/films.jpg&quot; /&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h3 id="koa-bodyparser"><a href="#koa-bodyparser" class="headerlink" title="koa-bodyparser"></a>koa-bodyparser</h3><p>此中间件的作用 是 把POST请求的参数解析到ctx.request.body中，koa-bodyparser底层就是基于ctx.req.on实现的。<br>其他信息见《koa-bodyparser导致ctx.req.on事件失效》  《POST请求参数的获取》</p><h3 id="jsonwebtoken-与-koa-jwt"><a href="#jsonwebtoken-与-koa-jwt" class="headerlink" title="jsonwebtoken 与 koa-jwt"></a>jsonwebtoken 与 koa-jwt</h3><p>jsonwebtoken 简称 JWT，用来实现Token的生成、校验和解码。<br>使用koa-jwt中间件可以将 jsonwebtoken与koa有机结合起来。<br>jsonwebtoken 与 koa-jwt 的关系，就跟 redux 与react-redux的关系。<br><a href="https://github.com/YeWills/koa-demo/tree/router-Token" target="_blank" rel="noopener">这里是一个基于Token的鉴权demo</a>。</p><p>使用方法：<br>一般方案为：登录是，koa通过jsonwebtoken给用户一个Token编码，之后客户端发送请求时，在Header上都带上此Token码，<br>后端接受请求时，验证此Token码进行鉴权。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const &#123; sign &#125; = require(&apos;jsonwebtoken&apos;);</span><br><span class="line">const secret = &apos;demo&apos;;</span><br><span class="line">const jwt = require(&apos;koa-jwt&apos;)(&#123; secret &#125;);</span><br><span class="line"></span><br><span class="line">//生成Token，secret作为密钥开发者自定义设置，expiresIn为失效时间，不要设置太久</span><br><span class="line">//登陆成功后，后台通过jsonwebtoken为该用户生成Token编码，</span><br><span class="line">//客户端拿到Token编码后，下次发请求时，在Header中带上Token码</span><br><span class="line">router.post(&apos;/api/login&apos;, async (ctx, next) =&gt; &#123;</span><br><span class="line">    const &#123; username &#125; = ctx.request.body;</span><br><span class="line">    const token = sign(&#123; username &#125;, secret, &#123; expiresIn: &apos;1h&apos; &#125;);</span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">      message: &apos;Get Token Success&apos;,</span><br><span class="line">      code: 1,</span><br><span class="line">      token</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)</span><br><span class="line">  //登录之后的接口请求，都要验证Token，所以都要在Header中将上一步登录是获得的Token传给后台</span><br><span class="line">    .get(&apos;/api/userInfo&apos;, jwt, async ctx =&gt; &#123;</span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">      username: ctx.state.user.username</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h3 id="querystring"><a href="#querystring" class="headerlink" title="querystring"></a>querystring</h3><p>querystring模块有以下作用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const Querystring = require(&apos;querystring&apos;)</span><br><span class="line">Querystring.escape(&apos;id=1&apos;) //返回 id%3D1</span><br><span class="line">Querystring.unescape(&apos;id%3D1&apos;) //返回 id=1</span><br><span class="line">querystring.parse(&apos;foo=bar&amp;abc=xyz&amp;abc=123&apos;) //返回 &#123;foo: &apos;bar&apos;,abc: [&apos;xyz&apos;, &apos;123&apos;]&#125;</span><br><span class="line">querystring.stringify(&#123; foo: &apos;bar&apos;, baz: [&apos;qux&apos;, &apos;quux&apos;], corge: &apos;&apos; &#125;) // 返回 &apos;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge=&apos;</span><br></pre></td></tr></table></figure></p><p><a href="http://nodejs.cn/api/querystring.html" target="_blank" rel="noopener">更多点击官网</a></p><p><a href="https://github.com/YeWills/koa-demo/tree/http-request" target="_blank" rel="noopener">这里有一个querystring的demo</a></p><h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><p>http说的是 require(‘http’)模块。<br>koa利用http直接从服务端向其他服务器发起请求，<br>如下，koa服务端，接收到请求时，在路由函数体内，将请求参数重新组装，通过http，转发给对应服务器。<br>这种方法好处之一是避免跨域问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const Http = require(&apos;http&apos;);</span><br><span class="line">router.get(&apos;/&apos;, async (ctx, next) =&gt; &#123;</span><br><span class="line">    let &#123; kw &#125; = ctx.query;</span><br><span class="line">    let resData = await new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">          //http://m.maoyan.com/ajax/search?kw=捉妖记&amp;cityId=10</span><br><span class="line">            Http.request(&#123;</span><br><span class="line">                hostname: &apos;m.maoyan.com&apos;,</span><br><span class="line">                path: &apos;/ajax/search?&apos; + Querystring.stringify(&#123;</span><br><span class="line">                    kw,</span><br><span class="line">                    cityId: 10</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;, (res) =&gt; &#123;</span><br><span class="line">                res.setEncoding(&apos;utf8&apos;);</span><br><span class="line">                let data = [];</span><br><span class="line">                res.on(&apos;data&apos;, (chunk) =&gt; &#123;</span><br><span class="line">                    data.push(chunk)</span><br><span class="line">                &#125;).on(&apos;end&apos;, () =&gt; &#123;</span><br><span class="line">                    resolve(data.join(&apos;&apos;));</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;).end();</span><br><span class="line">        &#125;);</span><br><span class="line">    ctx.body = Render(JSON.parse(resData), kw);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a href="https://github.com/YeWills/koa-demo/tree/http-request" target="_blank" rel="noopener">完整http request的demo</a></p><h3 id="koa-multer"><a href="#koa-multer" class="headerlink" title="koa-multer"></a>koa-multer</h3><p>koa-multer 用来做文件上传功能，需要配合 fs模块一起，比较简单，<a href="https://github.com/YeWills/koa-demo/tree/web-pro" target="_blank" rel="noopener">这是文件上传koa-multer 和fs demo</a>。</p><h3 id="fs"><a href="#fs" class="headerlink" title="fs"></a>fs</h3><p>demo和介绍，参考《koa-multer》《写一个返回文件的接口》，这两部分都有demo，使用fs做了一个文件上传和读取本地文件并返回给前台的功能</p><h3 id="koa-json、log4js、ip"><a href="#koa-json、log4js、ip" class="headerlink" title="koa-json、log4js、ip"></a>koa-json、log4js、ip</h3><p><a href="https://github.com/YeWills/koa-demo/tree/pro-static" target="_blank" rel="noopener">这里只放一个demo</a>，不深入了解，用到的时候再深究，此demo包含koa-static、log4js与ip、koa-json、koa-nunjucks</p><h3 id="koa-nunjucks"><a href="#koa-nunjucks" class="headerlink" title="koa-nunjucks"></a>koa-nunjucks</h3><p>koa-nunjucks是基于nunjucks的html 模板中间件。<br>没有什么太复杂的需求，只是用koa玩玩，如果不用html模板，用koa-views就可以了，如果要用html模板，可以用koa-nunjucks，当然也可以用ejs模板，等等，有很多这方面的模板。<br>这里只放一个demo，不过多解释，用到的时候再了解。<br><a href="https://github.com/YeWills/koa-demo/tree/web-pro" target="_blank" rel="noopener">koa-nunjucks的使用demo</a></p><h3 id="ejs-pug-puppeteer-parcel-bundler"><a href="#ejs-pug-puppeteer-parcel-bundler" class="headerlink" title="ejs pug puppeteer parcel-bundler"></a>ejs pug puppeteer parcel-bundler</h3><p>暂时不用过多了解，用时深究，<a href="https://github.com/YeWills/koa2_films/tree/koa_web" target="_blank" rel="noopener">参见demo</a>。</p><h3 id="request-promise-native-request-glob"><a href="#request-promise-native-request-glob" class="headerlink" title="request-promise-native request glob"></a>request-promise-native request glob</h3><p>暂时不用过多了解，用时深究，<a href="https://github.com/YeWills/koa2_films/tree/koa_web" target="_blank" rel="noopener">参见demo</a>。</p><h2 id="RESTfull-和-http"><a href="#RESTfull-和-http" class="headerlink" title="RESTfull 和  http"></a>RESTfull 和  http</h2><h3 id="RESTful-规范"><a href="#RESTful-规范" class="headerlink" title="RESTful 规范"></a>RESTful 规范</h3><p>非RESTful规范定义的接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.get(/app/adduser)</span><br><span class="line">router.get(/app/edituser)</span><br><span class="line">router.get(/app/deleteuser)</span><br></pre></td></tr></table></figure></p><p>基于RESTful规范设计的API，全局只提供唯一的URI /app/user<br>设计如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.post(/app/user) //新增用户id</span><br><span class="line">router.edit(/app/user:id) 编辑名字为id的用户</span><br><span class="line">router.delete(/app/user:id) 删除名字为id的用户</span><br></pre></td></tr></table></figure></p><h3 id="URL-的7个部分组成："><a href="#URL-的7个部分组成：" class="headerlink" title="URL 的7个部分组成："></a>URL 的7个部分组成：</h3><p>scheme:[//[user[:password]@]host[:post][/path][?query][#fragemnt]<br>scheme:使用协议 如FTP、HTTP等<br>user[:password] : 表示访问资源的用户和密码，常见于FTP协议<br>host 主机<br>port 端口<br>path 访问资源路径<br>query 请求数据，以？开头<br>fragment 定位锚点，以#开头，可用于快速定位网页对应段落</p><h3 id="常用http状态码"><a href="#常用http状态码" class="headerlink" title="常用http状态码"></a>常用http状态码</h3><p>1<strong> 消息   100 继续，继续响应剩余部分，如已完成，可忽略<br>2</strong> 成功<br>3<strong> 重定向  301 永久移动； 302 临时移动； 304 未修改，请求资源对比上次没有修改<br>4</strong> 请求错误 401 未授权 ； 403 禁止； 404 未找到；<br>5<strong> 和 6</strong> 服务器错误  500 服务器内部错误； 503 服务不可用；</p><h2 id="相关demo"><a href="#相关demo" class="headerlink" title="相关demo"></a>相关demo</h2><h3 id="koa-demo"><a href="#koa-demo" class="headerlink" title="koa-demo"></a>koa-demo</h3><p>主要的示例demo:<a href="https://github.com/YeWills/koa-demo" target="_blank" rel="noopener">koa-demo</a>;</p><h3 id="koa2-films"><a href="#koa2-films" class="headerlink" title="koa2_films"></a>koa2_films</h3><p>很好的综合运行demo(含爬虫，mongodb，koa,前后端一体化编译开发):<a href="https://github.com/YeWills/koa2_films/tree/koa_web" target="_blank" rel="noopener">koa2_films/koa_web</a>,<br>此仓库其他分支还有单纯的 开发后台的分支;<br>也有单纯的爬虫demo：<a href="https://github.com/YeWills/koa2_films/tree/puppeteer" target="_blank" rel="noopener">爬虫小demo</a>；<br>还有一个分支为：<a href="https://github.com/YeWills/koa2_films/tree/event_IO_loop" target="_blank" rel="noopener">nodejs 异步io的理解 阻塞非阻塞，事件循环与驱动，单线程，子进程，进程通讯)events 框架demo</a>；</p><h3 id="films-new"><a href="#films-new" class="headerlink" title="films_new"></a>films_new</h3><p><a href="https://github.com/YeWills/react-redux-demo/tree/films_new" target="_blank" rel="noopener">films_new</a>是react-redux-demo仓库下的分支。<br>这是前端代码，用来像后台发起请求。</p><h3 id="koa-miniprogram"><a href="#koa-miniprogram" class="headerlink" title="koa-miniprogram"></a>koa-miniprogram</h3><p>此项目为微信开发，《koa与node.js开发实战》 书第九章以后的代码，在此仓库，我整理成单独几份，暂时没有微信学习，将源码整理备份，以备以后用。<br>其中<a href="https://github.com/YeWills/koa-miniprogram/tree/particle-css" target="_blank" rel="noopener">particle-css分支</a>挺好的一个css页面，同时还有超炫背景粒子-particlesJS插件的使用 效果：</p><h2 id="参考和学习资料"><a href="#参考和学习资料" class="headerlink" title="参考和学习资料"></a>参考和学习资料</h2><p><a href="">koa与node.js开发实战</a><br><a href="">Koa2框架从0开始构建预告片网站</a><br><a href="https://koajs.com/#context" target="_blank" rel="noopener">koa 官网</a><br><a href="https://github.com/koajs/koa#readme" target="_blank" rel="noopener">koa github </a><br><a href="https://github.com/YeWills/examples" target="_blank" rel="noopener">koa example，挺好的官方示例，比较全，做需求时可先在这找示例</a><br><a href="https://www.jianshu.com/p/d3afa36aa17a" target="_blank" rel="noopener">koa2入门笔记</a></p>]]></content>
      
      
      <categories>
          
          <category> koa2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> koa2 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js笔记</title>
      <link href="/2019/03/24/js/"/>
      <url>/2019/03/24/js/</url>
      
        <content type="html"><![CDATA[<h2 id="js-常用知识"><a href="#js-常用知识" class="headerlink" title="js 常用知识"></a>js 常用知识</h2><h3 id="自运行函数"><a href="#自运行函数" class="headerlink" title="自运行函数"></a>自运行函数</h3><h4 id="自运行函数的17种写法"><a href="#自运行函数的17种写法" class="headerlink" title="自运行函数的17种写法"></a>自运行函数的17种写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">( function() &#123;&#125;() );</span><br><span class="line">( function() &#123;&#125; )();</span><br><span class="line">[ function() &#123;&#125;() ];</span><br><span class="line"></span><br><span class="line">~ function() &#123;&#125;();</span><br><span class="line">! function() &#123;&#125;();</span><br><span class="line">+ function() &#123;&#125;();</span><br><span class="line">- function() &#123;&#125;();</span><br><span class="line"></span><br><span class="line">delete function() &#123;&#125;();</span><br><span class="line">typeof function() &#123;&#125;();</span><br><span class="line">void function() &#123;&#125;();</span><br><span class="line">new function() &#123;&#125;();</span><br><span class="line">new function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">var f = function() &#123;&#125;();</span><br><span class="line"></span><br><span class="line">1, function() &#123;&#125;();</span><br><span class="line">1 ^ function() &#123;&#125;();</span><br><span class="line">1 &gt; function() &#123;&#125;();</span><br><span class="line"></span><br><span class="line">;( function() &#123;&#125;() );</span><br></pre></td></tr></table></figure><h4 id="函数表达式-和-函数声明"><a href="#函数表达式-和-函数声明" class="headerlink" title="函数表达式 和 函数声明"></a>函数表达式 和 函数声明</h4><p>要弄懂自运行函数的原理，需弄懂函数表达式 和 函数声明概念；<br>函数声明，也叫函数定义；<br><a href="https://www.cnblogs.com/lenther2002/p/5894964.html" target="_blank" rel="noopener">参考</a><br>Javascript中有2个语法都与function关键字有关，分别是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">函数声明：function FunctionName(FormalParameterList) &#123; FunctionBody &#125;</span><br><span class="line">函数表达式：function [FunctionName](FormalParameterList) &#123; FunctionBody &#125;</span><br></pre></td></tr></table></figure></p><p>从语法的定义上看，这两者几乎是一模一样的（唯一的区别是函数表达式可以省略函数名称），那么就解释器而言，当遇到这个结构的语句时，判定为函数表达式还是函数定义呢？<br>就javascript的语法而言，如果一条语句是以function关键字开始，那么这段会被判定为函数定义(声明)；<br>如果不是以function关键字开始，那么就是函数表达式；</p><p><strong>为什么要分清 函数表达式和函数声明呢?</strong><br>因为<a href="https://www.zhihu.com/question/20249179" target="_blank" rel="noopener">函数表达式是不能拿来直接用的</a>，必须在<strong>左侧</strong>有字符或表达式与这个函数表达式共同构成一句可执行的函数语句；<br>（之所以在左侧，不是右侧，是因为在不要行函数语句以关键字function开始，避免被识别为函数声明，导致报错）<br>函数声明是可以拿过来直接用；<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function fn()&#123;&#125;</span><br><span class="line">fn()//不报错；</span><br><span class="line">function ()&#123;&#125;() //报错</span><br><span class="line">-function ()&#123;console.log(5)&#125;() //不报错 因为在funtion左侧有表达式-</span><br></pre></td></tr></table></figure></p><h4 id="16种含函数表达式的不报错的函数语句"><a href="#16种含函数表达式的不报错的函数语句" class="headerlink" title="16种含函数表达式的不报错的函数语句"></a>16种含函数表达式的不报错的函数语句</h4><p>结合上节的知识，将《自运行函数的17种写法》整理下，以下17种包含了函数表达式的函数语句不报错,注意的是，<br>以下函数表达式内的函数体都将不会执行，至于如何执行，下面会讲。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">( function() &#123;&#125; );</span><br><span class="line">( function() &#123;&#125; );</span><br><span class="line">[ function() &#123;&#125; ];</span><br><span class="line"></span><br><span class="line">~ function() &#123;&#125;;</span><br><span class="line">! function() &#123;&#125;;</span><br><span class="line">+ function() &#123;&#125;;</span><br><span class="line">- function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">delete function() &#123;&#125;;</span><br><span class="line">typeof function() &#123;&#125;;</span><br><span class="line">void function() &#123;&#125;;</span><br><span class="line">new function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">var f = function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">1, function() &#123;&#125;;</span><br><span class="line">1 ^ function() &#123;&#125;;</span><br><span class="line">1 &gt; function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">;( function() &#123;&#125; );</span><br></pre></td></tr></table></figure><h4 id="是否以function开始对js解释器很重要"><a href="#是否以function开始对js解释器很重要" class="headerlink" title="是否以function开始对js解释器很重要"></a>是否以function开始对js解释器很重要</h4><p><a href="https://www.zhihu.com/question/20249179" target="_blank" rel="noopener">参考</a><br>以下两种报错形式的原因分析：</p><ul><li>function (){ }()<br>期望是立即调用一个匿名函数表达式，结果是进行了函数声明，函数声明必须要有标识符做为函数名称。</li><li>function g(){ }()<br>期望是立即调用一个具名函数表达式，结果是声明了函数 g。末尾的括号作为分组运算符，<strong>必须要提供表达式做为参数</strong>，这个表达式可以是一个值或一个语句，例如改成下面的就不会报错：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function g()&#123; &#125;(1) //不报错，因为末尾的小括号有值作为表达式</span><br><span class="line">function g()&#123; &#125;(1,2) //不报错</span><br></pre></td></tr></table></figure></li></ul><p>以上说明了，是否以function开始对js解释器很重要;<br>如果以function开始，js解释器会认为它是一个函数声明，此时就要符合函数声明的标准，否则报错；<br>如果function左侧还有表达式，js解释器会认为它是一个函数表达式，此时该函数表达式配合左右两侧的表达式就构成了一个函数语句,要符合函数语句标准；<br>（例如 var a = function(){} 这就是一条函数语句）</p><h4 id="1种立即执行的函数声明形式"><a href="#1种立即执行的函数声明形式" class="headerlink" title="1种立即执行的函数声明形式"></a>1种立即执行的函数声明形式</h4><p>目前知道的，可以让函数声明内的函数体立即执行的只有这种方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function g(a)&#123;console.log(a) &#125;(1) //不报错</span><br></pre></td></tr></table></figure></p><p>注意，末尾小括号一定要有 表达式，原因查看《是否以function开始对js解释器很重要》<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function g(a)&#123;console.log(a) &#125;() //报错</span><br></pre></td></tr></table></figure></p><h4 id="如何让函数表达式、声明内的函数体立即执行"><a href="#如何让函数表达式、声明内的函数体立即执行" class="headerlink" title="如何让函数表达式、声明内的函数体立即执行"></a>如何让函数表达式、声明内的函数体立即执行</h4><p>如何让 函数表达式和函数声明 内的函数体立即执行呢；<br><strong>只能</strong>通过小括号();<br>例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = function()&#123;console.log(&apos;work&apos;)&#125; //不打印</span><br><span class="line">var a = function()&#123;console.log(&apos;work&apos;)&#125;() //打印work</span><br></pre></td></tr></table></figure></p><p>因此可以认为()是一个让立即执行的运算符，可以让函数表达式或函数声明内的函数体立即执行；</p><h4 id="函数表达式、声明-与-立即执行-关系"><a href="#函数表达式、声明-与-立即执行-关系" class="headerlink" title="函数表达式、声明 与 立即执行 关系"></a>函数表达式、声明 与 立即执行 关系</h4><p>参看上面的《如何让函数表达式、声明内的函数体立即执行》</p><h4 id="与-立即执行"><a href="#与-立即执行" class="headerlink" title="() 与 立即执行"></a>() 与 立即执行</h4><p>参看上面的《如何让函数表达式、声明内的函数体立即执行》</p><h4 id="放在哪些位置可以让函数体立即执行"><a href="#放在哪些位置可以让函数体立即执行" class="headerlink" title="()放在哪些位置可以让函数体立即执行"></a>()放在哪些位置可以让函数体立即执行</h4><p>一般而言，() 紧跟在 function(){} 的花括号后面的位置，通过这样的方式让函数表达式或函数声明 内的函数体立刻执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = function()&#123;console.log(&apos;work&apos;)&#125;()</span><br><span class="line">~ function() &#123;&#125;()</span><br><span class="line">( function() &#123;&#125;() )</span><br><span class="line">function fn(t)&#123;console.log(t)&#125;(&apos;work&apos;)</span><br></pre></td></tr></table></figure></p><p>不过有个例外，请看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">( function() &#123;&#125;() ); //可以立即执行函数体</span><br><span class="line">( function() &#123;&#125; )(); //()放在了左侧(  )的右侧，不过也可以立即执行函数体</span><br></pre></td></tr></table></figure></p><p>()紧跟在中括号后就不行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ function() &#123;&#125;()]; //不报错，这个函数语句其实就是一个数组</span><br><span class="line">[ function() &#123;&#125;](); //报错，因为[]是一个数组，数组不是方法，类似这种写法，都错：[]()</span><br></pre></td></tr></table></figure></p><p><strong>小结，从目前看，小括号一般紧跟如上的花括号，也可跟在如上的 (  )后面。</strong>现在再回过头，看这《自运行函数的17种写法》应该就明白了吧</p><h4 id="与-函数传参"><a href="#与-函数传参" class="headerlink" title="() 与 函数传参"></a>() 与 函数传参</h4><p>这个简单，不多介绍，一般自运行传参的方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( function(a) &#123;console.log(a)&#125; )(888) //888</span><br></pre></td></tr></table></figure></p><p>注意的是，将()写在里面也是可以传参的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( function(a) &#123;console.log(a)&#125;(888) ) //888</span><br></pre></td></tr></table></figure></p><h4 id="分号-与-立即执行"><a href="#分号-与-立即执行" class="headerlink" title="分号 ; 与 立即执行"></a>分号 ; 与 立即执行</h4><p>有些人喜欢用分号;来配合函数表达式写一个自运行，;分号本来是用来给函数语句断句的；<br>所以用这个的好处就是自带断句功能，避免不必要的错误；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//会报错</span><br><span class="line">var f = function() &#123;&#125;;</span><br><span class="line">f()</span><br><span class="line">( function() &#123;&#125; )();</span><br></pre></td></tr></table></figure></p><p>加分号;后不报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//会报错</span><br><span class="line">var f = function() &#123;&#125;;</span><br><span class="line">f()</span><br><span class="line">;( function() &#123;&#125; )();</span><br></pre></td></tr></table></figure></p><h4 id="，-，！比（-）立即执行方式少一个字符"><a href="#，-，！比（-）立即执行方式少一个字符" class="headerlink" title="+，-，！比（ ）立即执行方式少一个字符"></a>+，-，！比（ ）立即执行方式少一个字符</h4><p>通过+，-，！这三个符号运行的匿名函数比（）运行的匿名函数可以减少一个字符的使用<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">( function() &#123;&#125; );</span><br><span class="line">~ function() &#123;&#125;;</span><br></pre></td></tr></table></figure></p><p>不过这不影响使用(  )还是+，-，！ 配合使用函数表达式，这里只是提取这个现象出来。</p><h4 id="难点立即执行的demo分析"><a href="#难点立即执行的demo分析" class="headerlink" title="难点立即执行的demo分析"></a>难点立即执行的demo分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new(function P()&#123;console.log(1)&#125;)()</span><br></pre></td></tr></table></figure><p>以上相当于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new (function P()&#123;console.log(1)&#125;)()</span><br></pre></td></tr></table></figure></p><p>左侧是new表达式，右侧是一个立即执行的函数；<br>右侧立即执行的函数其实就是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function P()&#123;console.log(1)&#125;</span><br><span class="line">P()</span><br></pre></td></tr></table></figure></p><p>所以以上相当于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function P()&#123;console.log(1)&#125;</span><br><span class="line">new P()</span><br></pre></td></tr></table></figure></p><p>问题：为什么new(function() {})()，new可以与()紧挨着，不用空格；<br>因为(function() {})()是一个函数表达式语句，可以挨着，也可以不挨着，都不会报错<br>你把new当成+ - ！ ~来看，就好理解了；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ function() &#123;&#125;; //不紧挨着，不报错</span><br><span class="line">~function() &#123;&#125;; //紧挨着，不报错</span><br></pre></td></tr></table></figure></p><h4 id="自运行-参考资料"><a href="#自运行-参考资料" class="headerlink" title="自运行 参考资料"></a>自运行 参考资料</h4><p><a href="http://www.softwhy.com/article-2022-1.html" target="_blank" rel="noopener">JavaScript 小括号()分组运算符</a><br><a href="https://www.cnblogs.com/lenther2002/p/5894964.html" target="_blank" rel="noopener">JS中函数定义和函数表达式的区别</a><br><a href="https://www.zhihu.com/question/20249179" target="_blank" rel="noopener">JavaScript 匿名函数有哪几种执行方式?</a></p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自运行函数写法形式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mongoose 与 mongodb笔记</title>
      <link href="/2019/03/24/mongoose_mongodb/"/>
      <url>/2019/03/24/mongoose_mongodb/</url>
      
        <content type="html"><![CDATA[<p>关于 mongoose 与 mongodb笔记 暂时以问答方式叙述。</p><h2 id="mongoose-与-mongodb-基本知识"><a href="#mongoose-与-mongodb-基本知识" class="headerlink" title="mongoose 与 mongodb 基本知识"></a>mongoose 与 mongodb 基本知识</h2><h3 id="什么是mongodb服务端和客户端"><a href="#什么是mongodb服务端和客户端" class="headerlink" title="什么是mongodb服务端和客户端"></a>什么是mongodb服务端和客户端</h3><p>启动mongodb服务端，cmd命令为 mongod；这表明在电脑上启动了mongodb服务，启动了mongodb服务端；<br>启动mongodb客户端，cmd命令为 mongo；此命令执行后，cmd处于输入状态，可以对数据库进行增删改查；<br>以上两面命令 都基于mongodb安装目录(C:\Program Files\MongoDB\Server\4.0\bin)下的mongod.exe和mongo.exe；</p><h3 id="在哪些目录下执行mongo等命令才能连接数据库"><a href="#在哪些目录下执行mongo等命令才能连接数据库" class="headerlink" title="在哪些目录下执行mongo等命令才能连接数据库?"></a>在哪些目录下执行mongo等命令才能连接数据库?</h3><p>启动mongodb有两层意思，一个是启动mongodb服务器，一个是启动mongodb的客户端mongo。<br>上面两个动作没有目录限制，这个命令是全局的，在任意目录上都启动cmd都可以操作MongoDB数据库。<br>整个电脑，任何项目创建的数据库，都可以通过任意目录下，启动<br>cmd都可以查到，并且对数据库进行增删改查操作。</p><h3 id="启动mongodb-以及数据库、表格的查看"><a href="#启动mongodb-以及数据库、表格的查看" class="headerlink" title="启动mongodb 以及数据库、表格的查看"></a>启动mongodb 以及数据库、表格的查看</h3><p>主要为两个命令：<br>mongod //启动mongod 服务器，这是一切操作数据库的基础准备工作<br>mongo //启动mongodb客户端，用来连接mongodb并进行相关数据的查询<br>具体步骤如下：</p><h4 id="在任意目录下启动cmd-执行-mongod"><a href="#在任意目录下启动cmd-执行-mongod" class="headerlink" title="在任意目录下启动cmd 执行 mongod;"></a>在任意目录下启动cmd 执行 mongod;</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ mongod</span><br><span class="line">2019-03-24T11:25:33.479+0800 I CONTROL  [main] Automatically disabling TLS 1.0, to force-enable TLS 1.0 specify --sslDisabledProtocols &apos;none&apos;</span><br><span class="line">2019-03-24T11:25:33.483+0800 I CONTROL  [initandlisten] MongoDB starting : pid=8380 port=27017 dbpath=C:\data\db\ 64-bit host=UO4SB7YL9WOZ3OK</span><br><span class="line">2019-03-24T11:25:33.483+0800 I CONTROL  [initandlisten] targetMinOS: Windows 7/Windows Server 2008 R2</span><br><span class="line">2019-03-24T11:25:33.483+0800 I CONTROL  [initandlisten] db version v4.0.6</span><br><span class="line">2019-03-24T11:25:33.483+0800 I CONTROL  [initandlisten] git version: caa42a1f75a56c7643d0b68d3880444375ec42e3</span><br><span class="line">2019-03-24T11:25:33.483+0800 I CONTROL  [initandlisten] allocator: tcmalloc</span><br><span class="line">2019-03-24T11:25:33.483+0800 I CONTROL  [initandlisten] modules: none</span><br><span class="line">2019-03-24T11:25:33.484+0800 I CONTROL  [initandlisten] build environment:</span><br><span class="line">2019-03-24T11:25:33.484+0800 I CONTROL  [initandlisten]     distmod: 2008plus-ssl</span><br><span class="line">2019-03-24T11:25:33.484+0800 I CONTROL  [initandlisten]     distarch: x86_64</span><br><span class="line">2019-03-24T11:25:33.484+0800 I CONTROL  [initandlisten]     target_arch: x86_64</span><br><span class="line">2019-03-24T11:25:33.484+0800 I CONTROL  [initandlisten] options: &#123;&#125;</span><br><span class="line">2019-03-24T11:25:33.486+0800 I STORAGE  [initandlisten] exception in initAndListen: NonExistentPath: Data directory C:\data\db\ not found., terminating</span><br><span class="line">2019-03-24T11:25:33.486+0800 I NETWORK  [initandlisten] shutdown: going to close listening sockets...</span><br><span class="line">2019-03-24T11:25:33.486+0800 I CONTROL  [initandlisten] now exiting</span><br><span class="line">2019-03-24T11:25:33.486+0800 I CONTROL  [initandlisten] shutting down with code:100</span><br></pre></td></tr></table></figure><h4 id="接着执行-mongo；"><a href="#接着执行-mongo；" class="headerlink" title="接着执行 mongo；"></a>接着执行 mongo；</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ mongo</span><br><span class="line">MongoDB shell version v4.0.6</span><br><span class="line">connecting to: mongodb://127.0.0.1:27017/?gssapiServiceName=mongodb</span><br><span class="line">Implicit session: session &#123; &quot;id&quot; : UUID(&quot;4f84c125-8db8-4d3a-ad61-5c85b2817fb7&quot;) &#125;</span><br><span class="line">MongoDB server version: 4.0.6</span><br></pre></td></tr></table></figure><p>此时命令窗口处于等待输入命令的状态，就像输入node后，等待执行的情况。</p><h4 id="数据库、表格的查看；"><a href="#数据库、表格的查看；" class="headerlink" title="数据库、表格的查看；"></a>数据库、表格的查看；</h4><p>此时在此cmd窗口，接着输入以下命令，对数据库进行增删改查：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ mongo</span><br><span class="line">MongoDB shell version v4.0.6</span><br><span class="line">connecting to: mongodb://127.0.0.1:27017/?gssapiServiceName=mongodb</span><br><span class="line">Implicit session: session &#123; &quot;id&quot; : UUID(&quot;4f84c125-8db8-4d3a-ad61-5c85b2817fb7&quot;) &#125;</span><br><span class="line">MongoDB server version: 4.0.6</span><br><span class="line">show dbs  //显示MongoDB目前有多少数据库</span><br><span class="line">admin           0.000GB</span><br><span class="line">config          0.000GB</span><br><span class="line">douban-test     0.000GB</span><br><span class="line">douban-trailer  0.000GB</span><br><span class="line">local           0.000GB</span><br><span class="line">test            0.000GB</span><br><span class="line">yyy             0.000GB</span><br><span class="line">use yyy //使用yyy数据库，use 数据库name，有此name就是用此数据库，没有就是创建数据库</span><br><span class="line">switched to db yyy</span><br><span class="line">show tables //显示数据库有多少表格</span><br><span class="line">fruits</span><br><span class="line">db.fruits.find() //显示 fruits 表格的数据内容</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5c964dbe52f3fd21d06da3a0&quot;), &quot;category&quot; : &quot;apple&quot;, &quot;name&quot; : &quot;apple&quot;, &quot;__v&quot; : 0 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5c964dca541443051483e3c8&quot;), &quot;category&quot; : &quot;apple&quot;, &quot;name&quot; : &quot;apple&quot;, &quot;__v&quot; : 0 &#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/shirly77/p/6536327.html" target="_blank" rel="noopener">更多信息点击</a></p><h3 id="用mongodb原生命令还是mongoose操作数据库？"><a href="#用mongodb原生命令还是mongoose操作数据库？" class="headerlink" title="用mongodb原生命令还是mongoose操作数据库？"></a>用mongodb原生命令还是mongoose操作数据库？</h3><p>在这里只讨论node端。<br>值得注意的是，我们大多不通过mongodb原生命令操作数据库，而是通过mongoose；<br>一个是mongoose 更能优雅地进行MongoDB对象建模，<br>而且Mongoose写了很多mongodb的验证机制、类型转换与业务逻辑模板，然后提供几个简单的api给我们，简化了工作，等等。<br>因此在实际项目开发中，包括连接数据库以及之后的所有操作都是通过mongoose来操作。<br>因此建议不用太去花太多时间去看mongodb的api教程，稍微了解下即可，然后多看看mongoose的相关操作。</p><h3 id="花更多时间学mongodb还是mongoose教程？"><a href="#花更多时间学mongodb还是mongoose教程？" class="headerlink" title="花更多时间学mongodb还是mongoose教程？"></a>花更多时间学mongodb还是mongoose教程？</h3><p>请参看《用mongodb原生命令还是mongoose操作数据库？》。</p><h3 id="要不要手动建文件夹目录data-db？"><a href="#要不要手动建文件夹目录data-db？" class="headerlink" title="要不要手动建文件夹目录data\db？"></a>要不要手动建文件夹目录data\db？</h3><p>我在刚接触 mongodb时，以为启动mongodb要建文件夹目录，用来存放数据库数据，其实不必了。<br>只要在cmd上启动好mongodb服务器就好，其他的就交给项目使用mongoose来操作mongodb就好。<br>不要创建什么数据库文件夹目录。</p><h3 id="经典demo-创建数据库、表格和数据"><a href="#经典demo-创建数据库、表格和数据" class="headerlink" title="经典demo-创建数据库、表格和数据"></a>经典demo-创建数据库、表格和数据</h3><h4 id="demo-代码"><a href="#demo-代码" class="headerlink" title="demo 代码"></a>demo 代码</h4><p>启动mongodb后，在任意目录下，使用node 执行如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const mongoose = require(&apos;mongoose&apos;);</span><br><span class="line">//mongoose.connect 连接mongodb服务器中的数据库，newdbName是数据库名，有则连，无此name数据，就创建</span><br><span class="line">mongoose.connect(&apos;mongodb://localhost:27017/newdbName&apos;,&#123;</span><br><span class="line">    useNewUrlParser:true</span><br><span class="line">&#125;);</span><br><span class="line">//Schema 定义表格Field的类型和规则，这个过程称为 建数据模型</span><br><span class="line">var schema = new mongoose.Schema(&#123; name: &apos;string&apos;, size: &apos;string&apos; &#125;);</span><br><span class="line">//Model 将Schema定义的模型继承过来，生成表格tables,这里生成的名字为 Tank，在数据库中表格名是复数，见《的解释》</span><br><span class="line">var Model = mongoose.model(&apos;Tank&apos;, schema);</span><br><span class="line">//new Model()此方法用来表格数据的增删改查,</span><br><span class="line">var small = new Model(&#123; size: &apos;small&apos; &#125;);</span><br><span class="line">small.save(function (err) &#123;</span><br><span class="line">  if (err) return handleError(err);</span><br><span class="line">  console.log(&apos;创建成功&apos;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="mongodb客户端mongo检测是否生成成功"><a href="#mongodb客户端mongo检测是否生成成功" class="headerlink" title="mongodb客户端mongo检测是否生成成功"></a>mongodb客户端mongo检测是否生成成功</h4><p>将以上代码复制到js中，然后 node 该js试试，如果出现创建成功；<br>然后任意目录下 启动cmd，打开mongodb客户端，查看newdbName数据库是否生成，以下是正常生成的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Administrator@UO4SB7YL9WOZ3OK MINGW64 ~/Desktop</span><br><span class="line">$ mongo</span><br><span class="line">MongoDB shell version v4.0.6</span><br><span class="line">connecting to: mongodb://127.0.0.1:27017/?gssapiServiceName=mongodb</span><br><span class="line">Implicit session: session &#123; &quot;id&quot; : UUID(&quot;a6d3c14e-703d-44d8-851f-60dbb5ad2b9e&quot;) &#125;</span><br><span class="line">MongoDB server version: 4.0.6</span><br><span class="line">show dbs</span><br><span class="line">admin           0.000GB</span><br><span class="line">config          0.000GB</span><br><span class="line">douban-test     0.000GB</span><br><span class="line">douban-trailer  0.000GB</span><br><span class="line">local           0.000GB</span><br><span class="line">newdbName       0.000GB</span><br><span class="line">onedb           0.000GB</span><br><span class="line">test            0.000GB</span><br><span class="line">twodb           0.000GB</span><br><span class="line">yyy             0.000GB</span><br><span class="line">use newdbName</span><br><span class="line">switched to db newdbName</span><br><span class="line">show tables</span><br><span class="line">tanks</span><br><span class="line">db.tanks.find()</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5c974d5df84c0d2b9450f43c&quot;), &quot;size&quot; : &quot;small&quot;, &quot;__v&quot; : 0 &#125;</span><br></pre></td></tr></table></figure><h3 id="mongodb、mongoose概念"><a href="#mongodb、mongoose概念" class="headerlink" title="mongodb、mongoose概念"></a>mongodb、mongoose概念</h3><p>本节内容参考如下，如有疑问点击如下连接详细了解。<br><a href="https://www.cnblogs.com/chris-oil/p/9142795.html" target="_blank" rel="noopener">参考1</a><br><a href="http://www.runoob.com/mongodb/mongodb-databases-documents-collections.html" target="_blank" rel="noopener">参考2</a></p><h4 id="mongodb-与-传统数据库-概念对比"><a href="#mongodb-与-传统数据库-概念对比" class="headerlink" title="mongodb 与 传统数据库 概念对比"></a>mongodb 与 传统数据库 概念对比</h4><figure class="image-box">                <img src="/image/mongodb/db.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="mongodb-、mongoose-与-传统数据库-概念对比"><a href="#mongodb-、mongoose-与-传统数据库-概念对比" class="headerlink" title="mongodb 、mongoose 与 传统数据库 概念对比"></a>mongodb 、mongoose 与 传统数据库 概念对比</h4><p>结合 《经典创建数据库、添加表格和数据 demo》一起看<br><figure class="image-box">                <img src="/image/mongodb/mongoose.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="mongoose核心概念-与-数据库知识-对应关系"><a href="#mongoose核心概念-与-数据库知识-对应关系" class="headerlink" title="mongoose核心概念 与 数据库知识 对应关系"></a>mongoose核心概念 与 数据库知识 对应关系</h4><p>结合 《经典创建数据库、添加表格和数据 demo》一起看<br><figure class="image-box">                <img src="/image/mongodb/index.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li>mongodb中说的集合，其实就是tables，通过model生成；</li><li>mongodb中说的文档，其实就是tables的行数据，通过model实例生成；</li><li>mongoose的重点在Schema和model，其实与数据直接打交道最多的是model；</li><li>至于生成或连接数据库，就是mongoose.connect方法。</li></ul><h3 id="mongoose-model第一个参数的复数才是tables名字！！"><a href="#mongoose-model第一个参数的复数才是tables名字！！" class="headerlink" title="mongoose.model第一个参数的复数才是tables名字！！"></a>mongoose.model第一个参数的复数才是tables名字！！</h3><p>mongoose.model(abc,oneSchema)定义的第一个参数abc,abc并非tables表格名字,它的复数才是，数据库中的表格名字是abces。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let Model = mongoose.model(&quot;fruit&quot;,Schema);</span><br><span class="line">let apple = new Model(&#123;</span><br><span class="line">        category:&apos;apple&apos;,</span><br><span class="line">        name:&apos;apple&apos;</span><br><span class="line">    &#125;);</span><br><span class="line">apple.save()</span><br><span class="line"></span><br><span class="line">cmd中执行命令：</span><br><span class="line">show tables，</span><br><span class="line">名字是fruits,非 fruit。</span><br></pre></td></tr></table></figure></p><h3 id="创建或连接数据库"><a href="#创建或连接数据库" class="headerlink" title="创建或连接数据库"></a>创建或连接数据库</h3><p>创建和连接数据库一般通过mongoose，用的命令都是mongoose.connect。</p><p>在任意目录cmd，然后执行如下命令，看到mongodb服务器中有数据库twodb；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mongo</span><br><span class="line">show dbs</span><br><span class="line">admin           0.000GB</span><br><span class="line">config          0.000GB</span><br><span class="line">local           0.000GB</span><br><span class="line">newdbName       0.000GB</span><br><span class="line">onedb           0.000GB</span><br><span class="line">test            0.000GB</span><br><span class="line">twodb           0.000GB</span><br></pre></td></tr></table></figure></p><p>例如我现在要连接 数据库twodb，步骤如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(&apos;mongodb://localhost:27017/twodb&apos;,&#123;</span><br><span class="line">    useNewUrlParser:true</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如上，mongodb://localhost:27017/ 这是默认写法，twodb是数据库写法，<br>当twodb这个数据库在mongodb存在时，就连接此数据库，当不存在时，就是创建名为twodb的数据库。</p><h3 id="mongodb-localhost-27017-dbName"><a href="#mongodb-localhost-27017-dbName" class="headerlink" title="mongodb://localhost:27017/dbName"></a>mongodb://localhost:27017/dbName</h3><p>我们如果要连接dbName数据库，为什么mongoose.connect的时候，却要写成mongodb://localhost:27017/twodb;<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(&apos;mongodb://localhost:27017/twodb&apos;)</span><br></pre></td></tr></table></figure></p><p>那么为什么要这样呢。<br><strong>原来这是mongodb的标准 URI 连接语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]</span><br></pre></td></tr></table></figure><ul><li>mongodb:// 这是固定的格式，必须要指定。</li><li>username:password@ 可选项，如果设置，在连接数据库服务器之后，驱动都会尝试登陆这个数据库</li><li>host1 必须的指定至少一个host, host1 是这个URI唯一要填写的。它指定了要连接服务器的地址。如果要连接复制集，请指定多个主机地址。</li><li>portX 可选的指定端口，如果不填，默认为27017</li><li>/database 如果指定username:password@，连接并验证登陆指定数据库。若不指定，默认打开 test 数据库。</li><li>?options 是连接选项。如果不使用/database，则前面需要加上/。所有连接选项都是键值对name=value，键值对之间通过&amp;或;（分号）隔开<br>这里就不展开了，<a href="http://www.runoob.com/mongodb/mongodb-connections.html" target="_blank" rel="noopener">更详细的请点击这里了解</a>。</li></ul><p>一般使用mongoose.connect(‘mongodb://localhost:27017/twodb’)连接即可。</p><h3 id="mongodb目录"><a href="#mongodb目录" class="headerlink" title="mongodb目录"></a>mongodb目录</h3><p>C:\Program Files\MongoDB\Server\4.0\bin</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/chris-oil/p/9142795.html" target="_blank" rel="noopener">深入浅出mongoose—–包括mongoose基本所有操作,非常实用!!!!!</a><br><a href="https://www.cnblogs.com/shirly77/p/6536327.html" target="_blank" rel="noopener">mongodb 怎样检测 安装成功 以及mongodb的一些增删改查命令</a><br><a href="http://www.runoob.com/mongodb/mongodb-query.html" target="_blank" rel="noopener">MongoDB 教程</a></p>]]></content>
      
      
      <categories>
          
          <category> mongoose </category>
          
          <category> mongodb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongoose </tag>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>webpack笔记</title>
      <link href="/2019/03/03/webpack/"/>
      <url>/2019/03/03/webpack/</url>
      
        <content type="html"><![CDATA[<h2 id="webpack常用知识"><a href="#webpack常用知识" class="headerlink" title="webpack常用知识"></a>webpack常用知识</h2><h3 id="sourcemap的处理"><a href="#sourcemap的处理" class="headerlink" title="sourcemap的处理"></a>sourcemap的处理</h3><h4 id="css模块-sourcemap的处理"><a href="#css模块-sourcemap的处理" class="headerlink" title="css模块 sourcemap的处理"></a>css模块 sourcemap的处理</h4><p>给一下loader加上sourceMap: true，就可以做到css的sourcemap调试。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: /\.(sc|c|sa)ss$/,</span><br><span class="line">        use: [</span><br><span class="line">          &apos;style-loader&apos;, &#123;</span><br><span class="line">            loader: &apos;css-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;postcss-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              ident: &apos;postcss&apos;,</span><br><span class="line">              sourceMap: true,</span><br><span class="line">              plugins: (loader) =&gt; [require(&apos;autoprefixer&apos;)(&#123;browsers: [&apos;&gt; 0.15% in CN&apos;]&#125;)]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;sass-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><h4 id="js模块-sourcemap的处理"><a href="#js模块-sourcemap的处理" class="headerlink" title="js模块 sourcemap的处理"></a>js模块 sourcemap的处理</h4><p>很简单，加一个这个配置即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devtool: &apos;inline-source-map&apos;, // 开发阶段开启 sourcemap</span><br></pre></td></tr></table></figure></p><h4 id="要不要配置index-html"><a href="#要不要配置index-html" class="headerlink" title="要不要配置index.html"></a>要不要配置index.html</h4><p>有时候容易误解，webpack会自动生成index.html，这是不对的。<br>入口文件index.html必须要自己手动配置例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//index.html</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>其实webpack只是一个js打包器，会把index.html用到的js全部打包成一个js，就是上面的index.js。<br>只是我们可以通过webpack的插件html-webpack-plugin，写一个index.html模板，不用手动输入index.js的引用，且不用每次手动将index.html拷贝到build目录。<br>将上面的index.html，改成模板，其实就是就是去掉这句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>改成的index.html如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//index.html模板</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>所以在项目中，你必须写一个index.html，或者一个index.html模板。<br>看这个章节加深 项目中index.html 的理解：《webpack常用知识 —解决css文件或者js文件名字哈希值变化的问题》</p><h4 id="output-publicPath-output-path-exports-context-devServer-publicPath"><a href="#output-publicPath-output-path-exports-context-devServer-publicPath" class="headerlink" title="output.publicPath output.path exports.context devServer.publicPath"></a>output.publicPath output.path exports.context devServer.publicPath</h4><ul><li>exports.context 与 output.path<br>exports.context 是提供一个全局的根目录，为配置提供方便,你也可不配置；如果配置此目录下面的output.path 基于此目录。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">context: path.resolve(__dirname, &apos;src&apos;),</span><br><span class="line">output: &#123;</span><br><span class="line">  path: &apos;version1.0.0&apos;,</span><br><span class="line">  publicPath: &apos;/&apos;,</span><br><span class="line">  filename: &apos;assets/[name].[hash:8].js&apos;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ul><p>相当于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  path: path.resolve(__dirname, &apos;version1.0.0/version1.0.0&apos;),</span><br><span class="line">  publicPath: &apos;/&apos;,</span><br><span class="line">  filename: &apos;assets/[name].[hash:8].js&apos;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><ul><li>output.publicPath<br>output.publicPath是给index.html文件内所以link或js引用，在原编辑结果下，在最左侧统一加一个目录，通常也可不配置。<br>如：<br>不加output.publicPath<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">context: path.resolve(__dirname, &apos;src&apos;),</span><br><span class="line">output: &#123;</span><br><span class="line">  path: &apos;version1.0.0&apos;,</span><br><span class="line">  filename: &apos;assets/[name].[hash:8].js&apos;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ul><p>编译出来的index.html为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;robots&quot; content=&quot;noindex, nofollow&quot;&gt;</span><br><span class="line">    &lt;title&gt;React App Pro&lt;/title&gt;</span><br><span class="line">    &lt;link rel=&quot;preload&quot; href=&quot;assets/css/1.db782111.css&quot;  as=&quot;style&quot;&gt;</span><br><span class="line">    &lt;link rel=&quot;preload&quot; href=&quot;assets/css/style.db782111.css&quot;  as=&quot;style&quot;&gt;</span><br><span class="line">    &lt;link rel=&quot;preload&quot; href=&quot;assets/vendors.db782111.js&quot; as=&quot;script&quot;&gt;</span><br><span class="line">    &lt;link rel=&quot;preload&quot; href=&quot;assets/client.db782111.js&quot; as=&quot;script&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot; src=&quot;assets/vendors.db782111.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot; src=&quot;assets/client.db782111.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>加了output.publicPath<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">context: path.resolve(__dirname, &apos;src&apos;),</span><br><span class="line">output: &#123;</span><br><span class="line">  path: &apos;version1.0.0&apos;,</span><br><span class="line">  publicPath: &apos;/&apos;,</span><br><span class="line">  filename: &apos;assets/[name].[hash:8].js&apos;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>编译出来的index.html每个引用路径前都加了一个’/‘<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;preload&quot; href=&quot;/assets/css/1.2e0f42df.css&quot;  as=&quot;style&quot;&gt;</span><br><span class="line">&lt;link rel=&quot;preload&quot; href=&quot;/assets/css/style.2e0f42df.css&quot;  as=&quot;style&quot;&gt;</span><br><span class="line">&lt;link rel=&quot;preload&quot; href=&quot;/assets/vendors.2e0f42df.js&quot; as=&quot;script&quot;&gt;</span><br><span class="line">&lt;link rel=&quot;preload&quot; href=&quot;/assets/client.2e0f42df.js&quot; as=&quot;script&quot;&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;/assets/vendors.2e0f42df.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;/assets/client.2e0f42df.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><ul><li>devServer.publicPath<br>这么没什么说的，默认配置为 ‘/‘，大多时候我们不会去改，使用默认配置。</li></ul><h3 id="给css加前缀-postcss-loader"><a href="#给css加前缀-postcss-loader" class="headerlink" title="给css加前缀  postcss-loader"></a>给css加前缀  postcss-loader</h3><p><a href="https://www.webpackjs.com/loaders/postcss-loader/#options" target="_blank" rel="noopener">postcss-loader</a>有很多用处，其中之一就是给各个浏览器添加css3兼容样式。</p><p>安装 postcss-loader 和 autoprefixer。 使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: /\.(sc|c|sa)ss$/,</span><br><span class="line">        use: [</span><br><span class="line">          &apos;style-loader&apos;, &#123;</span><br><span class="line">            loader: &apos;css-loader&apos;,</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;postcss-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              ident: &apos;postcss&apos;,//这里一定要定义一个唯一的名字，一般喜欢定义为postcss，你也可以定义任意其他唯一名字</span><br><span class="line">              //&gt; 0.15% in CN 大致是指兼容什么范围内的浏览器，这样写就行，一定要设置，否则可能不加前缀，</span><br><span class="line">              //且数值一定要设置合适，否则设置浏览器太新，也可能不会生成前缀</span><br><span class="line">              plugins: (loader) =&gt; [require(&apos;autoprefixer&apos;)(&#123;browsers: [&apos;&gt; 0.15% in CN&apos;]&#125;)]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;sass-loader&apos;,</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><p>如果配置了  postcss-loader，如果你还使用了happypack,就必须要 在根目录 (通常是webpack.comfig.js同级目录)配置 postcss.config.js。详细请看下面章节 《构建与性能优化–happypack》</p><h3 id="抽离css样式文件"><a href="#抽离css样式文件" class="headerlink" title="抽离css样式文件"></a>抽离css样式文件</h3><p>注意：1.webpack4开始使用mini-css-extract-plugin ，1-3版本可以用 extract-text-webpack-plugin。<br>     2.只有 mode: ‘production’ 插件才生效。<br>     3.开发阶段使用style-loader就行了<br>方法：<br>1.mode: ‘production’<br>2.抽离只需将原先style-loader的对象换成mini-css-extract-plugin；<br>3.配置plugins；</p><p>配置代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">const MiniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;);</span><br><span class="line">...</span><br><span class="line">mode: &apos;production&apos;,</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">        test: /\.(sc|c|sa)ss$/,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader, &#123;</span><br><span class="line">            loader: &apos;css-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;postcss-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              ident: &apos;postcss&apos;,</span><br><span class="line">              sourceMap: true,</span><br><span class="line">              plugins: (loader) =&gt; [require(&apos;autoprefixer&apos;)(&#123;browsers: [&apos;&gt; 0.15% in CN&apos;]&#125;)]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;sass-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line"> ....</span><br><span class="line"> plugins: [</span><br><span class="line">   new MiniCssExtractPlugin(&#123;</span><br><span class="line">     filename: &apos;[name][hash].css&apos;, // 设置最终输出的文件名，这个name最终根据output.filename一致。</span><br><span class="line">     chunkFilename: &apos;[id][hash].css&apos;</span><br><span class="line">   &#125;)</span><br><span class="line"> ],</span><br></pre></td></tr></table></figure><p>以下是css未从html上抽离的原先配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: /\.(sc|c|sa)ss$/,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &apos;style-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,&#123;</span><br><span class="line">            loader: &apos;css-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &apos;postcss-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              ident: &apos;postcss&apos;,</span><br><span class="line">              sourceMap: true,</span><br><span class="line">              plugins: (loader) =&gt; [require(&apos;autoprefixer&apos;)(&#123;browsers: [&apos;&gt; 0.15% in CN&apos;]&#125;)]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;sass-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="压缩css"><a href="#压缩css" class="headerlink" title="压缩css"></a>压缩css</h3><p>所谓压缩代码，就是把css压缩成紧凑的一行。<br>注意：1.webpack5内置压缩 ，4版本可以设置插件optimize-css-assets-webpack-plugin即可。<br>     2.只有 mode: ‘production’ 。<br>配置代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const OptimizeCSSAssetsPlugin = require(&apos;optimize-css-assets-webpack-plugin&apos;);</span><br><span class="line">...</span><br><span class="line">mode: &apos;production&apos;</span><br><span class="line">...</span><br><span class="line">optimization: &#123;</span><br><span class="line">    minimizer: [</span><br><span class="line">      new OptimizeCSSAssetsPlugin(&#123;&#125;), // 压缩CSS插件</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="解决css文件或者js文件名字哈希值变化的问题"><a href="#解决css文件或者js文件名字哈希值变化的问题" class="headerlink" title="解决css文件或者js文件名字哈希值变化的问题"></a>解决css文件或者js文件名字哈希值变化的问题</h3><p>html-webpack-plugin插件，可以把打包后的css或js文件引用直接注入到HTML模板中，这样就不用每次手动修改文件引用了。<br>因此，只要项目中使用了hash，就必须配套使用html-webpack-plugin。<br>另外如果要使用模板html，也必须配套使用html-webpack-plugin。<br>当然，你也可以不使用模板，就算有哈希值，你不怕麻烦，当然也可以不适用html-webpack-plugin,你自己手写html，然后将打包生成的js\css文件手动引用也是可以的。<br>配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">new HtmlWebpackPlugin(&#123;</span><br><span class="line">  title: &apos;AICODER test&apos;, // 默认值：Webpack App</span><br><span class="line">  filename: &apos;index.html&apos;, // 默认值： &apos;index.html&apos;</span><br><span class="line">  template: path.resolve(__dirname, &apos;src/main.html&apos;),</span><br><span class="line">  minify: &#123;</span><br><span class="line">    collapseWhitespace: true, // 折叠空白</span><br><span class="line">    removeComments: true, // 是否移除注释</span><br><span class="line">    removeAttributeQuotes: true // 移除属性的引号</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="每次打包自动清除上一个dist目录"><a href="#每次打包自动清除上一个dist目录" class="headerlink" title="每次打包自动清除上一个dist目录"></a>每次打包自动清除上一个dist目录</h3><p>使用插件：clean-webpack-plugin，配置如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;);</span><br><span class="line">plugins: [</span><br><span class="line">    new CleanWebpackPlugin([&apos;dist&apos;])</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="压缩图片"><a href="#压缩图片" class="headerlink" title="压缩图片"></a>压缩图片</h3><p>使用loader：image-webpack-loader，一定在url-loader之前执行image-webpack-loader。<br>image-webpack-loader可以让原来90kb的图片，变成70kb，而不怎么影响质量。<br>配置如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: /\.(png|svg|jpg|gif|jpeg)$/,</span><br><span class="line">        include: [path.resolve(__dirname, &apos;src/&apos;)],</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &apos;url-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: 10000</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;image-webpack-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              mozjpeg: &#123;</span><br><span class="line">                progressive: true,</span><br><span class="line">                quality: 65</span><br><span class="line">              &#125;,</span><br><span class="line">              optipng: &#123;</span><br><span class="line">                enabled: false</span><br><span class="line">              &#125;,</span><br><span class="line">              pngquant: &#123;</span><br><span class="line">                quality: &apos;65-90&apos;,</span><br><span class="line">                speed: 4</span><br><span class="line">              &#125;,</span><br><span class="line">              gifsicle: &#123;</span><br><span class="line">                interlaced: false</span><br><span class="line">              &#125;,</span><br><span class="line">              webp: &#123;</span><br><span class="line">                quality: 75</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><h3 id="file-loader-与-url-loader-异同"><a href="#file-loader-与-url-loader-异同" class="headerlink" title="file-loader 与 url-loader 异同"></a>file-loader 与 url-loader 异同</h3><p>他们都是用来处理项目中图片的。<br>file-loader 有的功能，基本上url-loader都用；<br>而且url-loader还可以将图片进行base64压缩的功能（你可以不使用此功能）；<br>因此，项目中使用url-loader而不适用file-loader。<br>url-loader 配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: /\.(png|svg|jpg|gif|jpeg)$/,</span><br><span class="line">        include: [path.resolve(__dirname, &apos;src/&apos;)],</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &apos;url-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: 10000 //1kb以内的图片将被base64压缩</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><p>url-loader将图片进行base64压缩后就是一串DataURL：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    background: url(data:image/png;base64,UklGRkYwAABXRUJQVlA4WAoAAAAQAAAA/QIA8AAAQUxQSMAcAAABb…KnjLJNbGNAMFRe2WQhUfMAAAA19AAAkbAAAAAAAAAAAAAAABrYAAAAAD0gAAAAAAAAAAAAAAAA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在基本上常用的浏览器和移动端都可很好兼容DataURL，所以可以放心使用。<br>base64压缩图片为一串DataURL的好处在于减少html页面的http请求。缺点在于会加大打包文件大小。<br>一般网页性能优化时：<br>对于小图片，会使用base64压缩，减少http请求；<br>对于大图片，还是使用http请求。</p><h3 id="字体文件处理"><a href="#字体文件处理" class="headerlink" title="字体文件处理"></a>字体文件处理</h3><p>字体文件处理同图片文件处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: /\.(woff|woff2|eot|ttf|otf)$/,</span><br><span class="line">    include: [path.resolve(__dirname, &apos;src/&apos;)],</span><br><span class="line">    use: [</span><br><span class="line">      &#123;</span><br><span class="line">        loader: &apos;file-loader&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="代理proxy的几张图片"><a href="#代理proxy的几张图片" class="headerlink" title="代理proxy的几张图片"></a>代理proxy的几张图片</h3><p>备用，以后再分析<br><figure class="image-box">                <img src="/image/webpack/proxy1.jpg" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/proxy2.jpg" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/proxy3.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="外部扩展-externals"><a href="#外部扩展-externals" class="headerlink" title="外部扩展(externals)"></a>外部扩展(externals)</h3><p> 把一个模块做成外部依赖也就是用cdn的方式依赖，不会打包到 js文件中。<br> 例如lodash,jquery基本上每个页面都要用到，这个时候把它们放在index.html模板中，<br> 每个组件都可以通过externals定义的名称进行引用。<br> 从而可以减少打包后js的大小。<br> 配置如下：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//index.html模板中</span><br><span class="line">&lt;script</span><br><span class="line">  src=&quot;https://code.jquery.com/jquery-3.1.0.js&quot;</span><br><span class="line">  integrity=&quot;sha256-slogkvB1K3VOkzAI8QITxV3VzpOnkeNVsKvtkYLMjfk=&quot;</span><br><span class="line">  crossorigin=&quot;anonymous&quot;&gt;</span><br><span class="line"></span><br><span class="line">  //webpack.config.js</span><br><span class="line">   externals: &#123;  // 把一个模块做成外部依赖，不会打包到 js文件中。</span><br><span class="line">      jquery: &apos;jQuery&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    //index.js使用jquery</span><br><span class="line">    import $ from &apos;jquery&apos;; //注意是小写</span><br></pre></td></tr></table></figure></p><h3 id="webpack-bundle-analyzer统计分析"><a href="#webpack-bundle-analyzer统计分析" class="headerlink" title="webpack-bundle-analyzer统计分析"></a>webpack-bundle-analyzer统计分析</h3><p>注意，这个是在开发环境下使用,配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const BundleAnalyzerPlugin = require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin;</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">   new BundleAnalyzerPlugin(), // 打包模块报表</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure></p><p>配置好后，执行npm start ，会自动在浏览器打开分析页面：<br><figure class="image-box">                <img src="/image/webpack/analyzer.png" alt="" title="" class="">                <p></p>            </figure><br>由图看出，loadsh.js的体积最大，经过分析，可以将loadsh.js做成外部依赖，从而减少打包后js的体积。</p><h3 id="分离-库与业务代码"><a href="#分离-库与业务代码" class="headerlink" title="分离 库与业务代码"></a>分离 库与业务代码</h3><h4 id="配置方法一"><a href="#配置方法一" class="headerlink" title="配置方法一"></a>配置方法一</h4><p>配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">   filename: &apos;[name].[hash].js&apos;, //定义库代码以外的代码打包成的js appIndex.54c949dd739536531ad5.js</span><br><span class="line">   chunkFilename: &apos;[name].chunk.js&apos;,//定义库代码打包成的js customChunkNameQQ.chunk.js</span><br><span class="line">   path: path.resolve(__dirname, &apos;dist&apos;) //打包后输出的路径</span><br><span class="line"> &#125;,</span><br><span class="line">optimization: &#123;</span><br><span class="line">   splitChunks: &#123;</span><br><span class="line">           cacheGroups: &#123;</span><br><span class="line">             commons: &#123;</span><br><span class="line">                chunks: &apos;initial&apos;,</span><br><span class="line">                test: path.resolve(__dirname,&apos;node_modules&apos;),//匹配到的文件都将被一起打包成库js</span><br><span class="line">                enforce: true,</span><br><span class="line">                name: &apos;customChunkNameQQ&apos;,//定义打包后[name]值</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure></p><p>库与业务代码分离 使用的是splitChunks配置，其实它是一个插件，被整合到webpack4了。<br>这个插件的思路是，利用test匹配文件，只要匹配到的就打包成库js，剩下没有被匹配到的，就被打包成业务js；<br>所以如果test匹配不到任何文件，将不会有库js生成，所有的js资源都会被剩下，都被打包到业务js中。</p><p>以下就是一个例子，只有业务js生成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">   appIndex:&apos;./src/index.js&apos;</span><br><span class="line"> &#125;,</span><br><span class="line"> optimization: &#123;</span><br><span class="line">   splitChunks: &#123;</span><br><span class="line">           cacheGroups: &#123;</span><br><span class="line">             commons: &#123;</span><br><span class="line">                chunks: &apos;initial&apos;,</span><br><span class="line">                test: path.resolve(__dirname,&apos;node_modules11&apos;),//因为项目没有node_modules11目录,将只会有一个业务js生成</span><br><span class="line">                enforce: true,</span><br><span class="line">                name: &apos;customChunkNameQQ&apos;,</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p> <strong>webpack打包的原则就是这样，如果没有插件,所有的js将被webpack系统打包成一个js，如果有插件做代码分离，插件匹配的部分将被插件打包成js，剩下的将被webpack系统打包成一个js，如果插件没有匹配到任何js，,所有的js将被webpack系统打包成一个js</strong></p><p>还有其他几种定义方法：</p><h4 id="显示配置方法-推荐"><a href="#显示配置方法-推荐" class="headerlink" title="显示配置方法(推荐)"></a>显示配置方法(推荐)</h4><p>注意下面这个示例配置有一点点问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//将&apos;lodash&apos;,&apos;axios&apos;两个库的代码合并打包成一个名字为customChunkNameQQ 的 js，文件；</span><br><span class="line">//剩下所有js包含其他依赖库和业务js将被合并打包成另个一个js。</span><br><span class="line"> entry: &#123;</span><br><span class="line">    appIndex:&apos;./src/index.js&apos;,</span><br><span class="line">    lodashAndAxios:[&apos;lodash&apos;,&apos;axios&apos;],//显示定义需要将这些依赖库打成一个js</span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">              commons: &#123;</span><br><span class="line">                 chunks: &apos;initial&apos;,</span><br><span class="line">                 test: &apos;lodashAndAxios&apos;, //一定要匹配entry对象内，key值，lodashAndAxios就是entry中的key值</span><br><span class="line">                 enforce: true,</span><br><span class="line">                 name: &apos;customChunkNameQQ&apos;,</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>上面配置有些问题，打包后，会生成三个js：<br><figure class="image-box">                <img src="/image/webpack/verder2.png" alt="" title="" class="">                <p></p>            </figure><br>所以修改以上配置，将cacheGroups.commons.name与cacheGroups.commons.test统一定义成entry中的lodashAndAxios这样生成的文件就正常了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 正确配置方法 --&gt;</span><br><span class="line"> entry: &#123;</span><br><span class="line">    appIndex:&apos;./src/index.js&apos;,</span><br><span class="line">    lodashAndAxios:[&apos;lodash&apos;,&apos;axios&apos;],//显示定义需要将这些依赖库打成一个js</span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">              commons: &#123;</span><br><span class="line">                 chunks: &apos;initial&apos;,</span><br><span class="line">                 test: &apos;lodashAndAxios&apos;, //一定要匹配entry对象内，key值，lodashAndAxios就是entry中的key值</span><br><span class="line">                 enforce: true,</span><br><span class="line">                 name: &apos;lodashAndAxios&apos;,</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>打包结果为：<br><figure class="image-box">                <img src="/image/webpack/verder2.png" alt="" title="" class="">                <p></p>            </figure></p><h4 id="直接用test匹配方法"><a href="#直接用test匹配方法" class="headerlink" title="直接用test匹配方法"></a>直接用test匹配方法</h4><p>上面的方法也可以写成如下，效果一样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//将&apos;lodash&apos;,&apos;axios&apos;两个库的代码合并打包成一个名字为customChunkNameQQ 的 js，文件；</span><br><span class="line">//剩下所有js包含其他依赖库和业务js将被合并打包成另个一个js。</span><br><span class="line"> entry: &#123;</span><br><span class="line">    appIndex:&apos;./src/index.js&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">              commons: &#123;</span><br><span class="line">                 chunks: &apos;initial&apos;,</span><br><span class="line">                 test: /lodash|axios/,  //直接使用test去匹配</span><br><span class="line">                 enforce: true,</span><br><span class="line">                 name: &apos;customChunkNameQQ&apos;,</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><h3 id="entry多种配置形式"><a href="#entry多种配置形式" class="headerlink" title="entry多种配置形式"></a>entry多种配置形式</h3><p>入口可以使用 entry 字段来进行配置，webpack 支持配置多个入口来进行构建：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &apos;./src/index.js&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 上述配置等同于</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: &apos;./src/index.js&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 或者配置多个入口</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    foo: &apos;./src/page-foo.js&apos;,</span><br><span class="line">    bar: &apos;./src/page-bar.js&apos;,</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用数组来对多个文件进行打包</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: [</span><br><span class="line">      &apos;./src/foo.js&apos;,</span><br><span class="line">      &apos;./src/bar.js&apos;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后的例子，可以理解为多个文件作为一个入口，webpack 会解析两个文件的依赖后进行打包。</p><p>还有一种形式，就是使用库与业务代码分离optimization.splitChunks时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//将&apos;lodash&apos;,&apos;axios&apos;两个库的代码合并打包成一个名字为customChunkNameQQ 的 js，文件；</span><br><span class="line">//剩下所有js包含其他依赖库和业务js将被合并打包成另个一个js。</span><br><span class="line"> entry: &#123;</span><br><span class="line">    appIndex:&apos;./src/index.js&apos;,</span><br><span class="line">    lodashAndAxios:[&apos;lodash&apos;,&apos;axios&apos;],//显示定义需要将这些依赖库打成一个js</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">  filename: &apos;[name].[hash].js&apos;,//库js剩下的，也就是所谓的业务js</span><br><span class="line">  chunkFilename: &apos;[name].chunk.js&apos;, //打包出来的库js</span><br><span class="line">  path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">&#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        commons: &#123;</span><br><span class="line">           chunks: &apos;initial&apos;,</span><br><span class="line">           test: &apos;lodashAndAxios&apos;,</span><br><span class="line">           enforce: true,</span><br><span class="line">           name: &apos;lodashAndAxios&apos;,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p><strong>entry 值可以是字符串，可以是对象；当entry为对象时，对象元素的key，value；value可以是字符串，也可以是数组。</strong></p><h3 id="生产与开发环境差异配置"><a href="#生产与开发环境差异配置" class="headerlink" title="生产与开发环境差异配置"></a>生产与开发环境差异配置</h3><p>前面提及的使用环境变量的方式可以让我们在不同的构建环境中完成不同的构建需求，这里列举一下常见的 webpack 构建差异配置：</p><ul><li>生产环境可能需要分离 CSS 成单独的文件，以便多个页面共享同一个 CSS 文件</li><li>生产环境需要压缩 HTML/CSS/JS 代码</li><li>生产环境需要压缩图片</li><li>开发环境需要生成 sourcemap 文件</li><li>开发环境需要打印 debug 信息</li><li>开发环境需要 live reload 或者 hot reload 的功能</li></ul><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ul><li>Entry: 入口。</li><li>Module: 模块。在webpack里，一切皆模块，一个模块对应一个文件，webpack会从配置的entry开始递归找出所有依赖的模块。</li><li>Chunk: 代码块。一个Chunk由多个模块组合而成，用于代码合并和分割。</li><li>loader: 模块转换器。</li><li>Plugin: 扩展插件。</li><li>Output: 输出结果。<br>webpack 在启动后会从Entry里配置的Moule开始，递归解析Entry依赖的所有module，每找到一个module，就会根据配置的loader去找出对应的转换规则，对module进行转换后，再解析出当前module依赖的module。这些模块会以entry为单位进行分组，一个entry及其所有依赖的module被分到一个组也就是一个chunk，最后webpack会将所有chunk转换成文件输出。<br><strong>在webpack中chunk概念很重要，也很不好理解，也容易被忽视，其实webpack目的是一个打包工具，然而将整个包打成几个代码块，都是由chunk控制，所以理解chunk对理解webpack，至关重要。</strong></li></ul><h2 id="webpack-黑知识"><a href="#webpack-黑知识" class="headerlink" title="webpack 黑知识"></a>webpack 黑知识</h2><h3 id="合并两个webpack的js配置"><a href="#合并两个webpack的js配置" class="headerlink" title="合并两个webpack的js配置"></a>合并两个webpack的js配置</h3><p>使用webpack-merge即可，配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//webpack.common</span><br><span class="line">module.exports = &#123;&#125;  //module.exports是node的语法，是commonjs标准</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//webpack.dev.js</span><br><span class="line">const merge = require(&apos;webpack-merge&apos;);</span><br><span class="line">const common = require(&apos;./webpack.common&apos;);</span><br><span class="line">let devConfig = &#123;&#125;</span><br><span class="line">module.exports = merge(common, devConfig);</span><br></pre></td></tr></table></figure><h3 id="–watch-与-热更新"><a href="#–watch-与-热更新" class="headerlink" title="–watch 与 热更新"></a>–watch 与 热更新</h3><p>在命令中加入 –watch，可以达到效果：当文件改动时，会自动编译，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;watch&quot;: &quot;npx webpack --watch --config webpack.dev.js&quot;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>自动编译还是不够的，我们还想它能够编译后自动刷新页面，也就是热更新，最常见的是npm start：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;npm webpack-dev-server --config webpack.dev.js&quot;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>其中devServer.hot置为true，就可以达到热更新。</p><p>所以启动 webpack-dev-server，可以达到自动编译(–watch功能)和热更新功能。</p><h3 id="自动编译与热更新三大条件"><a href="#自动编译与热更新三大条件" class="headerlink" title="自动编译与热更新三大条件"></a>自动编译与热更新三大条件</h3><p>需要同时如下配置，才能进行自动编译与热更新：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const webpack = require(&apos;webpack&apos;);</span><br><span class="line"></span><br><span class="line">devServer: &#123;</span><br><span class="line">   hot: true, // 启用 webpack 的模块热替换特性, 这个需要配合： webpack.HotModuleReplacementPlugin插件</span><br><span class="line"> &#125;,</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  new webpack.NamedModulesPlugin(), // 更容易查看(patch)的依赖</span><br><span class="line">  new webpack.HotModuleReplacementPlugin() // 替换插件</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="webpack-dev-server黑知识"><a href="#webpack-dev-server黑知识" class="headerlink" title="webpack-dev-server黑知识"></a>webpack-dev-server黑知识</h3><p>如下，将看到以下几点黑知识：</p><h4 id="为什么是-0-0-0-0；"><a href="#为什么是-0-0-0-0；" class="headerlink" title="为什么是 0.0.0.0；"></a>为什么是 0.0.0.0；</h4><p>当然，服务器也可以设置为127.0.0.1，这个随你，注意的是设置为0.0.0.0时，可能0.0.0.0:58080有问题，在浏览器上改为127即可正常访问。</p><h4 id="npm-start后自动打开浏览器；"><a href="#npm-start后自动打开浏览器；" class="headerlink" title="npm start后自动打开浏览器；"></a>npm start后自动打开浏览器；</h4><h4 id="编译监听的防抖设置；"><a href="#编译监听的防抖设置；" class="headerlink" title="编译监听的防抖设置；"></a>编译监听的防抖设置；</h4><h4 id="忽略监控文件范围设置；"><a href="#忽略监控文件范围设置；" class="headerlink" title="忽略监控文件范围设置；"></a>忽略监控文件范围设置；</h4><h4 id="proxy的代理重写pathRewrite；"><a href="#proxy的代理重写pathRewrite；" class="headerlink" title="proxy的代理重写pathRewrite；"></a>proxy的代理重写pathRewrite；</h4><h4 id="publicPath的黑知识；"><a href="#publicPath的黑知识；" class="headerlink" title="publicPath的黑知识；"></a>publicPath的黑知识；</h4><figure class="image-box">                <img src="/image/webpack/publicPath.jpg" alt="" title="" class="">                <p></p>            </figure><p>publicPath 的优先级高于 contentBase。contentBase 用于配置提供额外静态文件内容的目录，之前提到的 publicPath 是配置构建好的结果以什么样的路径去访问，而 contentBase 是配置额外的静态文件内容的访问路径，即那些不经过 webpack 构建，但是需要在 webpack-dev-server 中提供访问的静态资源（如部分图片等）<br>你不懂contentBase publicPath为什么，没关系，先这样用着。<br>更多配置说明可参考掘金小册的第六章节。</p><p>webpack-dev-server的配置devServer 完整代码及解释如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    clientLogLevel: &apos;warning&apos;, // 可能的值有 none, error, warning 或者 info（默认值)</span><br><span class="line">    hot: true, // 启用 webpack 的模块热替换特性, 这个需要配合： webpack.HotModuleReplacementPlugin插件</span><br><span class="line">    contentBase: path.join(__dirname, &quot;dist&quot;), // 告诉服务器从哪里提供内容， 默认情况下，将使用当前工作目录作为提供内容的目录</span><br><span class="line">    compress: true, // 一切服务都启用gzip 压缩</span><br><span class="line">    host: &apos;0.0.0.0&apos;, // 指定使用一个 host。默认是 localhost。如果你希望服务器外部可访问 0.0.0.0</span><br><span class="line">    port: 58080, // 端口</span><br><span class="line">    open: true, // 是否打开浏览器</span><br><span class="line">    overlay: &#123; // 出现错误或者警告的时候，是否覆盖页面线上错误消息。</span><br><span class="line">      warnings: true,</span><br><span class="line">      errors: true</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    publicPath: &apos;/&apos;, // 此路径下的打包文件可在浏览器中访问。（注意若无特殊要求，一定设置为&apos;/&apos;,默认配置为 &apos;/                   //&apos;，大多时候我们不会去改，使用默认配置。）</span><br><span class="line"></span><br><span class="line">    proxy: &#123; // 设置代理</span><br><span class="line">      &quot;/api&quot;: &#123; // 访问api开头的请求，会跳转到  下面的target配置</span><br><span class="line">        target: &quot;http://192.168.0.102:8080&quot;,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          &quot;^/api&quot;: &quot;/mockjsdata/5/api&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        //以上配置的意思就是 /api/getuser     =&gt;  http://192.168.0.102:8080//mockjsdata/5/api/getuser</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    quiet: true, // necessary for FriendlyErrorsPlugin. 启用 quiet 后，除了初始启动信息之外的任何内容都不会被打印到控制台。这也意味着来自 webpack 的错误或警告在控制台不可见。</span><br><span class="line">    watchOptions: &#123; // 监视文件相关的控制选项</span><br><span class="line">      poll: true, // webpack 使用文件系统(file system)获取文件改动的通知。在某些情况下，不会正常工作。例如，当使用 Network File System (NFS) 时。Vagrant 也有很多问题。在这些情况下，请使用轮询. poll: true。当然 poll也可以设置成毫秒数，比如：  poll: 1000</span><br><span class="line">      ignored: /node_modules/, // 忽略监控的文件夹，正则</span><br><span class="line">      aggregateTimeout: 300 // 默认值，当第一个文件更改，会在重新构建前增加延迟，防抖的功能，如果你连续几次改的文件间隔小于300毫秒，会延迟编译</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="服务器默认读取index-html"><a href="#服务器默认读取index-html" class="headerlink" title="服务器默认读取index.html"></a>服务器默认读取index.html</h3><p>入口HTML若不是index.html则需补全：<br><figure class="image-box">                <img src="/image/webpack/index.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="resolve之默认扩展文件名"><a href="#resolve之默认扩展文件名" class="headerlink" title="resolve之默认扩展文件名"></a>resolve之默认扩展文件名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">    alias: &#123; // 配置别名</span><br><span class="line">      &apos;@&apos;: path.resolve(__dirname, &apos;src/&apos;)</span><br><span class="line">    &#125;,</span><br><span class="line">    extensions: [&quot;.js&quot;, &quot;.vue&quot;, &quot;.json&quot;] // 默认值: [&quot;.js&quot;,&quot;.json&quot;]  模块名字可以省略的后缀名</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h3 id="name-id-hash-chunkhash"><a href="#name-id-hash-chunkhash" class="headerlink" title="[name][id][hash][chunkhash]"></a>[name][id][hash][chunkhash]</h3><h4 id="name"><a href="#name" class="headerlink" title="[name]"></a>[name]</h4><p>所有的name，默认为entry中定义的，如果entry的值为字符串，则默认为main。<br>如：<br>下面代码是entry为字符串时，[name] 为默认的main<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">entry: &apos;./src/index.js&apos;,</span><br><span class="line"></span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">              commons: &#123;</span><br><span class="line">                 chunks: &apos;initial&apos;,</span><br><span class="line">                 test: path.resolve(__dirname,&apos;node_modules&apos;),</span><br><span class="line">                 enforce: true,</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"> output: &#123;</span><br><span class="line">    filename: &apos;[name].[hash].js&apos;,//main.24673fe716edfcec07a9.js</span><br><span class="line">    chunkFilename: &apos;[name].chunk.js&apos;, //commons~main.chunk.js 这里多了一个commons，是因为splitChunks的commons配置的，默认加commons</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line"> new HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: &apos;AICODER 全栈线下实习&apos;, // 默认值：Webpack App</span><br><span class="line">      filename: &apos;indexMyApp.html&apos;, // 默认值： &apos;index.html&apos;</span><br><span class="line">      template: path.resolve(__dirname, &apos;src/tempHtml.html&apos;),</span><br><span class="line">      minify: &#123;</span><br><span class="line">        collapseWhitespace: true,</span><br><span class="line">        removeComments: true, // 是否移除注释</span><br><span class="line">        removeAttributeQuotes: true // 移除属性的引号</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">  new MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: &apos;[name][hash].css&apos;, // main24673fe716edfcec07a9.css</span><br><span class="line">      chunkFilename: &apos;[id][hash].css&apos;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p><p>下面代码是entry为对象时，[name] 为entry的key值，下面的例子，[name]就是appIndex：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">  appIndex:&apos;./src/index.js&apos;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">              commons: &#123;</span><br><span class="line">                 chunks: &apos;initial&apos;,</span><br><span class="line">                 test: path.resolve(__dirname,&apos;node_modules&apos;),</span><br><span class="line">                 enforce: true,</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"> output: &#123;</span><br><span class="line">    filename: &apos;[name].[hash].js&apos;,//appIndex.90feeea169ea4a86288d.js</span><br><span class="line">    chunkFilename: &apos;[name].chunk.js&apos;, //commons~appIndex.chunk.js</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line"> new HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: &apos;AICODER 全栈线下实习&apos;, // 默认值：Webpack App</span><br><span class="line">      filename: &apos;indexMyApp.html&apos;, // 默认值： &apos;index.html&apos;</span><br><span class="line">      template: path.resolve(__dirname, &apos;src/tempHtml.html&apos;),</span><br><span class="line">      minify: &#123;</span><br><span class="line">        collapseWhitespace: true,</span><br><span class="line">        removeComments: true, // 是否移除注释</span><br><span class="line">        removeAttributeQuotes: true // 移除属性的引号</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">  new MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: &apos;[name][hash].css&apos;, // appIndex90feeea169ea4a86288d.css</span><br><span class="line">      chunkFilename: &apos;[id][hash].css&apos;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p><p>可在插件中自定义对应模块的[name]，例如定义splitChunks模块下name: ‘custom_chunkName’，他会覆盖entry中定义的name，由此splitChunks插件生成的文件将[name]值为custom_chunkName:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">entry: &#123;</span><br><span class="line">  appIndex:&apos;./src/index.js&apos;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">              commons: &#123;</span><br><span class="line">                 chunks: &apos;initial&apos;,</span><br><span class="line">                 test: path.resolve(__dirname,&apos;node_modules&apos;),</span><br><span class="line">                 enforce: true,</span><br><span class="line">                 name: &apos;custom_chunkName&apos;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"> output: &#123;</span><br><span class="line">    filename: &apos;[name].[hash].js&apos;,//appIndex.c81ab09b0bd828f71845.js</span><br><span class="line">    chunkFilename: &apos;[name].chunk.js&apos;, //customChunkNameQQ.chunk.js</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">  new MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: &apos;[name][hash].css&apos;, // appIndexc81ab09b0bd828f71845.css</span><br><span class="line">      chunkFilename: &apos;[id][hash].css&apos;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">//其他跟上面代码一样，只列与上不同的代码：</span><br></pre></td></tr></table></figure><p>当然你也可以直接通过filename定义splitChunks模块下输出文件的名字，这个优先级最高：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">  appIndex:&apos;./src/index.js&apos;</span><br><span class="line">&#125;,</span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">              commons: &#123;</span><br><span class="line">                 chunks: &apos;initial&apos;,</span><br><span class="line">                 test: path.resolve(__dirname,&apos;node_modules&apos;),</span><br><span class="line">                 enforce: true,</span><br><span class="line">                 name: &apos;customChunkNameQQ&apos;,</span><br><span class="line">                 filename: &apos;chunckNiceName.js&apos;,</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"> output: &#123;</span><br><span class="line">    filename: &apos;[name].[hash].js&apos;,//appIndex.c81ab09b0bd828f71845.js</span><br><span class="line">    chunkFilename: &apos;[name].chunk.js&apos;, //chunckNiceName.js</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">  new MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: &apos;[name][hash].css&apos;, // appIndexc81ab09b0bd828f71845.css</span><br><span class="line">      chunkFilename: &apos;[id][hash].css&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">//其他跟上面代码一样，只列与上不同的代码：</span><br></pre></td></tr></table></figure><p>关于[name]小结：<br>如果entry为字符串，name值默认为main；<br>如果entry以对象形式，name值为对象的key值；<br>各个插件(如css、js处理插件)可自定义本插件生成的js的文件名，或自定name值覆盖entry中定义的name值。</p><h4 id="id"><a href="#id" class="headerlink" title="[id]"></a>[id]</h4><p>这个最简单，[id]其实就是数字1,2,3,4…..；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    filename: &apos;[name].[hash].js&apos;,</span><br><span class="line">    chunkFilename: &apos;[id].chunk.js&apos;,</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><h4 id="hash"><a href="#hash" class="headerlink" title="[hash]"></a>[hash]</h4><p>这就是一个hash码，值得注意的是，每次build的hash值都是相同的，也就是打包完成后，js\css文件名的hash值都是相同的。<br>hash一个典型特征是，只有有一个文件改变，那么重新打包后hash值将变化，所以使用hash输出文件名的都将变化，<br>所以业务js，必须使用hash，而不能使用chunkhash。</p><h4 id="chunkhash-及-chunkhash-与-hash-的异同"><a href="#chunkhash-及-chunkhash-与-hash-的异同" class="headerlink" title="[chunkhash]及 [chunkhash]与[hash]的异同"></a>[chunkhash]及 [chunkhash]与[hash]的异同</h4><p>依赖库的源码，我们一般单独打包成一个库js，这个js必须使用chunkhash，<br>chunkhash的原则是只要chunkhash对应的模块文件不变，就算其他文件有变化了，重新打包了，改变的是hash值，chunkhash值保持不变。<br><strong>需特别注意的是，在一般情况下，修改文件和增加文件，webpack编译生成chunkhash的策略是不同的，上面所说的只适合修改文件的情况，如果增加文件或删除文件，就算库文件不变，还是会产生不同的chunkhash，原因在与webpack会根据总体文件，为每个文件设置一个index进行编译，增加或删除文件都会改变整体的index，从而导致chunkhash改变，为了防止这一情况，可配置webpack.HashedModuleIdsPlugin</strong><br>关于chunkhash的规则，更多请看章节3.12:《构建与性能优化 之 webpack.HashedModuleIdsPlugin》<br>对于 chunkhash与HashedModuleIdsPlugin 看参看 <a href="https://www.cnblogs.com/zhishaofei/p/8590627.html" target="_blank" rel="noopener">这里</a><br><strong>所以为了利用http缓存，对于依赖源码库js，必须使用chunkhash，业务js必须使用hash，否则将失去库与业务代码分离的意义</strong></p><h3 id="关于chunkFilename"><a href="#关于chunkFilename" class="headerlink" title="关于chunkFilename"></a>关于chunkFilename</h3><p>chunkFilename是用来配置无入口的chunk输出的名字的。<br>1.代码如下，进行打包；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    appIndex:&apos;./src/index.js&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mode: &apos;production&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &apos;[name].[hash].js&apos;,</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        commons: &#123;</span><br><span class="line">           chunks: &apos;initial&apos;,</span><br><span class="line">           test: path.resolve(__dirname,&apos;node_modules&apos;),</span><br><span class="line">           enforce: true,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>打包后生成：<br><figure class="image-box">                <img src="/image/webpack/chunkfilename1.png" alt="" title="" class="">                <p></p>            </figure><br>因为splitChunks.cacheGroups.commons没有定义name，所以输出文件，默认加 commons~….js;</p><p>2.与1其他配置不变，加上name，再打包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">    cacheGroups: &#123;</span><br><span class="line">      commons: &#123;</span><br><span class="line">        ...</span><br><span class="line">         name: &apos;lodashAndAxios&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>打包后生成，我们发现，这个分离出来的代码块，用的是output.filename的配置：<br><figure class="image-box">                <img src="/image/webpack/chunkfilename2.png" alt="" title="" class="">                <p></p>            </figure></p><p>3.与2其他配置不变，加上chunkfilename，再打包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    ...</span><br><span class="line">    chunkFilename: &apos;[name]._chunk_[chunkhash].js&apos;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>打包后生成，我们发现，这个分离出来的代码块，用的是output.chunkFilename的配置：<br><figure class="image-box">                <img src="/image/webpack/chunkfilename3.png" alt="" title="" class="">                <p></p>            </figure></p><p>这单独分离的代码，在entry中没有入口，只通过splitChunks.cacheGroups.test进行匹配，所以chunkFilename 是用来配置没有入口的名称的，<br>如果不配置chunkFilename，将会根据filename输出。不配置splitChunks.cacheGroups.name，会给输出文件名默认加commons~</p><h3 id="chunk的名称"><a href="#chunk的名称" class="headerlink" title="chunk的名称"></a>chunk的名称</h3><p>chunk的名称和entry的配置有关；</p><ul><li>如果entry是一个string或array，只会生成一个chunk，这是的chunk的名称就是main；</li><li>如果entry是一个Object，就可能会出现多个chunk,这时chunk的名称是Object键值对中健的名称。</li></ul><h3 id="从代码分离看chunk与minChunks"><a href="#从代码分离看chunk与minChunks" class="headerlink" title="从代码分离看chunk与minChunks"></a>从代码分离看chunk与minChunks</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">  a: &apos;./path/to/my/entry/file.js&apos;,</span><br><span class="line">  b: &apos;./path/to/my/entry/app.js&apos;,</span><br><span class="line">&#125;</span><br><span class="line">optimization: &#123;</span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">    cacheGroups: &#123;</span><br><span class="line">      commons: &#123;</span><br><span class="line">        &lt;!-- 如果不指定chunks，将会从现有的所有chunk中提取公共代码 --&gt;</span><br><span class="line">         chunks: [&apos;a&apos;,&apos;b&apos;],//a、b是entry中的两个chunk，从a，b中抽取公共的代码，最终会形成一个名字为appCommon的js，和a.js和b.js</span><br><span class="line">         name: &apos;appCommon&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个参数是minChunks，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">minChunks = 2;</span><br><span class="line">chunks = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;]</span><br></pre></td></tr></table></figure></p><p>只要在abcde模块中任意两个模块出现了公共代码的，都被提取。<br>minChunks主要应对，很可能abcde没有一个公共代码，在所有模块中都有的情况。</p><h3 id="dev模式禁chunkhash"><a href="#dev模式禁chunkhash" class="headerlink" title="dev模式禁chunkhash"></a>dev模式禁chunkhash</h3><p>在dev模式下，只能用hash，不能使用chunkhash，否则报错。</p><h3 id="模块解析规则与resolve"><a href="#模块解析规则与resolve" class="headerlink" title="模块解析规则与resolve"></a>模块解析规则与resolve</h3><h4 id="解析相对路径"><a href="#解析相对路径" class="headerlink" title="解析相对路径"></a>解析相对路径</h4><ul><li>查找相对当前模块的路径下是否有对应文件或文件夹</li><li>是文件则直接加载</li><li>是文件夹则继续查找文件夹下的 package.json 文件</li><li>有 package.json 文件则按照文件中 main 字段的文件名来查找文件</li><li>无 package.json 或者无 main 字段则查找 index.js 文件<h4 id="解析模块名"><a href="#解析模块名" class="headerlink" title="解析模块名"></a>解析模块名</h4>查找当前文件目录下，父级目录及以上目录下的 node_modules 文件夹，看是否有对应名称的模块<h4 id="解析绝对路径（不建议使用）"><a href="#解析绝对路径（不建议使用）" class="headerlink" title="解析绝对路径（不建议使用）"></a>解析绝对路径（不建议使用）</h4>直接查找对应路径的文件</li></ul><p>在 webpack 配置中，和模块路径解析相关的配置都在 resolve 字段下。</p><h4 id="resolve-常用配置："><a href="#resolve-常用配置：" class="headerlink" title="resolve 常用配置："></a>resolve 常用配置：</h4><p>module.exports = {<br>   resolve: {<br>      alias: { // 配置别名<br>         utils: path.resolve(<strong>dirname, ‘src/utils’), // 模糊匹配，意味着只要模块路径中携带utils 就可以被替换掉<br>         component$: path.resolve(</strong>dirname, ‘src/component’) // 只会匹配 import ‘component’， 这是精确匹配方法。<br>      },<br>      modules: [<br>        path.resolve(__dirname, ‘node_modules’), // 指定当前目录下的 node_modules 优先查找<br>        ‘node_modules’, // 如果有一些类库是放在一些奇怪的地方的，你可以添加自定义的路径或者目录<br>      ],<br>      mainFiles: [‘index’], //当目录下没有 package.json 文件时，我们说会默认使用目录下的 index.js 这个文件,就是这个字段配置的。// 你可以添加其他默认使用的文件名<br>      extensions: [“.js”, “.vue”, “.json”] // 默认值: [“.js”,”.json”]  模块名字可以省略的后缀名<br>  },<br>}</p><h3 id="loader的规则条件配置"><a href="#loader的规则条件配置" class="headerlink" title="loader的规则条件配置"></a>loader的规则条件配置</h3><p>大多数情况下，配置 loader 的匹配条件时，只要使用 test 字段就好了，很多时候都只需要匹配文件后缀名来决定使用什么 loader，但也不排除在某些特殊场景下，我们需要配置比较复杂的匹配条件。webpack 的规则提供了多种配置形式：</p><ul><li>{ test: … } 匹配特定条件</li><li>{ include: … } 匹配特定路径</li><li>{ exclude: … } 排除特定路径</li><li>{ and: […] }必须匹配数组中所有条件</li><li>{ or: […] } 匹配数组中任意一个条件</li><li><p>{ not: […] } 排除匹配数组中所有条件<br>上述的所谓条件的值可以是：</p></li><li><p>字符串：必须以提供的字符串开始，所以是字符串的话，这里我们需要提供绝对路径</p></li><li>正则表达式：调用正则的 test 方法来判断匹配</li><li>函数：(path) =&gt; boolean，返回 true 表示匹配</li><li>数组：至少包含一个条件的数组</li><li>对象：匹配所有属性值的条件</li></ul><h3 id="关于output"><a href="#关于output" class="headerlink" title="关于output"></a>关于output</h3><p>单个入口是配置方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const config = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: &apos;./path/to/my/entry/file.js&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const config = &#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &apos;bundle.js&apos;,</span><br><span class="line">    path: &apos;/home/proj/public/assets&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>多个入口时配置方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: &apos;./src/app.js&apos;,</span><br><span class="line">    search: &apos;./src/search.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &apos;[name].js&apos;,//多个时，用占位符[name]的方式定义</span><br><span class="line">    path: __dirname + &apos;/dist&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="css-js是怎么嵌入html"><a href="#css-js是怎么嵌入html" class="headerlink" title="css\js是怎么嵌入html"></a>css\js是怎么嵌入html</h3><p>无论output出来一个或多个js，html-webpack-plugin都会将js、css嵌入到html内：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">new HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: &apos;AICODER 全栈线下实习&apos;, // 默认值：Webpack App</span><br><span class="line">      filename: &apos;indexMyApp.html&apos;, // 默认值： &apos;index.html&apos;</span><br><span class="line">      template: path.resolve(__dirname, &apos;src/tempHtml.html&apos;),</span><br><span class="line">      minify: &#123;</span><br><span class="line">        collapseWhitespace: true,</span><br><span class="line">        removeComments: true, // 是否移除注释</span><br><span class="line">        removeAttributeQuotes: true // 移除属性的引号</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br></pre></td></tr></table></figure></p><h3 id="模板index-html的ejs写法与html-webpack-plugin配合"><a href="#模板index-html的ejs写法与html-webpack-plugin配合" class="headerlink" title="模板index.html的ejs写法与html-webpack-plugin配合"></a>模板index.html的ejs写法与html-webpack-plugin配合</h3><p>模板文件index.html可以写ejs，ejs语法允许写js，然后每行用&lt;%= %&gt;包起来即可:<br><figure class="image-box">                <img src="/image/webpack/tpl1.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/tpl2.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/tpl3.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/tpl4.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/tpl5.png" alt="" title="" class="">                <p></p>            </figure></p><p>注意：1.当有需求把一个js放在html 的header上，一个在body上时，可以定义模板script引用，此时必须设置inject为fasle，表示不适用插件默认嵌入。<br>2.上面ejs模板上一定要写成htmlWebpackPlugin，否则undefined，目前不知道为什么写成HtmlWebpackPlugin就可以关联到插件html-webpack-plugin</p><h3 id="多页面html的配置打包"><a href="#多页面html的配置打包" class="headerlink" title="多页面html的配置打包"></a>多页面html的配置打包</h3><p>要生成多个html，就需要在webpack.config.js中多配置几次new  html-webpack-plugin<br><figure class="image-box">                <img src="/image/webpack/mutilPage1.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/mutilPage2.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/mutilPage3.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/mutilPage4.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/mutilPage5.png" alt="" title="" class="">                <p></p>            </figure></p><h3 id="autoprefixer-配置-postcss-loader"><a href="#autoprefixer-配置-postcss-loader" class="headerlink" title="autoprefixer 配置 (postcss-loader)"></a>autoprefixer 配置 (postcss-loader)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">要生成多个html，就需要在webpack.config.js中多配置几次new  html-webpack-plugin</span><br><span class="line">&#123;</span><br><span class="line">  loader: &apos;postcss-loader&apos;,</span><br><span class="line">  options: &#123;</span><br><span class="line">    ident: &apos;postcss&apos;,</span><br><span class="line">    sourceMap: true,</span><br><span class="line">    //根据中国使用浏览器情况统计，兼容使用率大于百分之0.15的所有浏览器</span><br><span class="line">    plugins: (loader) =&gt; [require(&apos;autoprefixer&apos;)(&#123;browsers: [&apos;&gt; 0.15% in CN&apos;]&#125;)]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">browsers: [&apos;&gt; 5% in US&apos;] //根据美国使用浏览器情况统计，兼容使用率大于百分之5的所有浏览器</span><br><span class="line">browsers: [&apos;last 5 versions&apos;] //兼容所有浏览器最新的五个版本</span><br></pre></td></tr></table></figure><p><a href="https://github.com/browserslist/browserslist#best-practices" target="_blank" rel="noopener">点击查看更多</a></p><h3 id="html内img图片引用路径"><a href="#html内img图片引用路径" class="headerlink" title="html内img图片引用路径"></a>html内img图片引用路径</h3><p>在html或ejs模板文件，此时如果写绝对路径引用图片是没问题的，如果要使用相对路径，就必须使用require，<br>这是index.html文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> &lt;div class=img&gt;</span><br><span class="line">     &lt;img src=&quot;$&#123; require(&apos;./assets/img/WechatIMG92.jpeg&apos;) &#125;&quot;  alt=&quot;标志&quot; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>这是ejs模板文件：<br><figure class="image-box">                <img src="/image/webpack/htmltpl.png" alt="" title="" class="">                <p></p>            </figure><br>不过在项目中，所以类型的，对图片的引用，使用绝对路径都没问题，只有使用相对路径才会有以上问题。<br>不过在css中，引用图片，使用相对路径和绝对路径都没问题。</p><h3 id="给图片指定生成目录"><a href="#给图片指定生成目录" class="headerlink" title="给图片指定生成目录"></a>给图片指定生成目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: /\.(png|svg|jpg|gif|jpeg)$/,</span><br><span class="line">        include: [path.resolve(__dirname, &apos;src/&apos;)],</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &apos;url-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: 10000,</span><br><span class="line">              //name既可以定义文件名字，也可以定义css生成路径，占位符[ext]是扩展externals的简写指图片扩展名</span><br><span class="line">              name: &apos;image/[name]_image.[ext]&apos;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="带ejs的入口index-html模板文件示例"><a href="#带ejs的入口index-html模板文件示例" class="headerlink" title="带ejs的入口index.html模板文件示例"></a>带ejs的入口index.html模板文件示例</h3><p>对ejs的一点解释</p><ol><li>&lt;%  %&gt; 不输出显示到浏览器上的写法，专门用来运算js；</li><li>&lt;%=  %&gt; 加了一个=后，输出显示到浏览器上的写法；<br>完整示例看 看<a href="https://github.com/YeWills/webpack-code/tree/ejsHtml" target="_blank" rel="noopener">github 仓库中的 ejsHtml 分支 demo </a>，对应的tag发布版本为ejsHtmlV1.0</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">  &lt;script</span><br><span class="line">  src=&quot;https://code.jquery.com/jquery-3.1.0.js&quot;</span><br><span class="line">  integrity=&quot;sha256-slogkvB1K3VOkzAI8QITxV3VzpOnkeNVsKvtkYLMjfk=&quot;</span><br><span class="line">  crossorigin=&quot;anonymous&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"> &lt;% for (var key of htmlWebpackPlugin.files.css) &#123; %&gt;</span><br><span class="line">  &lt;link href=&quot;&lt;%= key %&gt;&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line"> &lt;% &#125; %&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;dmo&quot;&gt;我是模板文件自带的内容1&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;% for (var key in htmlWebpackPlugin.files) &#123; %&gt;</span><br><span class="line">        &lt;%= key %&gt; : &lt;%= JSON.stringify(htmlWebpackPlugin.files.css) %&gt;</span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=img&gt;</span><br><span class="line">      &lt;img src=&quot;$&#123; require(&apos;./assets/img/WechatIMG92.jpeg&apos;) &#125;&quot;  alt=&quot;标志&quot; /&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">  &lt;script</span><br><span class="line">  src=&quot;&lt;%= htmlWebpackPlugin.files.chunks.appIndex.entry %&gt;&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script</span><br><span class="line">  src=&quot;&lt;%= htmlWebpackPlugin.files.chunks.lodashAndAxios.entry %&gt;&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="两个横杠命令"><a href="#两个横杠命令" class="headerlink" title="两个横杠命令"></a>两个横杠命令</h3><p>webpack –devtool source-map;<br>发现凡是带两个–的命令，都是配置 webpack 的配置项。</p><h2 id="构建与性能优化"><a href="#构建与性能优化" class="headerlink" title="构建与性能优化"></a>构建与性能优化</h2><p>构建与性能优化很多思路受益于kangshen，膜拜下大神。</p><h3 id="升级到最新的webpack稳定版本"><a href="#升级到最新的webpack稳定版本" class="headerlink" title="升级到最新的webpack稳定版本"></a>升级到最新的webpack稳定版本</h3><p>这无疑是性能显著提升的</p><h3 id="babel-loader-的优化"><a href="#babel-loader-的优化" class="headerlink" title="babel-loader 的优化"></a>babel-loader 的优化</h3><p>把 loader 应用的文件范围缩小,也就是说，配置loader的include来限定查询范围<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rules: [ </span><br><span class="line">  &#123;</span><br><span class="line">    test: /\.jsx?/,</span><br><span class="line">    include: [ </span><br><span class="line">      path.resolve(__dirname, &apos;src&apos;), </span><br><span class="line">      // 限定只在 src 目录下的 js/jsx 文件需要经 babel-loader 处理</span><br><span class="line">      // 通常我们需要 loader 处理的文件都是存放在 src 目录</span><br><span class="line">    ],</span><br><span class="line">    use: &apos;babel-loader&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">  // ...</span><br><span class="line">],</span><br></pre></td></tr></table></figure></p><h4 id="设置exclude"><a href="#设置exclude" class="headerlink" title="设置exclude"></a>设置exclude</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  modules: [</span><br><span class="line">    path.resolve(__dirname, &apos;node_modules&apos;), // 使用绝对路径指定 node_modules，不做过多查询</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  // 删除不必要的后缀自动补全，少了文件后缀的自动匹配，即减少了文件路径查询的工作</span><br><span class="line">  // 其他文件可以在编码时指定后缀，如 import(&apos;./index.scss&apos;)</span><br><span class="line">  extensions: [&quot;.js&quot;], </span><br><span class="line"></span><br><span class="line">  // 避免新增默认文件，编码时使用详细的文件路径，代码会更容易解读，也有益于提高构建速度</span><br><span class="line">  mainFiles: [&apos;index&apos;],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="启用缓存"><a href="#启用缓存" class="headerlink" title="启用缓存"></a>启用缓存</h4><p>总代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: /\.js$/,</span><br><span class="line">    exclude: /(node_modules)/, // 加快编译速度，不包含node_modules文件夹内容</span><br><span class="line">    use: &#123;</span><br><span class="line">      loader: &apos;babel-loader&apos;,</span><br><span class="line">      options: &#123;</span><br><span class="line">        cacheDirectory: true // 启用缓存，提高编译速度，生成和开发都要如此设置</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="生产下库与业务js分离"><a href="#生产下库与业务js分离" class="headerlink" title="生产下库与业务js分离"></a>生产下库与业务js分离</h3><p>对于单页面应用 生产下库与业务js分离，可以利用浏览器http请求缓存机制，提高下一次访问速度。<br>对于多页面应用 生产下库与业务js分离，可以利用浏览器http请求缓存机制，提高访问下一页的速度。</p><p>更多详细库与业务js分离配置方法 请看 1.13章节 《webpack常用知识–分离 库与业务代码》</p><p>更多信息，看<a href="https://github.com/YeWills/webpack-code/tree/master" target="_blank" rel="noopener">demo示例</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        commons: &#123;</span><br><span class="line">           chunks: &apos;initial&apos;,</span><br><span class="line">           test: &apos;lodashAndAxios&apos;,</span><br><span class="line">           enforce: true,</span><br><span class="line">           name: &apos;lodashAndAxios&apos;,//对应覆盖entry.chunkFilename中的name占位符[name]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>optimization.splitChunks.cacheGroups.chunks也可以是函数，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        styles: &#123;</span><br><span class="line">           chunks: &apos;all&apos;,</span><br><span class="line">           test: /\.(sc|c|sa)ss$/,</span><br><span class="line">           enforce: true,</span><br><span class="line">           name: &apos;styles&apos;,//对应覆盖entry.chunkFilename中的name占位符[name]</span><br><span class="line">        &#125;,</span><br><span class="line">        commons: &#123;</span><br><span class="line">           chunks: (chunk) =&gt; &#123;</span><br><span class="line">             return chunk.name !== &apos;styles&apos;;//避开上面定义的styles chunk</span><br><span class="line">           &#125;,</span><br><span class="line">           test: &apos;lodashAndAxios&apos;,</span><br><span class="line">           enforce: true,</span><br><span class="line">           name: &apos;lodashAndAxios&apos;,//对应覆盖entry.chunkFilename中的name占位符[name]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="使用花括号-进行import"><a href="#使用花括号-进行import" class="headerlink" title="使用花括号{}进行import"></a>使用花括号{}进行import</h3><p>例如 使用lodash，推荐这种写法import { filter } from ‘lodash’;<br>用什么就花括号，取什么。</p><h3 id="依赖包和业务js分离"><a href="#依赖包和业务js分离" class="headerlink" title="依赖包和业务js分离"></a>依赖包和业务js分离</h3><p>一般依赖包如loadsh，jq这些很少改变，而一般只改变业务js，分开打包后，依赖包js文件名，每次发布版本都是一样的，<br>浏览器的http请求缓存机制，浏览器不会重复请求，直接拿浏览器缓存的依赖包js即可，可提高性能，减少流量。每次发布版本，<br>只需要请求业务js。</p><h3 id="设置外部依赖"><a href="#设置外部依赖" class="headerlink" title="设置外部依赖"></a>设置外部依赖</h3><p>将笨重的很多页面都用到的js通过externals设置成外部依赖。</p><h3 id="利用浏览器http缓解机制"><a href="#利用浏览器http缓解机制" class="headerlink" title="利用浏览器http缓解机制"></a>利用浏览器http缓解机制</h3><p>利用浏览器http缓解机制，库与js代码分离，可以提高速度，减少流量。(这个应该属于 项目性能优化范畴)</p><h3 id="autodll-webpack-plugin"><a href="#autodll-webpack-plugin" class="headerlink" title="autodll-webpack-plugin"></a>autodll-webpack-plugin</h3><p>该插件能够快速打包，能把第三方依赖的文件能提前进行预编译打包到一个文件里面去。提高了构建速度。因为很多第三方插件我们并不需要改动它，所以我们想这些第三方库在我们每次编译的时候不要再次构建它就好,可以非常明显提高rebuild速度<br>该插件有两个作用：<br>1、可以明显提高rebuild的速度；<br>2、可以调试库源码；</p><p>更多信息，看<a href="https://github.com/YeWills/webpack-code/tree/master" target="_blank" rel="noopener">demo示例</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const AutoDllPlugin = require(&apos;autodll-webpack-plugin&apos;);</span><br><span class="line"> new AutoDllPlugin(&#123;</span><br><span class="line">      filename: &apos;[name]_chunk.js&apos;,</span><br><span class="line">      // 如果需要调试库源码，将inherit设置为true，是调试源码的尖刀利器，不过会影响rebuild速度</span><br><span class="line">      inherit: false,//当为false时，速度更快；当为true时，可以打开webpack没有压缩过的源码sourcemap调试</span><br><span class="line">      inject: true,</span><br><span class="line">      debug: true,</span><br><span class="line">      entry: &#123;</span><br><span class="line">        appVendor: [</span><br><span class="line">          &apos;axios&apos;,</span><br><span class="line">          &apos;lodash&apos;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br></pre></td></tr></table></figure><h3 id="happypack"><a href="#happypack" class="headerlink" title="happypack"></a>happypack</h3><p>webpack 只能一个loader处理完后处理下一个loader，这样，速度就慢，为了同时进行多线程loader，同时处理多个loader，可以使用happypack；<br>配置happypack可以明显提高构建速度。</p><ul><li>其他的都好配置，就postcss-loader 比较特殊，必须要另外新建 postcss.config.js 否则报错；</li><li>happypack 重写原来loader配置时，基本上就是复制，不改变，只有postcss可能稍微改动下</li></ul><p>更多信息，看<a href="https://github.com/YeWills/webpack-code/tree/master" target="_blank" rel="noopener">demo示例</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const HappyPack = require(&apos;happypack&apos;);</span><br><span class="line"> module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(sc|c|sa)ss$/,</span><br><span class="line">        loader: &apos;happypack/loader?id=handerStyle&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"> new HappyPack(&#123;</span><br><span class="line">      id:&apos;handerStyle&apos;,</span><br><span class="line">      loaders:[</span><br><span class="line">        &apos;style-loader&apos;, </span><br><span class="line">        &#123;</span><br><span class="line">          loader: &apos;css-loader&apos;,</span><br><span class="line">          options: &#123;</span><br><span class="line">            sourceMap: true</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &apos;postcss-loader&apos;, </span><br><span class="line">        &#123;</span><br><span class="line">          loader: &apos;sass-loader&apos;,</span><br><span class="line">          options: &#123;</span><br><span class="line">            sourceMap: true</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//postcss.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  ident: &apos;postcss&apos;,</span><br><span class="line">  sourceMap: true,</span><br><span class="line">  plugins: &#123;</span><br><span class="line">    &apos;autoprefixer&apos;: &#123;</span><br><span class="line">      browsers: [&apos;&gt; 0.15% in CN&apos;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="webpack-parallel-uglify-plugin"><a href="#webpack-parallel-uglify-plugin" class="headerlink" title="webpack-parallel-uglify-plugin"></a>webpack-parallel-uglify-plugin</h3><p>生产环境配置。<br>happypack是多线程操作loader进行多线程转译文件；与此相似，webpack-parallel-uglify-plugin是多线程进行压缩js，提高生产环境下的打包速度。<br>更多信息，看<a href="https://github.com/YeWills/webpack-code/tree/master" target="_blank" rel="noopener">demo示例</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    // 使用 ParallelUglifyPlugin 并行压缩输出JS代码</span><br><span class="line">    new ParallelUglifyPlugin(&#123;</span><br><span class="line">      // 传递给 UglifyJS的参数如下：</span><br><span class="line">      uglifyJS: &#123;</span><br><span class="line">        output: &#123;</span><br><span class="line">          /*</span><br><span class="line">           是否输出可读性较强的代码，即会保留空格和制表符，默认为输出，为了达到更好的压缩效果，</span><br><span class="line">           可以设置为false</span><br><span class="line">          */</span><br><span class="line">          beautify: false,</span><br><span class="line">          /*</span><br><span class="line">           是否保留代码中的注释，默认为保留，为了达到更好的压缩效果，可以设置为false</span><br><span class="line">          */</span><br><span class="line">          comments: false</span><br><span class="line">        &#125;,</span><br><span class="line">        compress: &#123;</span><br><span class="line">          /*</span><br><span class="line">           是否在UglifyJS删除没有用到的代码时输出警告信息，默认为输出，可以设置为false关闭这些作用</span><br><span class="line">           不大的警告</span><br><span class="line">          */</span><br><span class="line">          warnings: false,</span><br><span class="line"></span><br><span class="line">          /*</span><br><span class="line">           是否删除代码中所有的console语句，默认为不删除，开启后，会删除所有的console语句</span><br><span class="line">          */</span><br><span class="line">          drop_console: true,</span><br><span class="line"></span><br><span class="line">          /*</span><br><span class="line">           是否内嵌虽然已经定义了，但是只用到一次的变量，比如将 var x = 1; y = x, 转换成 y = 5, 默认为不</span><br><span class="line">           转换，为了达到更好的压缩效果，可以设置为false</span><br><span class="line">          */</span><br><span class="line">          collapse_vars: true,</span><br><span class="line"></span><br><span class="line">          /*</span><br><span class="line">           是否提取出现了多次但是没有定义成变量去引用的静态值，比如将 x = &apos;xxx&apos;; y = &apos;xxx&apos;  转换成</span><br><span class="line">           var a = &apos;xxxx&apos;; x = a; y = a; 默认为不转换，为了达到更好的压缩效果，可以设置为false</span><br><span class="line">          */</span><br><span class="line">          reduce_vars: true</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="ContextReplacementPlugin"><a href="#ContextReplacementPlugin" class="headerlink" title="ContextReplacementPlugin"></a>ContextReplacementPlugin</h3><p>配置ContextReplacementPlugin，是优化配置，下面章节《其他常用插件》有讲</p><h3 id="webpack-HashedModuleIdsPlugin"><a href="#webpack-HashedModuleIdsPlugin" class="headerlink" title="webpack.HashedModuleIdsPlugin"></a>webpack.HashedModuleIdsPlugin</h3><p>打包中chunkhash的规则：<br>当没有删除或增加文件，如果对于chunk的代码没有变化，chunkhash值不会变，可以起到浏览器缓存的作用；<br>但当有删除或增加文件是，如果对应chunk的代码没有变化，打包是，chunkhash还是会变，这不是我们想要的结果，我们只希望对应chunk代码如果没变化，<br>无论其他代码文件删除或增加，chunkhash都不变。<br>（为什么会变，webpack自带打包策略是给每个文件配置了一个数字index，无论增加或删除一个文件，都会打乱整个 index，导致chunkhash变化，<br>HashedModuleIdsPlugin，改变策略为，根据文件路径配置，所以达到了稳定chunkhash）<br>为了达到以上效果，请配置HashedModuleIdsPlugin插件：<br>new webpack.HashedModuleIdsPlugin({<br>  hashDigestLength：20<br>})</p><p>该插件会根据模块的相对路径生成一个四位数的hash作为模块id, 建议用于生产环境。<br>用 HashedModuleIdsPlugin 可以轻松地实现 chunkhash 的稳定化，可以实现持久化缓存。<br>建议生产配置使用，如果使用到了chunkhash，则最好配置HashedModuleIdsPlugin。<br>更多请看章节2.7.4:《webpack 黑知识 之 [name][id][hash][chunkhash][name]》<br>或看官网<br>对于 chunkhash与HashedModuleIdsPlugin 看参看 <a href="https://www.cnblogs.com/zhishaofei/p/8590627.html" target="_blank" rel="noopener">这里</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  new webpack.HashedModuleIdsPlugin(&#123;</span><br><span class="line">    hashDigestLength: 20</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="webpack-NormalModuleReplacementPlugin"><a href="#webpack-NormalModuleReplacementPlugin" class="headerlink" title="webpack.NormalModuleReplacementPlugin"></a>webpack.NormalModuleReplacementPlugin</h3><p>webpack.NormalModuleReplacementPlugin(a,b)编译时，第一个参数通常是正则，第一个参数正则匹配到文件后，会将此文件替换为第二个参数，从而达到生产或开发时，编译不同文件的目的，比如生产和开发时编译不同的路由文件。<br>所以配置时，在webpack.config.plugins中，位于最前面，保证webpack执行编译时，首先启用此插件替换文件。<br>注意的是，此插件的第一个参数一般都设置为正则。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">  new webpack.NormalModuleReplacementPlugin(</span><br><span class="line">    /some\/path\/config\.development\.js/,</span><br><span class="line">    &apos;./config.production.js&apos;</span><br><span class="line">  ),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="webpack-optimize-OccurrenceOrderPlugin"><a href="#webpack-optimize-OccurrenceOrderPlugin" class="headerlink" title="webpack.optimize.OccurrenceOrderPlugin"></a>webpack.optimize.OccurrenceOrderPlugin</h3><p>OccurrenceOrderPlugin插件：根据出现次数为每一个模块或者chunk设置id,经常使用的模块则会获取到较短的id(和前缀树类似)，这可以使id可预测并有效减少文件大小，建议使用在生产环境中～<br><a href="https://www.cnblogs.com/xuepei/p/7992423.html" target="_blank" rel="noopener">参考</a><br>有些说是可以优化排序输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">  new webpack.optimize.OccurrenceOrderPlugin(),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="webpack-optimize-AggressiveMergingPlugin"><a href="#webpack-optimize-AggressiveMergingPlugin" class="headerlink" title="webpack.optimize.AggressiveMergingPlugin"></a>webpack.optimize.AggressiveMergingPlugin</h3><p>AggressiveMergingPlugin用于合并块。<br>AggressiveMergingPlugin用于解决如路由分配不合理，会打包出很多很小的文件，每个文件或许只有几k，却多了很多网络请求，得不偿失。<br>用法很简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">  new webpack.optimize.AggressiveMergingPlugin(),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="react-loadable-懒加载优化生产模式构建速度以及页面访问速度"><a href="#react-loadable-懒加载优化生产模式构建速度以及页面访问速度" class="headerlink" title="react-loadable 懒加载优化生产模式构建速度以及页面访问速度"></a>react-loadable 懒加载优化生产模式构建速度以及页面访问速度</h3><p>这条优化经验受kangshen启发，表示对大神的膜拜，具体思路是：<br>利用react-loadable懒加载，将生产模式下的路由配合react-loadable懒加载，显示哪个路由页面，就编译加载某个路由页面，这样既提高webpack编译速度，又提高页面访问速度。<br>将路由进行懒加载有一个弊端是只能看到你打开页面的报错，没有打开的页面报错你无法看到。</p><p>react-loadable 是2017年5月左右才出现，到如今，GitHub上已经有一万多颗star，是可以比拟react-redux的插件，非常棒，项目中如果有用到懒加载，用这个框架非常好react-loadable</p><h3 id="减少不必要的plugin"><a href="#减少不必要的plugin" class="headerlink" title="减少不必要的plugin"></a>减少不必要的plugin</h3><h2 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h2><h3 id="ContextReplacementPlugin-1"><a href="#ContextReplacementPlugin-1" class="headerlink" title="ContextReplacementPlugin"></a>ContextReplacementPlugin</h3><p>当项目用到moment时，务必使用此插件，可减少打包体积，以下代码为例，匹配moment/locale路径，只加载编译此路径下的/zh-cn|zh-hk|en/的文件。<br>new webpack.ContextReplacementPlugin(/moment[/\]locale$/, /zh-cn|zh-hk|en/)</p><h3 id="webpack-NormalModuleReplacementPlugin-1"><a href="#webpack-NormalModuleReplacementPlugin-1" class="headerlink" title="webpack.NormalModuleReplacementPlugin"></a>webpack.NormalModuleReplacementPlugin</h3><p>用法请看章节《构建与性能优化》</p><h3 id="webpack-DefinePlugin"><a href="#webpack-DefinePlugin" class="headerlink" title="webpack.DefinePlugin"></a>webpack.DefinePlugin</h3><p>此插件定义值时，都需加JSON.stringify。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    new webpack.DefinePlugin(&#123;</span><br><span class="line">      &apos;process.env.ASSET_PATH&apos;: JSON.stringify(&quot;5fa3b9&quot;),</span><br><span class="line">      &apos;process.env.FLAG&apos;: JSON.stringify(true)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p><h3 id="ProvidePlugin"><a href="#ProvidePlugin" class="headerlink" title="ProvidePlugin"></a>ProvidePlugin</h3><p>配置全局变量，自动加载模块，不必到处import或require：<br>例如设置$为全局变量，指向jq。<br>new webpack.ProvidePlugin({<br>  $: ‘jquery’,<br>  jQuery: ‘jquery’<br>})</p><h3 id="webpack-optimize-OccurrenceOrderPlugin-1"><a href="#webpack-optimize-OccurrenceOrderPlugin-1" class="headerlink" title="webpack.optimize.OccurrenceOrderPlugin"></a>webpack.optimize.OccurrenceOrderPlugin</h3><p>用法请看章节《构建与性能优化》</p><h3 id="happypack-1"><a href="#happypack-1" class="headerlink" title="happypack"></a>happypack</h3><p>用法请看章节《构建与性能优化》</p><h3 id="AutoDllPlugin"><a href="#AutoDllPlugin" class="headerlink" title="AutoDllPlugin"></a>AutoDllPlugin</h3><p>用法请看章节《构建与性能优化》</p><h3 id="webpack-parallel-uglify-plugin-1"><a href="#webpack-parallel-uglify-plugin-1" class="headerlink" title="webpack-parallel-uglify-plugin"></a>webpack-parallel-uglify-plugin</h3><p>用法请看章节《构建与性能优化》</p><h3 id="webpack-HashedModuleIdsPlugin-1"><a href="#webpack-HashedModuleIdsPlugin-1" class="headerlink" title="webpack.HashedModuleIdsPlugin"></a>webpack.HashedModuleIdsPlugin</h3><p>用法请看章节《构建与性能优化》</p><h3 id="webpack-optimize-AggressiveMergingPlugin-1"><a href="#webpack-optimize-AggressiveMergingPlugin-1" class="headerlink" title="webpack.optimize.AggressiveMergingPlugin"></a>webpack.optimize.AggressiveMergingPlugin</h3><p>用法请看章节《构建与性能优化》</p><h2 id="webpack-版本变化"><a href="#webpack-版本变化" class="headerlink" title="webpack 版本变化"></a>webpack 版本变化</h2><h3 id="css分离插件"><a href="#css分离插件" class="headerlink" title="css分离插件"></a>css分离插件</h3><p>webpack4.x弃用了extract-text-webpack-plugin，使用mini-css-extract-plugin代替，来做css从html中分离单独成一个css文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">const MiniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;);</span><br><span class="line"> module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(sc|c|sa)ss$/,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader, &#123;</span><br><span class="line">            loader: &apos;css-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;postcss-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              ident: &apos;postcss&apos;,</span><br><span class="line">              sourceMap: true,</span><br><span class="line">              plugins: (loader) =&gt; [require(&apos;autoprefixer&apos;)(&#123;browsers: [&apos;&gt; 0.15% in CN&apos;]&#125;)]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;sass-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: &apos;[name][hash].css&apos;, // 设置最终输出的文件名</span><br><span class="line">      chunkFilename: &apos;[id][hash].css&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure></p><h3 id="webpack注意事项"><a href="#webpack注意事项" class="headerlink" title="webpack注意事项"></a>webpack注意事项</h3><ul><li>不要在生产环境下使用inline模式的source map，因为这会使js文件变得很大，而且会泄露源码。</li><li>尽量写全名称，扩展名也写上 const common = require(‘./webpack.common.js’);不要写成require(‘./webpack.common’)，不利于编译查询。</li><li>线上发布，或CDN优化配置，大部分与合理配置publicpath有关。</li></ul><h2 id="参考和学习资料"><a href="#参考和学习资料" class="headerlink" title="参考和学习资料"></a>参考和学习资料</h2><p><a href="https://ke.qq.com/course/321174" target="_blank" rel="noopener">老马全栈VIP2_02_webpack4配置入门到进阶</a><br><a href="https://www.imooc.com/learn/802" target="_blank" rel="noopener">webpack深入与实战</a><br><a href="https://www.imooc.com/learn/935" target="_blank" rel="noopener">Vue+Webpack打造todo应用</a><br>掘金小册-使用webpack定制前端开发环境<br>吴浩麟-深入浅出webpack<br><a href="https://www.webpackjs.com/" target="_blank" rel="noopener">webpack 官网</a><br>此官网下的四个子模块文档：<br>    <a href="https://www.webpackjs.com/concepts/" target="_blank" rel="noopener">webpack 文档官网_概念</a><br>    <a href="https://www.webpackjs.com/configuration/" target="_blank" rel="noopener">webpack 文档官网_配置</a><br>    <a href="https://www.webpackjs.com/api/" target="_blank" rel="noopener">webpack 文档官网_API</a><br>    <a href="https://www.webpackjs.com/guides/" target="_blank" rel="noopener">webpack 文档官网_指南</a><br>    <a href="https://www.webpackjs.com/loaders/" target="_blank" rel="noopener">webpack 文档官网_loader</a><br>    <a href="https://www.webpackjs.com/plugins/" target="_blank" rel="noopener">webpack 文档官网_插件</a><br><a href="https://segmentfault.com/a/1190000007479892" target="_blank" rel="noopener">webpack学习系列</a><br><a href="https://www.mmxiaowu.com/article/58482332d4352863efb55465" target="_blank" rel="noopener">WebPack 终极配置说明</a><br><a href="https://github.com/YeWills/webpack-code/tree/master" target="_blank" rel="noopener">原创webpack demo 主要应用分支</a><br><a href="https://github.com/YeWills/webpack-code/tree/ejsHtml" target="_blank" rel="noopener">原创webpack demo 模板ejs语法分支</a><br><a href="https://github.com/YeWills/webpack-code/tree/webpack_custom_merge_demo" target="_blank" rel="noopener">原创webpack demo 自定义merge config分支</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React Router</title>
      <link href="/2019/03/03/react_router/"/>
      <url>/2019/03/03/react_router/</url>
      
        <content type="html"><![CDATA[<h2 id="React-Router常见知识"><a href="#React-Router常见知识" class="headerlink" title="React Router常见知识"></a>React Router常见知识</h2><h3 id="HashRouter-还是-BrowserRouter-以及-Router-Route-讲解"><a href="#HashRouter-还是-BrowserRouter-以及-Router-Route-讲解" class="headerlink" title="HashRouter 还是 BrowserRouter 以及 Router  Route 讲解"></a>HashRouter 还是 BrowserRouter 以及 Router  Route 讲解</h3><p>简言之如果项目服务端做了服务端渲染，可以选择BrowserRouter，否则请选择HashRouter，因此一般项目都是HashRouter，因为大多项目么有做服务端渲染。<br>详细见下面（还讲了：利用服务器解析机制，服务器不会解析路由#以后的部分）：<br>摘自《React 实战：设计模式和最佳实践》第15章；<br>react-router 的工作方式，是在组件树顶层放一个 Router 组件，然后在组件树中散落着很多 Route 组件（注意比 Router 少一个“r”），顶层的 Router 组件负责分析监听 URL 的变化，在它保护伞之下的 Route 组件可以直接读取这些信息。</p><p>很明显，Router 和 Route 的配合，就是之前我们介绍过的“提供者模式”，Router 是“提供者”，Route是“消费者”。</p><p>更进一步，Router 其实也是一层抽象，让下面的 Route 无需各种不同 URL 设计的细节，不要以为 URL 就一种设计方法，至少可以分为两种。</p><p>第一种很自然，比如 / 对应 Home 页，/about 对应 About 页，但是这样的设计需要服务器端渲染，因为用户可能直接访问任何一个 URL，服务器端必须能对 /的访问返回 HTML，也要对 /about 的访问返回 HTML。</p><p>第二种看起来不自然，但是实现更简单。<strong>只有一个路径 /，通过 URL 后面的 # 部分来决定路由，/#/ 对应 Home 页，/#/about 对应 About 页。因为 URL 中#之后的部分是不会发送给服务器的，所以，无论哪个 URL，最后都是访问服务器的 / 路径，服务器也只需要返回同样一份 HTML 就可以，然后由浏览器端解析 # 后的部分，完成浏览器端渲染。</strong></p><p>在 react-router，有 BrowserRouter 支持第一种 URL，有 HashRouter 支持第二种 URL。</p><p>因为 create-react-app 产生的应用默认不支持服务器端渲染，为了简单起见，我们在下面的例子中使用 HashRouter，在实际产品中，其实最好还是用 BrowserRouter，这样用户体验更好。</p><p>修改index.js文件，增加下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123;HashRouter&#125; from &apos;react-router-dom&apos;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;HashRouter&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;/HashRouter&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>把 Router 用在 React 组件树的最顶层，这是最佳实践。因为将来我们如果想把 HashRouter 换成 BrowserRouter，组件 App 以下几乎不用任何改变。</p><h3 id="带-与不带-的路由的区别"><a href="#带-与不带-的路由的区别" class="headerlink" title="带#与不带#的路由的区别"></a>带#与不带#的路由的区别</h3><p>利用服务器解析机制，服务器不会解析路由#以后的部分，详细见本章第《HashRouter 还是 BrowserRouter 以及 Router  Route 讲解》</p><h3 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h3><p>摘自《React 实战：设计模式和最佳实践》第15章；<br>我们来看 Content 这个组件，这里会用到 react-router 最常用的两个组件 Route 和 Switch。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const Content = () =&gt; (</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;Switch&gt;</span><br><span class="line">      &lt;Route exact path=&apos;/&apos; component=&#123;Home&#125;/&gt;</span><br><span class="line">      &lt;Route path=&apos;/about&apos; component=&#123;About&#125;/&gt;</span><br><span class="line">    &lt;/Switch&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>Route 组件的 path 属性用于匹配路径，因为我们需要匹配 / 到 Home，匹配 /about 到 About，所以肯定需要两个 Route，但是，我们不能这么写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&apos;/&apos; component=&#123;Home&#125;/&gt;</span><br><span class="line">&lt;Route path=&apos;/about&apos; component=&#123;About&#125;/&gt;</span><br></pre></td></tr></table></figure></p><p>如果按照上面这么写，当访问 /about 页面时，不光匹配 /about，也配中 /，界面上会把 Home 和 About 都渲染出来的。</p><p>解决方法，可以在想要精确匹配的 Route 上加一个属性 exact，或者使用 Switch 组件。</p><p>可以把 Switch 组件看做是 JavaScript 的 switch 语句，像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">switch (条件) &#123;</span><br><span class="line">  case 1: 渲染1; break;</span><br><span class="line">  case 2: 渲染2; break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上往下找第一个匹配的 Route，匹配中了之后，立刻就 break，不继续这个 Switch 下其他的 Route 匹配了。</p><p>可以看到，react-router 巧妙地用 React 组件实现了路由的所有逻辑，印证了那句话：React 世界里一切都是组件。</p><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>摘自《React 实战：设计模式和最佳实践》第15章；<br>在了解了 react-router的基本路由功能之后，再来理解“动态路由”就容易了。</p><p>假设，我们增加一个新的页面叫 Product，对应路径为 /product，但是只有用户登录了之后才显示。如果用静态路由，我们在渲染之前就确定这条路由规则，这样即使用户没有登录，也可以访问 product，我们还不得不在 Product 组件中做用户是否登录的检查。</p><p>如果用动态路由，则只需要在代码中的一处涉及这个逻辑：</p><pre><code>&lt;Switch&gt;  &lt;Route exact path=&apos;/&apos; component={Home}/&gt;  {    isUserLogin() &amp;&amp;    &lt;Route exact path=&apos;/product&apos; component={Product}/&gt;,  }    &lt;Route path=&apos;/about&apos; component={About}/&gt;&lt;/Switch&gt;</code></pre><p>可以用任何条件决定 Route 组件实例是否渲染，比如，可以根据页面宽度、设备类型决定路由规则，动态路由有了最大的自由度。</p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
          <category> React Router </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js设计模式上(面向对象、闭包、命名空间)</title>
      <link href="/2019/03/03/js_design_start/"/>
      <url>/2019/03/03/js_design_start/</url>
      
        <content type="html"><![CDATA[<p>js设计模式分两篇来写，此为上篇。下篇为《js设计模式下》。<br>js设计模式之前需要了解js的面向对象编程、闭包、命名空间编程模式的概念。</p><h1 id="js的面向对象编程"><a href="#js的面向对象编程" class="headerlink" title="js的面向对象编程"></a>js的面向对象编程</h1><p>注意，这里说的是js的面向对象编程，非java面向对象编程。js的面向对象编程与java是有区别的。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>js面向对象编程的核心概念是 类 和 实例(对象)。<br>类 在es6上就是 class类，在es5中就是构造函数中定义一系列的propoty原型<br>实例 就是 new class类，或者 new 构造函数。实例就是对象。<br>而定义类，最后实例化这个类，都是为了得到这个实例对象。重点最终是对象。这就是面向对象的编程。</p><p>简单说，js面向对象编程，就是熟悉使用 class类 来进行js编程。<br>由于react框架的流行，组件都是通过class类编程，因此熟练使用 js的面向对象编程变得更加重要。</p><p>注意的是，js的面向对象编程与java是有区别的。</p><h2 id="new-的理解"><a href="#new-的理解" class="headerlink" title="new 的理解"></a>new 的理解</h2><h3 id="关于new"><a href="#关于new" class="headerlink" title="关于new"></a>关于new</h3><p><a href="https://blog.csdn.net/zhouziyu2011/article/details/60143385" target="_blank" rel="noopener">关于new 的理解</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var baseObj = new Base();</span><br><span class="line">//new操作符具体干了什么呢?其实很简单，就干了三件事情：</span><br><span class="line">var obj  = &#123;&#125;;</span><br><span class="line">var result = Base.call(obj);</span><br><span class="line">obj.__proto__ = Base.prototype;</span><br><span class="line"></span><br><span class="line">if (typeof(result) === &quot;object&quot;)&#123;</span><br><span class="line">  baseObj = result;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">  baseObj = obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是两个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var Test = function()&#123;</span><br><span class="line">            this.html = 1111;</span><br><span class="line">            // return &#123;a:123&#125;;</span><br><span class="line">          &#125;</span><br><span class="line">          var obj = new Test()</span><br><span class="line">          console.log(obj) //&#123;html: 1111&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var Test = function()&#123;</span><br><span class="line">            this.html = 1111;</span><br><span class="line">            return &#123;a:123&#125;;</span><br><span class="line">          &#125;</span><br><span class="line">          var obj = new Test()</span><br><span class="line">          console.log(obj) //&#123;a: 123&#125;</span><br></pre></td></tr></table></figure><h3 id="new-Fn-与-new-Fn的区别"><a href="#new-Fn-与-new-Fn的区别" class="headerlink" title="new Fn() 与 new Fn的区别"></a>new Fn() 与 new Fn的区别</h3><p>function Fn(){<br>    this.name=’weide’;<br>}<br>console.log(new Fn) //Fn {name: “weide”}<br>console.log(new Fn()) //Fn {name: “weide”}<br>看起来二者没有区别，在构造函数Fn不用传参的时候，他们确实没有区别，只有当构造函数需要传参的时候，<br>才必须使用小括号：new Fn()</p><p>下面将讲 面向对象编程三大特征 多态，继承，封装</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>js的多态与java的面向对象多态不同。</p><p>js的多态定义：对同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。<br>以上通俗点的定义就是：对同一个函数作用于不同对象时（也就是同一个函数，接受不同的对象作为参数时），函数执行的结果不同。</p><p>列举多态的几个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//最简单的：</span><br><span class="line">var  a  =  5;</span><br><span class="line">console.log(a);</span><br><span class="line">a=&quot;str&quot;;</span><br><span class="line">console.log(a)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//最经典的：</span><br><span class="line">var makeSound = function(animal) &#123; // 把不变的部分隔离出来</span><br><span class="line">    animal.sound();</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">var Duck = function() &#123;&#125;;</span><br><span class="line">Duck.prototype.sound = function() &#123;</span><br><span class="line">    console.log(&quot;嘎嘎嘎&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">var Chicken = function() &#123;&#125;;</span><br><span class="line">Chicken.prototype.sound = function() &#123;</span><br><span class="line">    console.log(&quot;咯咯咯&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">makeSound( new Duck() ); // 嘎嘎嘎</span><br><span class="line">makeSound( new Chicken() ); // 咯咯咯</span><br></pre></td></tr></table></figure><p>多态的思想实际上是把“做什么”和“谁去做”分离开来，达到 开放-封闭的设计原则。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="原型浅拷贝的痛点"><a href="#原型浅拷贝的痛点" class="headerlink" title="原型浅拷贝的痛点"></a>原型浅拷贝的痛点</h3><p>所有new实例将指向构造函数原型上的引用类型，造成浅拷贝问题，一个实例修改了此引用类型，其他所有实例受此影响。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> function Super()&#123;</span><br><span class="line">    this.colors = [&apos;red&apos;,&apos;blue&apos;,&apos;green&apos;];</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.apples = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">function newF(o, constructor)&#123;</span><br><span class="line">    o.__proto__ = constructor.prototype;</span><br><span class="line">    constructor.call(o); </span><br><span class="line">&#125;</span><br><span class="line">var aa = &#123;&#125;;</span><br><span class="line">var bb = &#123;&#125;;</span><br><span class="line">newF(aa, Super);</span><br><span class="line">newF(bb, Super);</span><br><span class="line">console.log(aa.apples === bb.apples)//true</span><br><span class="line">console.log(aa.colors === bb.colors)//false</span><br></pre></td></tr></table></figure></p><p>以上过程代码等效于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> function Super()&#123;</span><br><span class="line">    this.colors = [&apos;red&apos;,&apos;blue&apos;,&apos;green&apos;];</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.apples = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">var aa = new Super();</span><br><span class="line">var bb = new Super();</span><br><span class="line">console.log(aa.apples === bb.apples)//true</span><br><span class="line">console.log(aa.colors === bb.colors)//false</span><br></pre></td></tr></table></figure></p><p>以上说明了，构造函数 new出来的所有实例，他们会针对同一个构造函数prototype对象被赋值，如果prototype对象里面有引用类型，那么将相互影响，结合上面代码，这情况等同于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> Super.prototype = &#123;apples:&#123;&#125;&#125;;</span><br><span class="line">aa.__proto__ = Super.prototype </span><br><span class="line">//等同于</span><br><span class="line">aa.apples = Super.prototype.apples</span><br></pre></td></tr></table></figure></p><h3 id="es5继承"><a href="#es5继承" class="headerlink" title="es5继承"></a>es5继承</h3><h4 id="套路"><a href="#套路" class="headerlink" title="套路"></a>套路</h4><p>es5继承方法有类继承和原型继承，我们不用去管他们叫什么名字和概念是什么，他们的套路无非三种：<br>1、代理函数(proxy)的构造函数内让父构造函数call一次，就会重写覆盖父构造函数内属性，以此来避免浅拷贝问题。<br>2、将父函数的new 实例对象 赋值给代理函数的prototype。<br>3、将父函数的prototype 赋值给代理函数的prototype。</p><h4 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h4><p>通过以上套路，大致有以下两种方式实现继承：<br>方式一<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//方式一，将父函数的new 实例对象 赋值给代理函数的prototype，弊端 会执行两次父函数</span><br><span class="line"> function Super()&#123;</span><br><span class="line">    this.colors = [&apos;red&apos;,&apos;blue&apos;,&apos;green&apos;];</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.apples = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">function proxy()&#123;</span><br><span class="line">    //执行一次父函数Super</span><br><span class="line">     Super.call(this);</span><br><span class="line">&#125;</span><br><span class="line">//方式一 proxy.prototype直接赋值 new 构造函数</span><br><span class="line">proxy.prototype = new Super();//执行第二次父函数Super</span><br><span class="line">var aa = new proxy();//次步代码 会 重写覆盖父构造函数内属性</span><br><span class="line">var bb = new proxy();</span><br><span class="line">console.log(aa.colors === bb.colors)//true</span><br></pre></td></tr></table></figure></p><p>方式二、此方式与方式一一样，其他代码与方式一都一样，只有一句不同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//方式二，相比方式二的好处在于 父函数 只执行一遍</span><br><span class="line"> ...</span><br><span class="line">proxy.prototype = Super.prototype</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><h4 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h4><p>以上方式都无法解决 prototype 对象的 浅拷贝问题。原因见 《所有new实例将浅拷贝原型上的引用类型 》</p><h4 id="es5最佳继承方式一：与深拷贝函数结合"><a href="#es5最佳继承方式一：与深拷贝函数结合" class="headerlink" title="es5最佳继承方式一：与深拷贝函数结合"></a>es5最佳继承方式一：与深拷贝函数结合</h4><p>传统的继承方式都无法解决prototype的浅拷贝问题，只能引入深拷贝函数，如下代码的deepcopy深拷贝方法，网上有很多，可以去找。<br>所以es5方法写继承最佳方式：父函数.call + proxy.prototype = deepcopy(Super.prototype).<br>简言之 call + 原型赋原型 + 深拷贝<br>作用：<br>call 拷贝 构造函数内属性<br>原型赋原型 拷贝原型方法，避免执行一次父函数<br>深拷贝 避免原型浅拷贝问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Super(name)&#123;</span><br><span class="line">    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.apples = &#123;&#125;;</span><br><span class="line">function Sub(name)&#123;</span><br><span class="line">    Super.call(this);</span><br><span class="line">&#125;</span><br><span class="line">Sub.prototype = deepcopy(Super.prototype);</span><br></pre></td></tr></table></figure><h4 id="es5最佳继承方式二：引用对象不写入父原型上"><a href="#es5最佳继承方式二：引用对象不写入父原型上" class="headerlink" title="es5最佳继承方式二：引用对象不写入父原型上"></a>es5最佳继承方式二：引用对象不写入父原型上</h4><p>es5继承的痛点是无法原型浅拷贝问题，如果能引用对象不写入父原型上，则可放心继承。</p><h3 id="最终极方式：es6-class"><a href="#最终极方式：es6-class" class="headerlink" title="最终极方式：es6 class"></a>最终极方式：es6 class</h3><p>class是es6 的api，是一个语法糖，使用class进行继承，能够轻松进行继承，且无浅拷贝问题。<br>因此推荐使用es6的class类继承方式，代码优雅而简洁，不推荐使用es5。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Super &#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    this.colors = [];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Sub extends Super&#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var instance1 = new Sub();</span><br><span class="line">var instance2 = new Sub();</span><br><span class="line">console.log(instance1.colors === instance2.colors);//false</span><br></pre></td></tr></table></figure><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装这个最好理解，直白的说就是：<br>封装说的就类。类由一系列的方法和属性组成，将一系列的方法和属性封装起来，封装成一个类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class People &#123;</span><br><span class="line">    constructor(name, age) &#123;</span><br><span class="line">        this.name = name</span><br><span class="line">        this.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    eat() &#123;</span><br><span class="line">        alert(`$&#123;this.name&#125; eat something`)</span><br><span class="line">    &#125;</span><br><span class="line">    speak() &#123;</span><br><span class="line">        alert(`My name is $&#123;this.name&#125;, age $&#123;this.age&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p><a href="https://blog.csdn.net/ybdt1201/article/details/53366613" target="_blank" rel="noopener">关于闭包详细知识，可参考我在几年前写的一篇博客，这里只摘取一些必要知识</a>，以下内容基本摘至这篇博客，如有疑问，点击进入了解。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>官方对闭包的定义：所谓“闭包”，指的是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。</p><p>还有一种对闭包更直接明了的说法：<a href="https://www.cnblogs.com/tinkbell/p/3173293.html" target="_blank" rel="noopener">闭包就是有权访问另一个函数作用域中变量的函数。</a><br>分析这句话:<br>　　1.闭包是定义在函数中的函数.<br>　　2.闭包能访问函数内的私有变量.<br>　　3.即使包含函数执行完了, 被闭包引用的变量也得不到释放.</p><p>满足以上定义的，都可称之为闭包。</p><h2 id="三种定义方式"><a href="#三种定义方式" class="headerlink" title="三种定义方式"></a>三种定义方式</h2><p>闭包有三种定义方式，一种就是经典的return方式，一种就是new的方式，一种就是对象方式。<br>我目前看到的闭包就这三种，基本这三种满足了工作中绝大部分需求了。<br>网上有很多人列举了很多闭包方式，其实本质上都是对这三种方式的发展延伸而已。</p><h3 id="return方式"><a href="#return方式" class="headerlink" title="return方式"></a>return方式</h3><p>这种方式最经典，也最为常用，推荐这种写法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function a() &#123;</span><br><span class="line">    var num = 1;</span><br><span class="line">    return function ()&#123;</span><br><span class="line">        num++;</span><br><span class="line">        console.log(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="new-方式"><a href="#new-方式" class="headerlink" title="new 方式"></a>new 方式</h3><p>这种方式之所以被认定为闭包，是因为以下两点理由，下面代码中：<br>1、a是母函数<br>2、inc是a执行后返回，相当于return的函数，此函数绑定了a的私有变量n， 这是决定inc是否为闭包的重要依据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function a()&#123;</span><br><span class="line">  var n = 0;</span><br><span class="line">  this.inc = function () &#123;</span><br><span class="line">    n++;</span><br><span class="line">    console.log(n);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var cc = new a();</span><br><span class="line">cc.inc()//1</span><br><span class="line">cc.inc()//2</span><br></pre></td></tr></table></figure></p><h3 id="对象方式"><a href="#对象方式" class="headerlink" title="对象方式"></a>对象方式</h3><p>下面两个闭包例子，套路都一样，外层定义个对象，然后在母函数内部给这个对象定义一个函数，此函数绑定了私有变量，即为闭包函数。<br>我们姑且称这种定义闭包的方式为对象方式吧。<br>以下方式之所以被认定为闭包，是因为以下两点理由，下面代码中：<br>1、有母函数（下面两个例子母函数是匿名函数，当然也可以定义为非匿名函数）<br>2、母函数执行后，给函数绑定了母函数的私有变量n， 这是决定内部函数是否为闭包的重要依据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">(function() &#123;</span><br><span class="line">    var n = 1;</span><br><span class="line">    obj.count = function () &#123;</span><br><span class="line">                    n++;</span><br><span class="line">                    console.log(n);</span><br><span class="line">                 &#125;;</span><br><span class="line">    </span><br><span class="line">&#125;)()</span><br><span class="line">obj.count();//2</span><br><span class="line">obj.count();//3</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var divDom = $(&apos;#name&apos;);</span><br><span class="line">(function() &#123;</span><br><span class="line">    var n = 1;</span><br><span class="line">    divDom.onclick = function () &#123;</span><br><span class="line">                    n++;</span><br><span class="line">                    console.log(n);</span><br><span class="line">                 &#125;;</span><br><span class="line">    </span><br><span class="line">&#125;)()</span><br><span class="line">divDom.onclick();//2</span><br><span class="line">divDom.onclick();//3</span><br></pre></td></tr></table></figure><h2 id="不是闭包的设计"><a href="#不是闭包的设计" class="headerlink" title="不是闭包的设计"></a>不是闭包的设计</h2><p>列举一下非闭包的设计方式，以此加深对闭包的理解<br>很多人认为自运行匿名函数、命名空间设计模式和原型定义方式都是闭包，我觉得是不对的。</p><h3 id="自运行匿名函数："><a href="#自运行匿名函数：" class="headerlink" title="自运行匿名函数："></a>自运行匿名函数：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//这不是闭包</span><br><span class="line">(function fn()&#123;</span><br><span class="line">          var n = 8;</span><br><span class="line">           console.log(n) ;</span><br><span class="line">      &#125;)();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//这一种是闭包的设计，但并不是因为它是自运行匿名函数的原因，而是因为匿名函数内部return了一个函数的原因，</span><br><span class="line">//这其实就是上面讲的两种闭包设计模式的第一种 return方式</span><br><span class="line">(function fn()&#123;</span><br><span class="line">      var n = 8;</span><br><span class="line">      return function()&#123;</span><br><span class="line">          console.log(n) ;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)();</span><br></pre></td></tr></table></figure><h3 id="js的命名空间写法"><a href="#js的命名空间写法" class="headerlink" title="js的命名空间写法"></a>js的命名空间写法</h3><p>js的命名空间写法不能称之为闭包，它最多是使用了js关于引用对象一处改变，都受改变的特性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//这是命名空间的写法，但不是闭包</span><br><span class="line">var obj = &#123;</span><br><span class="line">  n:8,</span><br><span class="line">  count:function()&#123;</span><br><span class="line">    this.n++;</span><br><span class="line">    console.log(this.n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.count()//9</span><br><span class="line">obj.count()//10</span><br></pre></td></tr></table></figure></p><h3 id="原型定义方式"><a href="#原型定义方式" class="headerlink" title="原型定义方式"></a>原型定义方式</h3><p>还有一些把函数定义在原型上，这本质上也是运用了引用对象的特性，不是闭包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//这不是闭包，是运用了引用对象的特性，才有对象元素值叠加的效果</span><br><span class="line">function a()&#123;</span><br><span class="line">  this.n = 8;</span><br><span class="line">&#125;</span><br><span class="line">a.prototype.count=function()&#123;</span><br><span class="line">  this.n++;</span><br><span class="line">  console.log(this.n);</span><br><span class="line">&#125;</span><br><span class="line">var obj = new a();</span><br><span class="line">obj.count()//9</span><br><span class="line">obj.count()//10</span><br></pre></td></tr></table></figure></p><p> 如果稍微换一下，就行不通了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//这不是闭包</span><br><span class="line">function a()&#123;</span><br><span class="line">  this.n = 8;</span><br><span class="line">&#125;</span><br><span class="line">a.prototype.count=function()&#123;</span><br><span class="line">  this.n++;</span><br><span class="line">  console.log(this.n);</span><br><span class="line">&#125;</span><br><span class="line">var newCount = (new a()).count;</span><br><span class="line">newCount()//NaN</span><br><span class="line">newCount()//NaN</span><br></pre></td></tr></table></figure></p><h2 id="闭包的用处"><a href="#闭包的用处" class="headerlink" title="闭包的用处"></a>闭包的用处</h2><h3 id="定义私有变量"><a href="#定义私有变量" class="headerlink" title="定义私有变量"></a>定义私有变量</h3><p>若不想某些变量被其他函数访问，就可以写一个闭包设计，将变量定义为私有变量，只有闭包函数可以访问，达到其他函数无法访问的目的。</p><h3 id="保存变量值"><a href="#保存变量值" class="headerlink" title="保存变量值"></a>保存变量值</h3><p>这是闭包最经典和关键意义所在，也是闭包函数存在的意义。闭包函数绑定了母函数的变量，每次执行完，此变量不销毁，达到保存变量值的目的。</p><h2 id="运用场景"><a href="#运用场景" class="headerlink" title="运用场景"></a>运用场景</h2><h3 id="保存变量值。"><a href="#保存变量值。" class="headerlink" title="保存变量值。"></a>保存变量值。</h3><h3 id="进行前后两次执行时的比较。"><a href="#进行前后两次执行时的比较。" class="headerlink" title="进行前后两次执行时的比较。"></a>进行前后两次执行时的比较。</h3><h4 id="react-redux的props状态比较"><a href="#react-redux的props状态比较" class="headerlink" title="react-redux的props状态比较"></a>react-redux的props状态比较</h4><p>比如react-redux就是通过闭包的这个特性，保存prop上一次状态，然后跟当前props比较。</p><h4 id="节流和防抖"><a href="#节流和防抖" class="headerlink" title="节流和防抖"></a>节流和防抖</h4><p>这是性能优化经常使用的手段，可以网上查阅，都是用闭包来进行。</p><h4 id="for循环的使用"><a href="#for循环的使用" class="headerlink" title="for循环的使用"></a>for循环的使用</h4><p>错误写法，这种for达不到预期<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//错误写法</span><br><span class="line">function foo()&#123;</span><br><span class="line">    var arr = [];</span><br><span class="line">    for(var i = 0; i &lt; 2; i++)&#123;</span><br><span class="line">        arr[i] = function()&#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">var bar = foo();</span><br><span class="line">console.log(bar[0]());//2</span><br></pre></td></tr></table></figure></p><p>正确写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//正确写法</span><br><span class="line">//为什么能记住当时值，是因为是自运行的函数，每次都会执行一次</span><br><span class="line">function foo()&#123;</span><br><span class="line">    var arr = [];</span><br><span class="line">    for(var i = 0; i &lt; 2; i++)&#123;</span><br><span class="line">        arr[i] = (function fn(j)&#123;</span><br><span class="line">            return function test()&#123;</span><br><span class="line">                return j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">var bar = foo();</span><br><span class="line">console.log(bar[0]());//0</span><br></pre></td></tr></table></figure></p><p>换一种写法，可能更容易理解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//正确写法</span><br><span class="line">function foo()&#123;</span><br><span class="line">    var arr = [];</span><br><span class="line">    for(var i = 0; i &lt; 2; i++)&#123;</span><br><span class="line">        arr[i] = (function fn(j)&#123;</span><br><span class="line">            var _j = j;//定义一个变量，更容易理解</span><br><span class="line">            return function test()&#123;</span><br><span class="line">                return _j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">var bar = foo();</span><br><span class="line">console.log(bar[0]());//0</span><br></pre></td></tr></table></figure></p><h2 id="对闭包的误解"><a href="#对闭包的误解" class="headerlink" title="对闭包的误解"></a>对闭包的误解</h2><p>很多人认为闭包会增加内存，导致内存泄漏，这是错误的，是对闭包的误解。<br>如果你不把变量定义为闭包访问的私有变量，你也一定会把这些变量定义在全局作用域上，全局作用上下文也是不销毁的，一样也是增加了内存。<br>所以闭包并没有增加内存，更没有内存泄漏。<br>如果增加了内存和内存泄漏，其实都是编码水平有待提高导致。</p><h1 id="命名空间模式"><a href="#命名空间模式" class="headerlink" title="命名空间模式"></a>命名空间模式</h1><p>js使用命名空间模式设计，主要是为了避免命名冲突。<br>命名空间设计模式有很多，工作中最常用的是 对象字面量表示法 的设计模式。其他命名空间模式，我觉得应该用的不多，知道一下即可，这里不展开，可以网上查，<a href="https://www.cnblogs.com/syfwhu/p/4885628.html" target="_blank" rel="noopener">也可参考此篇文章</a>。</p><h2 id="对象字面量表示法"><a href="#对象字面量表示法" class="headerlink" title="对象字面量表示法"></a>对象字面量表示法</h2><p>对象字面量表示法是命名空间设计模式的一种，用得最广，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//对象字面量表示法 的命名空间设计模式</span><br><span class="line">var myApplication = &#123;</span><br><span class="line">    // 可以很容易的为对象字面量定义功能</span><br><span class="line">    getInfo:function() &#123;</span><br><span class="line">        // ***</span><br><span class="line">    &#125;,</span><br><span class="line">    // 可以进一步支撑对象命名空间</span><br><span class="line">    models:&#123;&#125;,</span><br><span class="line">    views:&#123;</span><br><span class="line">        pages:&#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    collections:&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="命名空间与设计模式区别"><a href="#命名空间与设计模式区别" class="headerlink" title="命名空间与设计模式区别"></a>命名空间与设计模式区别</h2><p>很多人命名空间的设计模式，是js 单例的设计模式，其实二者完全是两样东西。<br>命名空间偏向于是一种编程规范的设计；<br>js的一些设计模式，例如单例、观察者模式，更多的偏向功能实现方案的js设计模式。如设计绑定和监听时，选择观察者设计模式。<br>所以说，命名空间是一种编程规范，设计模式(如单例，以下设计模式都为这种含义)是一种功能实现的设计方案。</p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js设计模式 </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> 闭包 </tag>
            
            <tag> 命名空间 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js设计模式下</title>
      <link href="/2019/03/03/js_design_main/"/>
      <url>/2019/03/03/js_design_main/</url>
      
        <content type="html"><![CDATA[<p>js设计模式分两篇来写，此为下篇，上篇为 《js设计模式上(面向对象、闭包、命名空间)》。<br>主要讲设计原则与设计模式两部分。</p><h1 id="js设计原则"><a href="#js设计原则" class="headerlink" title="js设计原则"></a>js设计原则</h1><p>js设计原则有四五个，但真正在js编程中的用得最多的差不多就两个：单一职责原则、开放封闭原则。<br>另外在本节的最后部分，附上《unix／linux 设计哲学》书中提到的几个linux的编码准则，列举其中对js编码有启发意义的几个。</p><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>单一职责原则：一个对象（方法）只做一件事情。<br>单一职责原则要求我们在写复杂方法时，将方法进行抽象，分离颗粒化成多个方法，让每个方法只做一件事情。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：让一个方法只做一个事情，将复杂职责分解为多个职责，后期维护代码的时候，修改其中一个职责，也就不会影响其他职责，这样代码可读性、可维护性、可扩张、可移植性更好，也更符合开放封闭原则。<br>缺点：增加编写代码的复杂度（能写出单一职责设计原则代码的程序员，也是要求他有一定编程水平才能写出的），当我们按照职责把对象分解成更小粒度之后，实际上也增大了这些对象之间相互联系的难度。</p><p>单一职责原则是js编写代码最重要的两个准则之一，在它的优点面前，它的缺点不值得一提。</p><h2 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>开放封闭原则：对扩展开放，对修改封闭。<br>开放封闭原则要求我们写出来的方法，当对程序方法进行扩展时，更加方便，不要修改原来的行为方法。</p><p>通过一段代码来体现 开放封闭原则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 这是原代码，此代码相比之下，每次扩展都需要修改makeSound方法，违反了开放封闭原则</span><br><span class="line">//每次扩展时，因为要修改公共方法makeSound，你还要担心有回归测试的一些问题，还要去测试Duck和Chicken</span><br><span class="line">var makeSound = function(animal)&#123;</span><br><span class="line">  if(animal instanceof Duck)&#123;</span><br><span class="line">    console.log(&apos;嘎嘎嘎&apos;);</span><br><span class="line">  &#125;else if(animal instanceof Chicken)&#123;</span><br><span class="line">    console.log(&apos;咯咯咯&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var Duck = function()&#123;&#125;</span><br><span class="line">var Chicken = function()&#123;&#125;</span><br><span class="line">makeSound(new Duck);</span><br><span class="line">makeSound(new Chicken);</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 这是改良后代码，此代码相比之下，每次扩展都不用修改makeSound方法，更加易于扩展，而且makeSound是一个公共的方法，</span><br><span class="line">//每次扩展时，因为不用修改公共方法makeSound，就不会担心有回归测试的一些问题，不用担心还要去测试Duck和Chicken</span><br><span class="line">var makeSound = function(animal)&#123;</span><br><span class="line">  animal.sound();</span><br><span class="line">&#125;</span><br><span class="line">var Duck = function()&#123;&#125;</span><br><span class="line">Duck.prototype.sound = function()&#123;</span><br><span class="line">  console.log(&apos;嘎嘎嘎&apos;);</span><br><span class="line">&#125;</span><br><span class="line">var Chicken = function()&#123;&#125;</span><br><span class="line">Chicken.prototype.sound = function()&#123;</span><br><span class="line">  console.log(&apos;咯咯咯&apos;);</span><br><span class="line">&#125;</span><br><span class="line">makeSound(new Duck);</span><br><span class="line">makeSound(new Chicken);</span><br><span class="line"></span><br><span class="line">//增加新需求，添加一个Dog行为</span><br><span class="line">var Dog = function()&#123;&#125;</span><br><span class="line">Dog.prototype.sound = function()&#123;</span><br><span class="line">  console.log(&apos;汪汪汪&apos;);</span><br><span class="line">&#125;</span><br><span class="line">makeSound(new Dog);</span><br></pre></td></tr></table></figure><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：从上面代码例子中看到，开放封闭原则的代码，后期可维护性更高，扩展性更强，当有扩展新功能时，风险更小，要做的回归测试问题更少，因此维护、扩展成本更低。<br>缺点：在项目刚开始时，因为业务不熟，或业务不稳定，因此你很难抽象出 方法中永远变化的部分和永远不变化的部分进行封装。</p><h3 id="接受第一次愚弄"><a href="#接受第一次愚弄" class="headerlink" title="接受第一次愚弄"></a>接受第一次愚弄</h3><p>为了解决上面说的缺点，一种现实的做法是，在项目刚开始时，我们假设方法的所有部分都是不变化的，不对方法进行开放封闭进行抽象封装处理，项目初期快速编码完成需求，不影响项目进度。<br>当后期变化发生时，再来回过头来封装这些变化地方，确保下一次不会掉进同一个坑里。<br>我们将这条编码经验称之为 ‘接受第一次愚弄’，但永远不会被同样的招数击倒第二次。</p><h2 id="其他准则"><a href="#其他准则" class="headerlink" title="其他准则"></a>其他准则</h2><p>下面是unix／linux 设计哲学 的 几条准则，对js编程依然有借鉴：<br>准则1:小即是美<br>准则2:让每个程序只做好一件事情<br>准则3:快速建立原型（快速更早将功能骨架做好，先让用户用起来，然后客户边用边反馈，开发根据这个实施开发客户反馈需求）<br>准则4:舍弃高效率而取可移植性（硬件升级或浏览器内核升级后，原来不高效的写法，因为计算机硬件提高，原来不高效写法不影响效率了）<br>准则5:充分地抽象封装程序，以此达到程序复用性</p><h1 id="js设计模式"><a href="#js设计模式" class="headerlink" title="js设计模式"></a>js设计模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>单例模式 定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><h3 id="标准单例模式示例"><a href="#标准单例模式示例" class="headerlink" title="标准单例模式示例"></a>标准单例模式示例</h3><p>标准的单例模式示例，如下代码符合单例模式的几点定义：</p><ul><li>Singletom是一个类；</li><li>new Singletom 是它点实例；</li><li>全局范围内，可通过Singletom访问这个类。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//标准的单例模式示例</span><br><span class="line">var Singletom = function(name)&#123;</span><br><span class="line">            console.log(name)</span><br><span class="line">          &#125;</span><br><span class="line">Singletom.getInstance = (function()&#123;</span><br><span class="line">var instance = null;</span><br><span class="line">return function(name)&#123;</span><br><span class="line">    if(!instance)&#123;</span><br><span class="line">    instance = new Singletom(name);</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)()</span><br><span class="line">var a = Singletom.getInstance(&apos;sven1&apos;);</span><br><span class="line">var b = Singletom.getInstance(&apos;sven2&apos;);</span><br><span class="line">console.log(a === b)//true</span><br></pre></td></tr></table></figure><h3 id="将以上-标准单例模式示例-优化"><a href="#将以上-标准单例模式示例-优化" class="headerlink" title="将以上 标准单例模式示例 优化"></a>将以上 标准单例模式示例 优化</h3><p>上面的标准示例，将new 实例和 管理是否有无两个功能放在一个函数内，违背了 单一职责原则，在此改造下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//优化后的单例模式示例</span><br><span class="line">var CreateDiv = function(html)&#123;</span><br><span class="line">          this.html = html;</span><br><span class="line">          this.init()</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">CreateDiv.prototype.init = function()&#123;</span><br><span class="line">    var div = document.createElement(&apos;div&apos;);</span><br><span class="line">    div.innerHTML = this.html;</span><br><span class="line">    document.body.appendChild(div);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var ProxySingletonCreateDiv = (function()&#123;</span><br><span class="line">    var instance;</span><br><span class="line">    return function(html)&#123;</span><br><span class="line">    if(! instance)&#123;</span><br><span class="line">        instance = new CreateDiv(html);</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line">var a = new ProxySingletonCreateDiv(&apos;sven1&apos;);</span><br><span class="line">var b = new ProxySingletonCreateDiv(&apos;sven2&apos;);</span><br><span class="line">console.log(a === b)//true</span><br></pre></td></tr></table></figure></p><h3 id="通用的单例模式示例"><a href="#通用的单例模式示例" class="headerlink" title="通用的单例模式示例"></a>通用的单例模式示例</h3><p>上面我们解释了标准的单例模式，这样可以更加容易理解单例模式是什么，在实际应用中，我们更偏向使用基于以上标准单例模式改造而来的通用的单例模式。<br>我们不必拘泥于单例模式的定义，单例模式必须要求是一个类 和 实例，<br>其实类也是一个函数，实例其实就是对call或apply的应用，我们不必拘泥于new 实例，大可 将 函数的直接执行 来 代替实例。<br>单例模式的精神就是：</p><ul><li>有一个全局的函数（类）</li><li>此函数被执行或被实例一次<br>满足了以上两个条件，都可以称之为单例设计模式；<br>下面写了一个经典 单例模式示例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//优化后的单例模式示例</span><br><span class="line">var num = 0;</span><br><span class="line">var CreateDiv = function(...args)&#123;</span><br><span class="line">    num ++;</span><br><span class="line">    console.log(args[0],`一共执行了$&#123;num&#125;次`);</span><br><span class="line">    var div = document.createElement(&apos;div&apos;);</span><br><span class="line">    div.innerHTML = this.html;</span><br><span class="line">    document.body.appendChild(div);</span><br><span class="line">    return div;</span><br><span class="line">&#125;</span><br><span class="line">ProxySingletonCreateDiv 专门用来管理 函数是否执行</span><br><span class="line">var ProxySingletonCreateDiv = function(fn)&#123;</span><br><span class="line">    var instance;</span><br><span class="line">    return function()&#123;</span><br><span class="line">    if(! instance)&#123;</span><br><span class="line">        instance = fn.apply(this, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var a = ProxySingletonCreateDiv(CreateDiv);</span><br><span class="line"></span><br><span class="line">a(&apos;单例模式&apos;)//单例模式 一共执行了1次</span><br><span class="line">a(&apos;单例模式&apos;)//单例模式 一共执行了1次</span><br><span class="line"></span><br><span class="line">//如果我们要扩展，增加一个CreateFrame，只需这样做,非常容易扩展</span><br><span class="line">var CreateFrame = function(...args)&#123;</span><br><span class="line">    console.log(args[0]);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">var f = ProxySingletonCreateDiv(CreateFrame);</span><br><span class="line">f(&apos;单例模式&apos;)//单例模式 一共执行了1次</span><br><span class="line">f(&apos;单例模式&apos;)//单例模式 一共执行了1次</span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>购物车，登陆，redux 的 store都是单例模式的运用。</p><h3 id="如何写一个单例模式"><a href="#如何写一个单例模式" class="headerlink" title="如何写一个单例模式"></a>如何写一个单例模式</h3><p>由上面例子看到，写一个单例模式的功能，基本上要借助闭包来实现。<br>通过上面的例子看到，在单例模式中，请将管理单例 和 功能函数 分开编写。</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式也称为发布订阅模式</p><h3 id="es6示例"><a href="#es6示例" class="headerlink" title="es6示例"></a>es6示例</h3><h4 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h4><p>对下面例子解说，<br>新闻公司通过 暴露出来一个接口attach，用来给订阅者(观察者)报名或参加订阅，<br>新闻公司内部，用以下几个属性用来记录情况：<br>this.foodState —- 将要推送的 食品消息<br>this.houseState —- 将要推送的 房产消息<br>this.foodObservers —- 食品消息订阅者个人信息<br>this.houseObservers —- 房产消息订阅者个人信息<br>this.deliveryType —- 将要推送的消息的类别<br>deliveryState —- 推送消息<br>notifyAllObservers  —- 给每个订阅者打电话将消息通知给订阅者<br>getState —- 暴露给订阅者的API,订阅者接到通知消息的电话后，可通过公司提供的渠道网站或短信来看新闻</p><p>订阅者：<br>订阅者用以下几个属性来记录情况<br>this.phoneNum —- 订阅新闻需要提供给新闻公司的 手机号码<br>this.subscribeType  —- 订阅新闻需要提供给新闻公司的 新闻类别<br>this.company  —- 用来保存公司资料，刚开始是根据公司提供的报名方式attach进行报名，后期新闻发送消息是，<br>                   可以通过公司提供的渠道(this.company.getState)查看消息，也可以针对新闻服务公司的服务态度，给公司反馈或投诉建议<br>this.company.attach 通过公司对外暴露的接口，登记报名订阅。</p><p>cellphone 订阅者对外暴露给新闻公司自己接收消息的方式，用来update。</p><h4 id="示例小结"><a href="#示例小结" class="headerlink" title="示例小结"></a>示例小结</h4><p>新闻公司必须 对订阅者暴露 订阅方式attach；<br>订阅者必须 对公司暴露 接收消息方式cellphone；<br>因为订阅者要 保存公司的资料，例如获取订阅方式等等，所以订阅者必须设计一个属性用来保存公司这个对象总类；<br>因为公司要 保存订阅者的资料，例如获取订阅者的接收方式等等，所以公司必须设计一个属性用来保存订阅者完整类；</p><p>因为公司要 发送消息deliveryState，就要用一个属性来保存将要发的消息foodState，然后要执行打电话通知notifyAllObservers，<br>通知完后，还要提供网站或app或短信等渠道getState，让订阅者查看新闻。</p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><p>此代码针对上面解说而写的，此示例代码的好处是可以很好地先理解好观察者到底是一个什么东西。<br>但此代码也有弊端，例如NewsCompany不易维护性，NewsCompany中维护了food，house，如果将来增加了money等等呢，需要改写NewsCompany内部。所以NewsCompany需要进一步优化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">// 主题，接收状态变化，触发每个观察者</span><br><span class="line"></span><br><span class="line">class NewsCompany &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.foodState = 0</span><br><span class="line">        this.houseState = 0</span><br><span class="line">        this.foodObservers = []</span><br><span class="line">        this.houseObservers = []</span><br><span class="line">        this.deliveryType = 0</span><br><span class="line">    &#125;</span><br><span class="line">    getState() &#123;</span><br><span class="line">        if(this.deliveryType === &apos;food&apos;)&#123;</span><br><span class="line">            return this.foodState</span><br><span class="line">        &#125;</span><br><span class="line">        return this.houseState</span><br><span class="line">    &#125;</span><br><span class="line">    deliveryState(state,deliveryType) &#123;</span><br><span class="line">        if(deliveryType === &apos;food&apos;)&#123;</span><br><span class="line">            this.foodState = state</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            this.houseState = state</span><br><span class="line">        &#125;</span><br><span class="line">        this.deliveryType = deliveryType;</span><br><span class="line">        this.notifyAllObservers(deliveryType)</span><br><span class="line">    &#125;</span><br><span class="line">    attach(observer) &#123;</span><br><span class="line">        if(observer.subscribeType === &apos;food&apos;)&#123;</span><br><span class="line">            this.foodObservers.push(observer)</span><br><span class="line">        &#125;</span><br><span class="line">        if(observer.subscribeType === &apos;house&apos;)&#123;</span><br><span class="line">            this.houseObservers.push(observer)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    notifyAllObservers(type) &#123;</span><br><span class="line">        const observers = type === &apos;food&apos; ? this.foodObservers : this.houseObservers;</span><br><span class="line">        observers.forEach(observer =&gt; &#123;</span><br><span class="line">            //发布消息，给每个订阅者留的电话打电话，通知订阅者</span><br><span class="line">            observer.cellphone()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 观察者，等待被触发</span><br><span class="line">class Observer &#123;</span><br><span class="line">    constructor(phoneNum, subscribeType ,company) &#123;</span><br><span class="line">        this.phoneNum = phoneNum</span><br><span class="line">        //订阅的第一步，就必须获得订阅内容的资料或对象，我们把这个对象看成是新闻服务公司，这个新闻服务公司提供很多种类的新闻：房产新闻，食品新闻，体育新闻。。。。</span><br><span class="line">        this.company = company //必不可少，将公司资料保存下来，可以针对新闻服务公司的服务态度，给公司反馈或投诉建议</span><br><span class="line">        this.subscribeType = subscribeType</span><br><span class="line">        this.company.attach(this)//报名，参加订阅，这一步是不是可以理解为订阅.attach就是公司给订阅者的报名方式</span><br><span class="line">    &#125;</span><br><span class="line">    //cellphone 新闻服务公司，有消息时会打电话给每个订阅者，cellphone模拟的是订阅者手机接到电话的行为，很多示例中将cellphone写作update，不过为了方便理解，在此写成cellphone</span><br><span class="line">    cellphone() &#123;</span><br><span class="line">        console.log(`$&#123;this.phoneNum&#125; 收到, state新闻: $&#123;this.company.getState()&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 测试代码</span><br><span class="line">let newsCompany = new NewsCompany()</span><br><span class="line">//对于新闻服务公司来说，他只需要知道 订阅者 电话号码 和 订阅内容即可，一个人可以有很多特性，例如名字，性别，爱好等等，</span><br><span class="line">//但对于新闻服务公司而言，它只需要知道订阅者的 手机号码 和 新闻类别，所以一个订阅者的对象，只需要具备手机号码和订阅新闻类别两个属性即可。</span><br><span class="line">//所以我们上面设计的订阅者类Observer，只有phoneNum, subscribeType 两个属性。</span><br><span class="line">//从观察者的角度看，它还需要 一个属性来将公司资料保存下来，可以针对新闻服务公司的服务态度，给公司反馈或投诉建议</span><br><span class="line">//基于以上，一个订阅者，需要设置三个属性，而cellphone是公司打电话来时，模拟订阅者手机接到电话的行为</span><br><span class="line">let o1 = new Observer(&apos;15099281126&apos;, &apos;food&apos;, newsCompany)</span><br><span class="line">let o2 = new Observer(&apos;15099281127&apos;, &apos;food&apos;, newsCompany)</span><br><span class="line">let o3 = new Observer(&apos;15099281128&apos;, &apos;food&apos;, newsCompany)</span><br><span class="line">newsCompany.deliveryState(&apos;奶制食品新闻&apos;,&apos;food&apos;);//给每个订阅者发布消息</span><br><span class="line"></span><br><span class="line">let o7 = new Observer(&apos;13899761271&apos;, &apos;house&apos;, newsCompany)</span><br><span class="line">let o8 = new Observer(&apos;13899761272&apos;, &apos;house&apos;, newsCompany)</span><br><span class="line">let o9 = new Observer(&apos;13899761273&apos;, &apos;house&apos;, newsCompany)</span><br><span class="line">newsCompany.deliveryState(&apos;房产新闻&apos;,&apos;house&apos;);//给每个订阅者发布消息</span><br></pre></td></tr></table></figure></p><h4 id="优化及延伸方式一"><a href="#优化及延伸方式一" class="headerlink" title="优化及延伸方式一"></a>优化及延伸方式一</h4><p>对示例代码优化及延伸方式一：<br>上面代码不易扩展，将上面代码优化：NewsCompany中去掉constructor，并且改写food与house切换，将cellphone改为callback不再统一管理callback：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">class NewsCompany &#123;</span><br><span class="line">    deliveryState(state,deliveryType) &#123;</span><br><span class="line">        this[`$&#123;deliveryType&#125;State`] = state;</span><br><span class="line">        this.deliveryType = deliveryType;</span><br><span class="line">        this.notifyAllObservers()</span><br><span class="line">    &#125;</span><br><span class="line">    attach(observer) &#123;</span><br><span class="line">        const &#123;subscribeType&#125; = observer;</span><br><span class="line">        if(!this[`$&#123;subscribeType&#125;Observers`])&#123;</span><br><span class="line">            this[`$&#123;subscribeType&#125;Observers`] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        this[`$&#123;subscribeType&#125;Observers`].push(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    notifyAllObservers() &#123;</span><br><span class="line">        const observers = this[`$&#123;this.deliveryType&#125;Observers`];</span><br><span class="line">        observers.forEach(observer =&gt; &#123;</span><br><span class="line">            observer.callback(this[`$&#123;this.deliveryType&#125;State`], this, observer)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 观察者，等待被触发</span><br><span class="line">class Observer &#123;</span><br><span class="line">    constructor(phoneNum, subscribeType ,company, callback) &#123;</span><br><span class="line">        this.phoneNum = phoneNum</span><br><span class="line">        this.subscribeType = subscribeType</span><br><span class="line">        this.callback = callback</span><br><span class="line">        company.attach(this)//报名，参加订阅，</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let newsCompany = new NewsCompany()</span><br><span class="line">//state, newsCompany, observerMyself 将newsCompany和observerMyself都传给callback，以备不时之需</span><br><span class="line">let o1 = new Observer(&apos;15099281126&apos;, &apos;food&apos;, newsCompany, (state, newsCompany, observerMyself)=&gt;&#123;</span><br><span class="line">    console.log(`15099281126 收到, state新闻: `,state)</span><br><span class="line">&#125;)</span><br><span class="line">let o2 = new Observer(&apos;15099281127&apos;, &apos;food&apos;, newsCompany, (state, newsCompany, observerMyself)=&gt;&#123;</span><br><span class="line">    console.log(`15099281127 收到, state新闻: `,state)</span><br><span class="line">&#125;)</span><br><span class="line">let o3 = new Observer(&apos;15099281128&apos;, &apos;food&apos;, newsCompany, (state, newsCompany, observerMyself)=&gt;&#123;</span><br><span class="line">    console.log(`15099281128 收到, state新闻: `,state)</span><br><span class="line">&#125;)</span><br><span class="line">newsCompany.deliveryState(&apos;奶制食品新闻&apos;,&apos;food&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let o7 = new Observer(&apos;13899761271&apos;, &apos;house&apos;, newsCompany, (state, newsCompany, observerMyself)=&gt;&#123;</span><br><span class="line">    console.log(`13899761271 收到, state新闻: `,state)</span><br><span class="line">&#125;)</span><br><span class="line">let o8 = new Observer(&apos;13899761272&apos;, &apos;house&apos;, newsCompany, (state, newsCompany, observerMyself)=&gt;&#123;</span><br><span class="line">    console.log(`13899761272 收到, state新闻: `,state)</span><br><span class="line">&#125;)</span><br><span class="line">let o9 = new Observer(&apos;13899761273&apos;, &apos;house&apos;, newsCompany, (state, newsCompany, observerMyself)=&gt;&#123;</span><br><span class="line">    console.log(`13899761273 收到, state新闻: `,state)</span><br><span class="line">&#125;)</span><br><span class="line">newsCompany.deliveryState(&apos;房产新闻&apos;,&apos;house&apos;);</span><br></pre></td></tr></table></figure><h4 id="优化及延伸方式二"><a href="#优化及延伸方式二" class="headerlink" title="优化及延伸方式二"></a>优化及延伸方式二</h4><p>对示例代码优化及延伸方式二：<br>你会发现上面的phoneNum其实可有可无，NewsCompany保持跟上面不变，改造其他部分：<br>删除phoneNum,<br>将attach提取出来，<br>删除Observer类，直接用参数来代替，<br>参数因为可能会超过3个改成options对象方式容易扩展</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let newsCompany = new NewsCompany()</span><br><span class="line">//state, newsCompany, observerMyself 将newsCompany和observerMyself都传给callback，以备不时之需</span><br><span class="line">newsCompany.attach(&#123;</span><br><span class="line">    subscribeType : &apos;food&apos;, </span><br><span class="line">    callback: (state, newsCompany, observerMyself)=&gt;&#123;</span><br><span class="line">      console.log(`o1 订阅或观察者 收到, state新闻: `,state)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">newsCompany.attach(&#123;</span><br><span class="line">    subscribeType : &apos;food&apos;, </span><br><span class="line">    callback: (state, newsCompany, observerMyself)=&gt;&#123;</span><br><span class="line">      console.log(`o2 订阅或观察者 收到, state新闻: `,state)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">newsCompany.attach(&#123;</span><br><span class="line">    subscribeType : &apos;food&apos;, </span><br><span class="line">    callback: (state, newsCompany, observerMyself)=&gt;&#123;</span><br><span class="line">      console.log(`o3 订阅或观察者 收到, state新闻: `,state)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">newsCompany.deliveryState(&apos;奶制食品新闻&apos;,&apos;food&apos;);</span><br></pre></td></tr></table></figure><p>此时，你是否可以将attach想象成 addEventListener，deliveryState想象成fire或trigger。</p><h3 id="es5示例"><a href="#es5示例" class="headerlink" title="es5示例"></a>es5示例</h3><p>由于js天生可以很优雅地使用花括号来构造一个对象，而不用通过class实例化，因此我们可很容易通过es5来写一个观察者与订阅模式示例：</p><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">var Event = (function()&#123;</span><br><span class="line">    var ClientList = &#123;&#125;,</span><br><span class="line">    listen,</span><br><span class="line">    trigger,</span><br><span class="line">    remove;</span><br><span class="line">    listen = function(key, fn)&#123;</span><br><span class="line">        if(!ClientList[key])&#123;</span><br><span class="line">            ClientList[key] = []</span><br><span class="line">        &#125;</span><br><span class="line">        ClientList[key].push(fn);</span><br><span class="line">    &#125;</span><br><span class="line">    trigger = function()&#123;</span><br><span class="line">        var key = Array.prototype.shift.call(arguments),</span><br><span class="line">        fns = ClientList[key];</span><br><span class="line">        if(!fns || fns.listen === 0)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        for(var i = 0; i&lt;fns.length; i++)&#123;</span><br><span class="line">            fns[i].apply(this,arguments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    remove = function(key, fn)&#123;</span><br><span class="line">        var fns = ClientList[key];</span><br><span class="line">        if(!fns)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        var fns = ClientList[key];</span><br><span class="line">        if(!fn)&#123;</span><br><span class="line">            fns &amp;&amp; (fns.length = 0);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            for (var l = fns.length -1;l&gt;0;l--)&#123;</span><br><span class="line">                var _fn = fns[l];</span><br><span class="line">                if(_fn === fn)&#123;</span><br><span class="line">                    fns.splice(l,1);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;listen,trigger,remove&#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">Event.listen(&apos;squeremeter88&apos;, function(price)&#123;</span><br><span class="line">    console.log(&apos;价格= &apos;+price);</span><br><span class="line">&#125;)</span><br><span class="line">Event.listen(&apos;squeremeter88&apos;, function(price)&#123;</span><br><span class="line">    console.log(&apos;价格_111= &apos;+price);</span><br><span class="line">&#125;)</span><br><span class="line">Event.trigger(&apos;squeremeter88&apos;, 20000);</span><br></pre></td></tr></table></figure><p>当业务复杂后，可能出现命名污染的现象，这个时候，我们可以改写Event，通过Event.creat(namespace).listen(add),<br>Event.creat(namespace).trigger(add),详细可看 《js设计模式》书</p><h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><p>一个按钮被点击时，出发一个div显示最新的count值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button id=&quot;count&quot;&gt;click&lt;/button&gt;</span><br><span class="line">&lt;div id=&quot;show&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var a = (function()&#123;</span><br><span class="line">    var count = 0;</span><br><span class="line">    var button = document.getElementById(&apos;count&apos;);</span><br><span class="line">    button.onclick = function()&#123;</span><br><span class="line">        //Event 就是上面的Event不变。</span><br><span class="line">        Event.trigger(&apos;add&apos;, count++)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line">var b = (function()&#123;</span><br><span class="line">    var div = document.getElementById(&apos;show&apos;);</span><br><span class="line">    Event.listen(&apos;add&apos;, function(count)&#123;</span><br><span class="line">        div.innerHTML = count</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)()</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>网页事件绑定，promise的一系列then，还有react的生命周期函数其实都是定义callbase，是一种观察者模式</p><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>它定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都将得到通知。<br>它的特征是，</p><ul><li>发布和订阅</li><li>一对多（包含一对一）<br>设计的原则：<br>主题与观察者分离，不是主动触发而是被动监听，两者解耦。</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>上面举例来es6和es5两种方式的观察者模式示例，es6和es5两种方式，各有各的优点，本质上也是一样的，为了便于直观理解观察者模式，可先行记忆es5示例的形式。</p><h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><p>缺点 观察者模式容易隐藏 代码逻辑，过量使用观察者模式，后期后期维护时，可能不好找入口的风险带来一些麻烦。<br>优点 观察者模式可以用来很好地写异步编程，事件驱动编程。</p><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><h3 id="反例"><a href="#反例" class="headerlink" title="反例"></a>反例</h3><p>举例一个常规编程，但这个编程是一个不好的例子–反例，下节会基于此做优化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var Light = function()&#123;</span><br><span class="line">    this.state = &apos;off&apos;</span><br><span class="line">    this.button = null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Light.prototype.init = function()&#123;</span><br><span class="line">    var button = document.createElement(&apos;button&apos;),</span><br><span class="line">    self = this;</span><br><span class="line">    this.button = document.body.appendChild(button);</span><br><span class="line">    this.button.innerHTML = &apos;开关&apos;;</span><br><span class="line">    this.button.onclick = function()&#123;</span><br><span class="line">        self.buttonWasPressed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Light.prototype.buttonWasPressed = function(newState)&#123;</span><br><span class="line">   if(this.state === &apos;off&apos;)&#123;</span><br><span class="line">       console.log(&apos;弱光&apos;);//用console来象征 状态行为</span><br><span class="line">       this.state = &apos;weakLight&apos;;</span><br><span class="line">   &#125;else if(this.state === &apos;weakLight&apos;)&#123;</span><br><span class="line">       console.log(&apos;高光&apos;);</span><br><span class="line">       this.state = &apos;strongLight&apos;;</span><br><span class="line">   &#125;else if(this.state === &apos;strongLight&apos;)&#123;</span><br><span class="line">       console.log(&apos;关灯&apos;);</span><br><span class="line">       this.state = &apos;off&apos;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">var light = new Light();</span><br><span class="line">light.init();</span><br></pre></td></tr></table></figure></p><p>需求来了，如果再增加一个超级强光，那么就要改写buttonWasPressed，违反了开放封闭原则，而且Light.prototype.buttonWasPressed会越来越臃肿，<br>代码中状态行为只有一句console.log(),但实际开发中，肯定不止这一句代码，基于以上两点理由，因为有必要 改写成下一节的示例代码</p><h3 id="标准状态模式示例"><a href="#标准状态模式示例" class="headerlink" title="标准状态模式示例"></a>标准状态模式示例</h3><p>将上节反例demo改造，优化，以下是标准状态模式demo：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">//标准状态模式示例</span><br><span class="line">var LightState = function(nextState, stateCallback)&#123;</span><br><span class="line">    this.stateCallback = stateCallback;</span><br><span class="line">    this.nextState = nextState;</span><br><span class="line">&#125;</span><br><span class="line">LightState.prototype.buttonWasPressed = function()&#123;</span><br><span class="line">    this.stateCallback();//对应的行为</span><br><span class="line">    this.light.setState(this.nextState) //切换状态</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var OffLightState = function(light)&#123;</span><br><span class="line">    this.light = light;</span><br><span class="line">&#125;</span><br><span class="line">OffLightState.prototype = new LightState(&apos;weakLightState&apos;, function()&#123;</span><br><span class="line">    console.log(&apos;弱光&apos;);//自定义对应的行为</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var WeakLightState = function(light)&#123;</span><br><span class="line">    this.light = light;</span><br><span class="line">&#125;</span><br><span class="line">WeakLightState.prototype = new LightState(&apos;strongLightState&apos; ,function()&#123;</span><br><span class="line">    console.log(&apos;强光&apos;);//自定义对应的行为</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var StrongLightState = function(light)&#123;</span><br><span class="line">    this.light = light;</span><br><span class="line">&#125;</span><br><span class="line">StrongLightState.prototype = new LightState(&apos;offLightState&apos; , function()&#123;</span><br><span class="line">    console.log(&apos;关灯&apos;);//自定义对应的行为</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var LightContext = function()&#123;</span><br><span class="line">    this.offLightState = new OffLightState(this)</span><br><span class="line">    this.weakLightState = new WeakLightState(this)</span><br><span class="line">    this.strongLightState = new StrongLightState(this)</span><br><span class="line">    this.button = null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LightContext.prototype.init = function()&#123;</span><br><span class="line">    var button = document.createElement(&apos;button&apos;),</span><br><span class="line">    self = this;</span><br><span class="line">    this.button = document.body.appendChild(button);</span><br><span class="line">    this.button.innerHTML = &apos;开关&apos;;</span><br><span class="line">    this.currState = this.offLightState; //设置开始状态</span><br><span class="line">    this.button.onclick = function()&#123;</span><br><span class="line">        self.currState.buttonWasPressed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">LightContext.prototype.setState = function(newState)&#123;</span><br><span class="line">   this.currState = this[newState]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var light = new LightContext();</span><br><span class="line">light.init();</span><br></pre></td></tr></table></figure></p><p>当增加一个超级强光时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var SuperStrongLightState = function(light)&#123;</span><br><span class="line">    this.light = light;</span><br><span class="line">&#125;</span><br><span class="line">SuperStrongLightState.prototype = new LightState(&apos;offLightState&apos; , function()&#123;</span><br><span class="line">    console.log(&apos;关灯&apos;);//自定义对应的行为</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">StrongLightState.prototype = new LightState(&apos;superStrongLightState&apos; , function()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var LightContext = function()&#123;</span><br><span class="line">...</span><br><span class="line">    this.superStrongLightState = new SuperStrongLightState(this)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="状态模式的优缺点"><a href="#状态模式的优缺点" class="headerlink" title="状态模式的优缺点"></a>状态模式的优缺点</h3><p>以上就是状态模式的魅力，符合开放封闭原则，可以不让buttonWasPressed臃肿，其实就是不让context无限臃肿。<br>缺点 会增加代码量，把逻辑分散到状态类中，无法在一个地方就可以将逻辑不能一目了然。</p><h3 id="设计原则与定义"><a href="#设计原则与定义" class="headerlink" title="设计原则与定义"></a>设计原则与定义</h3><p>状态模式，最重要的特征是定义状态类(如上的LightState)，并将逻辑分散到状态类中。<br>将状态(LightState)与主体(LightContext)分离，状态变化的逻辑单独到每个状态类中(例如OffLightState)处理。</p><p>状态模式的定义较晦涩：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。<br>这个定义基本看不懂，可以忽视掉。<br>状态模式的精髓在于 定义状态类，并状态对应的逻辑封装到状态类中。</p><h3 id="什么情况下使用"><a href="#什么情况下使用" class="headerlink" title="什么情况下使用"></a>什么情况下使用</h3><p>什么情况下使用状态模式，<br>如上面优缺点说的，<br>当你不希望Light.prototype.buttonWasPressed太臃肿时；<br>当每次有新需求你不希望每次都去修改Light.prototype.buttonWasPressed时；<br>当你做的功能业务有太多状态变化，且每个状态逻辑较多时；<br>那么就请使用状态模式吧</p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h3 id="两者代理模式的概念"><a href="#两者代理模式的概念" class="headerlink" title="两者代理模式的概念"></a>两者代理模式的概念</h3><p>js中用得最多的虚拟代理和缓存代理；<br>虚拟代理指通过代理，将一个函数延迟或等到真正需要执行的时候再执行，说白了就是延时下，例如下面例子中，等图片完全加载好后再执行真正的加载。<br>缓存代理，如下例子中，指通过代理，不用每次都执行函数，开始执行完函数后，后期从缓存取，如果我计算或2+3，后面再2+3时，直接从缓存取。<br>代理模式很简单直接通过以下两个例子来领略下代理模式；</p><h3 id="虚拟代理示例"><a href="#虚拟代理示例" class="headerlink" title="虚拟代理示例"></a>虚拟代理示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var myImage = (function()&#123;</span><br><span class="line">    var imgNode = document.createElement(&apos;img&apos;);</span><br><span class="line">    document.body.appendChild(imgNode);</span><br><span class="line">    return &#123;</span><br><span class="line">        setSrc: function(src)&#123;</span><br><span class="line">            imgNode.src = src;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">var proxyImage = (function()&#123;</span><br><span class="line">    var img = new Image;</span><br><span class="line">    img.onload = function()&#123;</span><br><span class="line">        myImage.setSrc(this.src)</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">        setSrc:function(src)&#123;</span><br><span class="line">            myImage.setSrc(&apos;file:// /c:/user/abc.gif&apos;);</span><br><span class="line">            img.src = src;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">//myImage.setSrc(&apos;http://s9.knowsky.com/bizhi/l/20100615/2010112611%20(1).jpg&apos;)</span><br><span class="line">proxyImage.setSrc(&apos;http://s9.knowsky.com/bizhi/l/20100615/2010112611%20(1).jpg&apos;)</span><br></pre></td></tr></table></figure><p>注意一个现象，myImage有一个setSrc接口，proxyImage也有一个setSrc接口，并且代理函数体内用了myImage.setSrc；</p><h3 id="缓存代理示例"><a href="#缓存代理示例" class="headerlink" title="缓存代理示例"></a>缓存代理示例</h3><h4 id="简单版示例"><a href="#简单版示例" class="headerlink" title="简单版示例"></a>简单版示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var mult = function()&#123;</span><br><span class="line">    console.log(&apos;开始计算乘积&apos;);</span><br><span class="line">    var a = 1;</span><br><span class="line">    for (var i =0, l = arguments.length; i&lt;l; i++)&#123;</span><br><span class="line">        a = a*arguments[i]</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var proxyMult = (function()&#123;</span><br><span class="line">    var cache = &#123;&#125;;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        var args = Array.prototype.join.call(arguments, &apos;,&apos;);</span><br><span class="line">        if(args in cache)&#123;</span><br><span class="line">            return cache[args];</span><br><span class="line">        &#125;</span><br><span class="line">        return cache[args] = mult.apply(this, arguments)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line">console.log(proxyMult(1,2,3,4))</span><br><span class="line">console.log(proxyMult(1,2,3,4))</span><br></pre></td></tr></table></figure><h4 id="延伸版示例"><a href="#延伸版示例" class="headerlink" title="延伸版示例"></a>延伸版示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var plus = function()&#123;</span><br><span class="line">    console.log(&apos;开始计算加和&apos;);</span><br><span class="line">    var a = 0;</span><br><span class="line">    for (var i =0, l = arguments.length; i&lt;l; i++)&#123;</span><br><span class="line">        a = a+arguments[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var createProxyFactory = function(fn)&#123;</span><br><span class="line">    var cache = &#123;&#125;;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        var args = Array.prototype.join.call(arguments, &apos;,&apos;);</span><br><span class="line">        if(args in cache)&#123;</span><br><span class="line">            return cache[args];</span><br><span class="line">        &#125;</span><br><span class="line">        return cache[args] = fn.apply(this, arguments)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var proxyMult = createProxyFactory(mult);</span><br><span class="line"></span><br><span class="line">console.log(proxyMult(11,2,3,4))</span><br><span class="line">console.log(proxyMult(11,2,3,4))</span><br></pre></td></tr></table></figure><p>注意一个现象，proxyMult代理函数体内用了fn.apply,且mult与proxyMult接收的参数是一致的，可以认为二者接口一致。</p><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>从上面的示例我们可以看到，<br>设计一个代理模式，有一个小技巧：</p><ul><li>就是代理函数 要 提供跟被代理函数一摸一样的接口，或者有一摸一样的接收传参方式；</li><li>代理函数体内 引用 被代理函数。</li></ul><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>策略模式的思想：<br>定义一系列的算法，把他们一个个封装起来，并且使他们可以相互替换。<br>最代表性和关键的操作是将每种算法单独封装成类，或者函数。</p><h3 id="经典示例一"><a href="#经典示例一" class="headerlink" title="经典示例一"></a>经典示例一</h3><p>下面看一个策略模式最代表的例子：</p><h4 id="反例-1"><a href="#反例-1" class="headerlink" title="反例"></a>反例</h4><p>计算绩效奖金，最开始的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 这是反例</span><br><span class="line">var calculateBonus = function(performanceLevel, salary)&#123;</span><br><span class="line">    if(performanceLevel === &apos;S&apos;)&#123;</span><br><span class="line">        return salary*4;</span><br><span class="line">    &#125;</span><br><span class="line">    if(performanceLevel === &apos;A&apos;)&#123;</span><br><span class="line">        return salary*3;</span><br><span class="line">    &#125;</span><br><span class="line">    if(performanceLevel === &apos;B&apos;)&#123;</span><br><span class="line">        return salary*2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">calculateBonus(&apos;B&apos;, 20000);</span><br><span class="line">calculateBonus(&apos;S&apos;, 6000);</span><br></pre></td></tr></table></figure></p><p>上面写法致命缺点在于，将来如果有更多的绩效等级，例如C、D、E、F…时，都需要在calculateBonus中增加代码逻辑；<br>改进上面代码的关键，在于精简calculateBonus。</p><h4 id="标准示例"><a href="#标准示例" class="headerlink" title="标准示例"></a>标准示例</h4><p>改进如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//标准策略模式示例</span><br><span class="line">var S = function(salary)&#123;</span><br><span class="line">    return salary*4;</span><br><span class="line">&#125;</span><br><span class="line">var A = function(salary)&#123;</span><br><span class="line">    return salary*3;</span><br><span class="line">&#125;</span><br><span class="line">var B = function(salary)&#123;</span><br><span class="line">    return salary*2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var calculateBonus = function(func, salary)&#123;</span><br><span class="line">    return func(salary);</span><br><span class="line">&#125;</span><br><span class="line">calculateBonus(B, 20000);</span><br><span class="line">calculateBonus(S, 6000);</span><br></pre></td></tr></table></figure></p><p>改进后，将每个等级的逻辑封装成单独的类或函数，<br>无论未来增加多少绩效逻辑，都将单独定义绩效逻辑类，不会影响现有类，同时calculateBonus都不变。<br>改进用到的策略模式技巧：</p><ul><li>将算法类直接以算法名字命名</li></ul><h3 id="经典示例二"><a href="#经典示例二" class="headerlink" title="经典示例二"></a>经典示例二</h3><p>如果只需了解 策略模式，只需看以上内容即可，这部分内容只是再举例加深理解。</p><p>下面再看一个经典测试模式示例</p><h4 id="反例-2"><a href="#反例-2" class="headerlink" title="反例"></a>反例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//这是反例</span><br><span class="line">&lt;form action=&quot;#&quot; id=&quot;registerForm&quot; method=&quot;POST&quot;&gt;</span><br><span class="line">    请输入用户名：&lt;input type=&quot;text&quot; name=&quot;userName&quot;/&gt;</span><br><span class="line">    请输入密码：&lt;input type=&quot;text&quot; name=&quot;passWord&quot; /&gt;</span><br><span class="line">    请输入手机号码：&lt;input type=&quot;text&quot; name=&quot;phoneNumber&quot; /&gt;</span><br><span class="line">    &lt;button&gt;提交&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">var registerForm = document.getElementById(&apos;registerForm&apos;);</span><br><span class="line">registerForm.onsubmit = function()&#123;</span><br><span class="line">    if(registerForm.userName.value === &apos;&apos;)&#123;</span><br><span class="line">        alert(&apos;用户名不能为空&apos;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if(registerForm.userName.length &lt; 6)&#123;</span><br><span class="line">        alert(&apos;用户名不能少于6位&apos;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if(registerForm.password.length &lt; 6)&#123;</span><br><span class="line">        alert(&apos;密码不能少于6位&apos;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="标准示例-1"><a href="#标准示例-1" class="headerlink" title="标准示例"></a>标准示例</h4><p>对以上示例进行改进：</p><ul><li>将每种验证方法 封装成单独的类或函数，如strategies.isNonEmpty;</li><li>Validator可以看作是本节的第一个标准示例中的calculateBonus，<br>validataForm可以看作是calculateBonus(B, 20000);</li><li>将验证Validator分两步逻辑，一步是逐条添加规则，一步是一次性验证所有规则<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">//将一系列 规则算法 封装成单独的函数</span><br><span class="line">var strategies = &#123;</span><br><span class="line">    isNonEmpty: function(value, errorMsg)&#123;</span><br><span class="line">        if(!value)&#123;</span><br><span class="line">            return errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    minLength: function(value, length, errorMsg)&#123;</span><br><span class="line">        if(value.length&lt;length)&#123;</span><br><span class="line">            return errorMsg</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    isMobile: function(value, errorMsg)&#123;</span><br><span class="line">        if(!/13511112222/.test(value))&#123;</span><br><span class="line">            return errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var Validator = function()&#123;</span><br><span class="line">    this.cache = [];</span><br><span class="line">&#125;</span><br><span class="line">//设计 添加 和 验证 规则的逻辑</span><br><span class="line">Validator.prototype.add = function(dom, rules)&#123;</span><br><span class="line">    var self = this;</span><br><span class="line">    for (var i = 0,rule; rule = rules[i++];)&#123;</span><br><span class="line">        (function(rule)&#123;</span><br><span class="line">            var strategyAry = rule.strategy.split(&apos;:&apos;);</span><br><span class="line">            var errorMsg = rule.errorMsg;</span><br><span class="line">            self.cache.push(function()&#123;</span><br><span class="line">                var strategy = strategyAry.shift();</span><br><span class="line">                strategyAry.unshift(dom.value);</span><br><span class="line">                strategyAry.push(errorMsg);</span><br><span class="line">                return strategies[strategy].apply(dom, strategyAry);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)(rule)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Validator.prototype.start = function()&#123;</span><br><span class="line">    for(var i= 0,validatorFunc; validatorFunc = this.cache[i++];)&#123;</span><br><span class="line">        var errorMsg = validatorFunc();</span><br><span class="line">        if(errorMsg)&#123;</span><br><span class="line">            return errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//为表单实际添加规则 和 验证</span><br><span class="line">var registerForm = document.getElementById(&apos;registerForm&apos;);</span><br><span class="line">var validataForm = function()&#123;</span><br><span class="line">    var validator = new Validator();</span><br><span class="line">    validator.add(registerForm.userName,[&#123;</span><br><span class="line">        strategy: &apos;isNonEmpty&apos;,</span><br><span class="line">        errorMsg: &apos;不能为空&apos;</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        strategy: &apos;minLength:10&apos;,</span><br><span class="line">        errorMsg: &apos;长度不能小于10&apos;</span><br><span class="line">    &#125;])</span><br><span class="line">    validator.add(registerForm.passWord,[&#123;</span><br><span class="line">        strategy: &apos;isNonEmpty&apos;,</span><br><span class="line">        errorMsg: &apos;不能为空&apos;</span><br><span class="line">    &#125;])</span><br><span class="line"></span><br><span class="line">    var errorMsg = validator.start();</span><br><span class="line">    return errorMsg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">registerForm.onsubmit = function()&#123;</span><br><span class="line">    var errorMsg = validataForm();</span><br><span class="line">    if(errorMsg)&#123;</span><br><span class="line">        alert(errorMsg);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>改进后，这种模式很好的适应了大型项目规则验证。</p><h3 id="编写策略模式技巧"><a href="#编写策略模式技巧" class="headerlink" title="编写策略模式技巧"></a>编写策略模式技巧</h3><ul><li>将策略算法 封装成单独函数或类；</li><li>直接以算法名称 命名 函数和类，如上面经典示例一</li></ul><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>主要讲解es5装饰者模式的其中的两种实现方式：一个是定义类(构造函数)的方式，一个是修改超级函数Function原型的方式。<br>下面对这两种方式分别讲解：</p><h3 id="构造函数方式"><a href="#构造函数方式" class="headerlink" title="构造函数方式"></a>构造函数方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var Plan = function()&#123;&#125;</span><br><span class="line">Plan.prototype.fire = function()&#123;</span><br><span class="line">    console.log(&apos;发射普通子弹&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var MissleDecorator = function(plan)&#123;</span><br><span class="line">    this.plan = plan;</span><br><span class="line">&#125;</span><br><span class="line">MissleDecorator.prototype.fire = function()&#123;</span><br><span class="line">    this.plan.fire();</span><br><span class="line">    console.log(&apos;发射导弹&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var AtomDecorator = function(plan)&#123;</span><br><span class="line">    this.plan = plan;</span><br><span class="line">&#125;</span><br><span class="line">AtomDecorator.prototype.fire = function()&#123;</span><br><span class="line">    this.plan.fire();</span><br><span class="line">    console.log(&apos;发射原子弹&apos;);</span><br><span class="line">&#125;</span><br><span class="line">var plan = new Plan();</span><br><span class="line">plan = new MissleDecorator(plan);</span><br><span class="line">plan = new AtomDecorator(plan);</span><br><span class="line">plan.fire();</span><br></pre></td></tr></table></figure><h3 id="Function原型方式"><a href="#Function原型方式" class="headerlink" title="Function原型方式"></a>Function原型方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.before = function(beforefn)&#123;</span><br><span class="line">        var _self = this;//保存原函数的引用</span><br><span class="line">        return function()&#123;//返回包含类原函数和新函数的代理函数</span><br><span class="line">            beforefn.apply(this,arguments);//执行新函数，且保证this不被劫持，新函数接受的参数</span><br><span class="line">            return _self.apply(this, arguments);//执行原函数，并且返回原函数的执行结果，并且保持this不被劫持</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Function.prototype.after = function(afterfn)&#123;</span><br><span class="line">        var _self = this;</span><br><span class="line">        return function()&#123;</span><br><span class="line">            var ret = _self.apply(this,arguments);</span><br><span class="line">            afterfn.apply(this,arguments);</span><br><span class="line">            return ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var func = function(param)&#123;</span><br><span class="line">        console.log(param);</span><br><span class="line">    &#125;</span><br><span class="line">    func = func.before(function(param)&#123;</span><br><span class="line">        param.b = &apos;b&apos;;</span><br><span class="line">    &#125;)</span><br><span class="line">    func(&#123;a:&apos;a&apos;&#125;);//&#123;a:&apos;a&apos;, b:&apos;b&apos;&#125;</span><br></pre></td></tr></table></figure><h3 id="es6中的修饰器（Decorator）"><a href="#es6中的修饰器（Decorator）" class="headerlink" title="es6中的修饰器（Decorator）"></a>es6中的修饰器（Decorator）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@testable</span><br><span class="line">class MyTestableClass &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">function testable(target) &#123;</span><br><span class="line">  target.isTestable = true;</span><br><span class="line">&#125;</span><br><span class="line">MyTestableClass.isTestable // true</span><br></pre></td></tr></table></figure><p>注意，修饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，修饰器能在编译阶段运行代码。也就是说，修饰器本质就是编译时执行的函数。</p><h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><p>装饰者，经常用到的小技巧，不改变原函数情况下，增加函数功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = function()&#123;</span><br><span class="line">        alert(1)</span><br><span class="line">    &#125;</span><br><span class="line">    var _a = a;</span><br><span class="line">    a = function()&#123;</span><br><span class="line">        _a();</span><br><span class="line">        alert(2);</span><br><span class="line">    &#125;</span><br><span class="line">    a();</span><br></pre></td></tr></table></figure></p><p>在开发中，我们常用这种方式，实现页面回退，加载等等事件时，增加功能。</p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js设计模式 </tag>
            
            <tag> 单例模式 </tag>
            
            <tag> 观察者模式 </tag>
            
            <tag> 状态模式 </tag>
            
            <tag> 单一职责原则 </tag>
            
            <tag> 开放封闭原则 </tag>
            
            <tag> 舍弃高效率而取可移植性 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo笔记</title>
      <link href="/2019/03/03/hexo/"/>
      <url>/2019/03/03/hexo/</url>
      
        <content type="html"><![CDATA[<h2 id="hexo-常用知识"><a href="#hexo-常用知识" class="headerlink" title="hexo 常用知识"></a>hexo 常用知识</h2><h3 id="public目录"><a href="#public目录" class="headerlink" title="public目录"></a>public目录</h3><p>根目录执行hexo g 命令，会在根目录下生成一个public/ 文件夹，<br>hexo g是一个编译源码的命令，编译后的源码，可以直接供GitHub网址生成博客。<br>因此public/ 文件夹是用来将源码上传到github上，供github生成博客的。</p><h3 id="常用hexo命令"><a href="#常用hexo命令" class="headerlink" title="常用hexo命令"></a>常用hexo命令</h3><h4 id="启动本地服务，看博客效果"><a href="#启动本地服务，看博客效果" class="headerlink" title="启动本地服务，看博客效果"></a>启动本地服务，看博客效果</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><h4 id="发布到GitHub"><a href="#发布到GitHub" class="headerlink" title="发布到GitHub"></a>发布到GitHub</h4><p>将git仓库放在public中，每次需要发布时，根目录下执行hexo g，然后在public目录下 git push;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure></p><h4 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h4><p>hexo d 并不会删除publc目录的.git文件夹，只会增量叠加。 –目前没有用过；<br>注意，不要执行hexo clean，它会删除public目录</p><h3 id="写的文章放在哪里与-posts目录"><a href="#写的文章放在哪里与-posts目录" class="headerlink" title="写的文章放在哪里与_posts目录"></a>写的文章放在哪里与_posts目录</h3><p>YeWills.github.io/source/_posts/<br>所有的文章都放置于_posts目录下。</p><h3 id="创建tag与categories相关事情"><a href="#创建tag与categories相关事情" class="headerlink" title="创建tag与categories相关事情"></a>创建tag与categories相关事情</h3><p>二者配置一样，以categories为例：<br>hexo new page categories<br>生成目录和文件：<br>YeWills.github.io/source/categories/index.md<br>修改index.md元数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">layout: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>同时修改<br>YeWills.github.io/scaffolds/draft.md<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">tags: &#123;&#123; tags &#125;&#125;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>YeWills.github.io/scaffolds/page.md<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>YeWills.github.io/scaffolds/post.md<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags: &#123;&#123; tags &#125;&#125;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>如此便可以配置出categories的all或全部 的选项卡内容，如果没有以上步骤，也可以生成categories，但无法生产categories的all或全部 的选项卡内容；<br>且点击本主题左侧菜单栏categories会报404错误。</p><p>这一步的配置内容，可看commit 哈希值 cbb06710ce7a40ade93</p><h3 id="categories、tags两种配置方式"><a href="#categories、tags两种配置方式" class="headerlink" title="categories、tags两种配置方式"></a>categories、tags两种配置方式</h3><p>categories:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 推荐使用方法 method one,双横杠方式，可以配置多级，</span><br><span class="line">categories: </span><br><span class="line">- react</span><br><span class="line">- react读书笔记</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// method two,只能配置一个值</span><br><span class="line">categories: &quot;react&quot;</span><br></pre></td></tr></table></figure><p>tags:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// method one</span><br><span class="line">tags:[react, react读书笔记]</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// method two,只能配置一个值</span><br><span class="line">tags: react</span><br></pre></td></tr></table></figure><h3 id="博客菜单栏左侧内容修改"><a href="#博客菜单栏左侧内容修改" class="headerlink" title="博客菜单栏左侧内容修改"></a>博客菜单栏左侧内容修改</h3><p>比如修改qq号码，名字，git地址，都可在这里修改YeWills.github.io/themes/mellow/_config.yml</p><h3 id="博客菜单栏左侧菜单增减"><a href="#博客菜单栏左侧菜单增减" class="headerlink" title="博客菜单栏左侧菜单增减"></a>博客菜单栏左侧菜单增减</h3><p>比如修改qq号码，名字，git地址，都可在这里修改YeWills.github.io/themes/mellow/_config.yml<br>修改改文件的menu部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home:</span><br><span class="line">    text: HOME</span><br><span class="line">    url: /</span><br><span class="line">    icon: home</span><br><span class="line">  th-list:</span><br><span class="line">    text: CATEGORIES</span><br><span class="line">    url: /categories</span><br><span class="line">    icon: th-list</span><br><span class="line">  tags:</span><br><span class="line">    text: TAGS</span><br><span class="line">    url: /tags</span><br><span class="line">    icon: tags</span><br><span class="line">  archives:</span><br><span class="line">    text: ARCHIVES</span><br><span class="line">    url: /archives</span><br><span class="line">    icon: archives</span><br></pre></td></tr></table></figure></p><p>如上，menu.th-list配置的是categories目录</p>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
