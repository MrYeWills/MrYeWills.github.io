<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    
    
    <title>算法 | Mr.Yellow.Wills</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="keywords" content="算法">
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.2/dist/jquery.fancybox.min.css">
    <link rel="stylesheet" href="/css/style.css?v=1.3.9">
    
    <script type="text/javascript">
        // Data Center
        var DC = {
            reward:	true,
            lv: JSON.parse('{"enable":false,"app_id":null,"app_key":null,"icon":true}'),
            v: JSON.parse('{"enable":false,"appid":null,"appkey":null,"notify":true,"verify":true,"placeholder":"give me some sugers plz...","avatar":"wavatar"}'),
            g: JSON.parse('{"enable":false,"lazy":true,"owner":"codefine","repo":"gitment","oauth":{"client_id":null,"client_secret":null},"perPage":10}'),
            d: JSON.parse('{"app_id":null}')
        };
    </script>
    <script type="text/javascript">
        window.lazyScripts=[];
    </script>
    
</head>


<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap">
      
      <img src="/img/brand.jpg" class="brand-bg">
      
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Mr.Yellow</h5>
          <a href="mailto:601661706@qq.com" title="601661706@qq.com" class="mail">
            
              <span>6</span>
            
              <span>0</span>
            
              <span>1</span>
            
              <span>6</span>
            
              <span>6</span>
            
              <span>1</span>
            
              <span>7</span>
            
              <span>0</span>
            
              <span>6</span>
            
              <span>@</span>
            
              <span>q</span>
            
              <span>q</span>
            
              <span>.</span>
            
              <span>c</span>
            
              <span>o</span>
            
              <span>m</span>
            
          </a>
        </hgroup>
        
        <ul class="menu-link">
          
              <li>
                <a href="https://github.com/YeWills/YeWills.github.io/tree/blog_code" target="_blank">
                  <i class="icon icon-lg icon-github"></i>
                </a>
              </li>
            
        </ul>
        
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="">
              <a href="/">
                <i class="icon icon-lg icon-home"></i>
                HOME
              </a>
            </li>
        
            <li class="">
              <a href="/categories">
                <i class="icon icon-lg icon-th-list"></i>
                CATEGORIES
              </a>
            </li>
        
            <li class="">
              <a href="/tags">
                <i class="icon icon-lg icon-tags"></i>
                TAGS
              </a>
            </li>
        
            <li class="">
              <a href="/archives">
                <i class="icon icon-lg icon-archives"></i>
                ARCHIVES
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row clearfix">
        <a href="javascript:;" class="header-icon pull-left waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">
            <span>算法</span>
            
        </div>
        
        <a href="javascript:;" id="site_search_btn" class="header-icon pull-right waves-effect waves-circle waves-light">
            <i class="icon icon-lg icon-search"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">
    <img src="/img/banner.jpg" class="header-bg">
    <div class="container fade-scale">
        <h1 class="title">算法</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-08-10T05:22:36.000Z" itemprop="datePublished" class="page-time">
  2019-08-10
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/前端/">前端</a></li></ul>

            
        </h5>
        
    </div>
    

</header>

<div id="site_search">
    <div class="search-title clearfix">
        <span class="pull-left">
          <i class="icon icon-lg icon-search"></i>
        </span>
        <input type="text" id="local-search-input" name="q" results="0" placeholder="search my blog..." class="form-control pull-left">
        <a href="javascript:;" class="close pull-right waves-effect waves-circle waves-light">
          <i class="icon icon-lg icon-close"></i>
        </a>
    </div>
    <div id="local-search-result"></div>
</div>


<div class="container body-wrap">
    <article id="post-calc" class="post-article article-type-post" itemprop="blogPost">
    <div class="post-card">
        <h1 class="post-card-title">算法</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-08-10 13:22:36" datetime="2019-08-10T05:22:36.000Z" itemprop="datePublished">2019-08-10</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/前端/">前端</a></li></ul>



            

            


            
        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            
            <p><strong>基础算法篇</strong></p>
<h2 id="电话号码"><a href="#电话号码" class="headerlink" title="电话号码"></a>电话号码</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">力扣原题 – 电话号码的字母组合</a><br>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。<br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function calc(str) &#123;</span><br><span class="line">     let map = [&apos;&apos;, 1, &apos;abc&apos;, &apos;def&apos;, &apos;ghi&apos;, &apos;jkl&apos;, &apos;mno&apos;, &apos;pqrs&apos;, &apos;tuv&apos;, &apos;wxyz&apos;]</span><br><span class="line">     let num = str.split(&apos;&apos;)</span><br><span class="line">     let code = []</span><br><span class="line">     num.forEach(item =&gt; &#123;</span><br><span class="line">       if (map[item]) &#123;</span><br><span class="line">         code.push(map[item])</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">     let comb = (arr) =&gt; &#123;</span><br><span class="line">       // 临时变量用来保存前两个组合的结果</span><br><span class="line">       let tmp = []</span><br><span class="line">       // 最外层的循环是遍历第一个元素，里层的循环是遍历第二个元素</span><br><span class="line">       for (let i = 0; i &lt; arr[0].length; i++) &#123;</span><br><span class="line">         for (let j = 0; j &lt; arr[1].length; j++) &#123;</span><br><span class="line">           tmp.push(`$&#123;arr[0][i]&#125;$&#123;arr[1][j]&#125;`)</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       arr.splice(0, 2, tmp)</span><br><span class="line">       if (arr.length &gt; 1) &#123;</span><br><span class="line">         comb(arr)</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         return tmp</span><br><span class="line">       &#125;</span><br><span class="line">       return arr[0]</span><br><span class="line">     &#125;</span><br><span class="line">     return comb(code)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   //calc(&apos;32&apos;)</span><br></pre></td></tr></table></figure></p>
<p>现在对上面方法进行思路和要点解析</p>
<h3 id="两两组合"><a href="#两两组合" class="headerlink" title="两两组合"></a>两两组合</h3><p>不管输入多少位数，都让前两位数字进行组合，组合的结果 再跟 第三位数字进行组合，逻辑一样，依次类推。 逻辑一样的部分，则突出了使用递归的需求。<br><figure class="image-box">
                <a rel="算法" href="/image/calc/phone.jpg" title="undefined" data-fancybox="images"><img src="/image/calc/phone.jpg" alt="" title="" class=""></a>
                <p></p>
            </figure></p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>参考上面《两两组合》</p>
<h3 id="return-arr-0-很需要"><a href="#return-arr-0-很需要" class="headerlink" title="return arr[0] 很需要"></a>return arr[0] 很需要</h3><p>咋一看，觉得这一句不需要，以为有 if else，就不会走到 return arr[0]。这也是我误解的，其实下面的comb(arr)递归，执行完后，就会执行后面的return arr[0]。<br>以上也是我对于递归的误区。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (arr.length &gt; 1) &#123;</span><br><span class="line">       comb(arr)</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       return tmp</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">return arr[0]</span><br></pre></td></tr></table></figure></p>
<h3 id="递归完了还会往下执行"><a href="#递归完了还会往下执行" class="headerlink" title="递归完了还会往下执行"></a>递归完了还会往下执行</h3><p>参考上面 《return arr[0] 很需要》</p>
<h2 id="卡牌分组"><a href="#卡牌分组" class="headerlink" title="卡牌分组"></a>卡牌分组</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>给定一副牌，每张牌上都写着一个整数。<br>此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：<br>每组都有 X 张牌。<br>组内所有的牌上都写着相同的整数。<br>仅当你可选的 X &gt;= 2 时返回 true。<br><a href="https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards" target="_blank" rel="noopener">力扣原题 – 卡牌分组</a></p>
<p>用白话解释原题：给定一副牌，这副牌可以是1张或1万张，将这副牌分成一组或多组，每组牌的数字都相同，每组牌的个数不少于2.</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function calc(arr) &#123;</span><br><span class="line">      // 将卡牌按值排序保证相同的卡牌是挨着的</span><br><span class="line">      let str = arr.sort((a, b) =&gt; a - b).join(&apos;&apos;)</span><br><span class="line">      // 分组(单张或者多张)  \1 在正则中表示连续一样的匹配</span><br><span class="line">      let group = str.match(/(\d)\1+|\d/g)</span><br><span class="line">      // 求两个数的最大公约数</span><br><span class="line">      let gcd = (a, b) =&gt; &#123;    </span><br><span class="line">        if(b === 0)  return a;   </span><br><span class="line">        return gcd(b, a % b)</span><br><span class="line">       &#125;</span><br><span class="line">      // 思想：只要所有的分组具有最大公约数(大于1)就满足条件</span><br><span class="line">      // 对所有的分组进行最大公约数验证，相邻两个分组的最大公约数，再与后面的公约数进行验证，以此类推，有一个最大公约数为1就退出</span><br><span class="line">      while (group.length &gt; 1) &#123;</span><br><span class="line">        let a = group.shift().length</span><br><span class="line">        let b = group.shift().length</span><br><span class="line">        let v = gcd(a, b)</span><br><span class="line">        if (v === 1) &#123;</span><br><span class="line">          return false</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          // 将前两个分组的最大公约数推进数组与下一个分组再次验证是否有最大公约数</span><br><span class="line">          group.unshift(&apos;0&apos;.repeat(v))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // 考虑边界[&apos;11&apos;]即只有一个分组的时候</span><br><span class="line">      return group.length ? group[0].length &gt; 1 : false</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法要点"><a href="#方法要点" class="headerlink" title="方法要点"></a>方法要点</h3><p>结合上面的《解决方法》代码来说</p>
<h4 id="用递归写最大公约数"><a href="#用递归写最大公约数" class="headerlink" title="用递归写最大公约数"></a>用递归写最大公约数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let gcd = (a, b) =&gt; &#123;    </span><br><span class="line">    if(b === 0)  return a;   </span><br><span class="line">    return gcd(b, a % b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h4><p>参考上面</p>
<h4 id="最大公约数除了1值外，其他值都合法"><a href="#最大公约数除了1值外，其他值都合法" class="headerlink" title="最大公约数除了1值外，其他值都合法"></a>最大公约数除了1值外，其他值都合法</h4><h4 id="shift-方式的-数组内两两比较"><a href="#shift-方式的-数组内两两比较" class="headerlink" title="shift()方式的 数组内两两比较"></a>shift()方式的 数组内两两比较</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while (group.length &gt; 1) &#123;</span><br><span class="line">        let a = group.shift().length</span><br><span class="line">        let b = group.shift().length</span><br><span class="line">      ...</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h3 id="不推荐方法"><a href="#不推荐方法" class="headerlink" title="不推荐方法"></a>不推荐方法</h3><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var hasGroupsSizeX = function(deck) &#123;</span><br><span class="line">  let getResult = (a, b) =&gt; &#123;    //定义一个寻找公约数的方法</span><br><span class="line">    if(b === 0)  return a;   </span><br><span class="line">    return getResult(b, a % b)</span><br><span class="line">  &#125;</span><br><span class="line">  const hash = deck.reduce((pre, num) =&gt; &#123;    //统计出每种数字的数目</span><br><span class="line">    if(!pre[num]) &#123;</span><br><span class="line">      pre[num] = 1</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      pre[num]++</span><br><span class="line">    &#125;</span><br><span class="line">    return pre</span><br><span class="line">  &#125;, &#123;&#125;)</span><br><span class="line">  const numCount = Object.values(hash)     //将hash中的每项数值存入数组，便于后续遍历</span><br><span class="line">  const min = numCount.sort((a, b) =&gt; a-b)[0];         //利用数组排序快速获取最小值</span><br><span class="line">  if (min &lt; 2) return false; //根据题意，如果最分组最小数量小于2，直接返回false</span><br><span class="line">  return !numCount.some((item,index) =&gt; &#123;</span><br><span class="line">    if(index &gt; 0) return getResult(item, min) === 1</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="两种方法的利弊"><a href="#两种方法的利弊" class="headerlink" title="两种方法的利弊"></a>两种方法的利弊</h4><p>尽管两种方法都能实现，但是前面说的方法要比不推荐方法节省了一次遍历，当数据量大时，这种性能上的差别就会比较大，所以推荐前一种方法。</p>
<h2 id="种花问题"><a href="#种花问题" class="headerlink" title="种花问题"></a>种花问题</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。<br>给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花，算出n的最大值。<br><a href="https://leetcode-cn.com/problems/can-place-flowers" target="_blank" rel="noopener">力扣原题 – 种花问题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function calc(arr, n)&#123;</span><br><span class="line">     // 计数器</span><br><span class="line">     let max = 0</span><br><span class="line">     for (let i = 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">       if (arr[i] === 0) &#123;</span><br><span class="line">         if (i === 0 &amp;&amp; arr[1] === 0) &#123;</span><br><span class="line">           max++</span><br><span class="line">           //跳转，这里i++，加上for循环自动也++，所以i实际加了2</span><br><span class="line">           i++</span><br><span class="line">         &#125; else if (arr[i - 1] === 0 &amp;&amp; arr[i + 1] === 0) &#123;</span><br><span class="line">           max++</span><br><span class="line">            //跳转，这里i++，加上for循环自动也++，所以i实际加了2</span><br><span class="line">           i++</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return max</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="要点分析"><a href="#要点分析" class="headerlink" title="要点分析"></a>要点分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,0,0,0,0,0,0,0,1]</span><br></pre></td></tr></table></figure>
<p>其实就是在数组中找000的模型，有000就可以变成010，达到要求。<br>另外一个要考虑的是边界问题，比如，[0,0,1]，这不符合 000，但依然可以在最左侧加1；<br>这种问题其实就是在数组中找 000 这种模型，就涉及到用数学建模的思想来解决。</p>
<h3 id="数学建模"><a href="#数学建模" class="headerlink" title="数学建模"></a>数学建模</h3><p>以后遇到类似的找这种000的形式的东西，就考虑用数学建模。</p>
<h3 id="如何跳级忽略某些元素遍历"><a href="#如何跳级忽略某些元素遍历" class="headerlink" title="如何跳级忽略某些元素遍历"></a>如何跳级忽略某些元素遍历</h3><p>例如下面的，index位置 1 2 3 符合 000；<br>2 3 4 也符合 000；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,0,0,0,0,1]</span><br></pre></td></tr></table></figure></p>
<p>但实际上当遍历了index 123后，下一次只要求遍历index 345；<br>如何做到呢，可通过在for循环内，i++ :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 0, len = arr.length - 1; i &lt; len; i++) &#123;</span><br><span class="line">   //跳转，这里i++，加上for循环自动也++，所以i实际加了2</span><br><span class="line">   i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="边界问题"><a href="#边界问题" class="headerlink" title="边界问题"></a>边界问题</h3><p>参考《要点分析》</p>
<h3 id="arr-i-1-与-arr-i-1-与-i-lt-arr-length-1-的妙用"><a href="#arr-i-1-与-arr-i-1-与-i-lt-arr-length-1-的妙用" class="headerlink" title="arr[i-1] 与 arr[i+1] 与 i&lt;arr.length-1 的妙用"></a>arr[i-1] 与 arr[i+1] 与 i&lt;arr.length-1 的妙用</h3><p>因为for循环体内用了arr[i+1]，那么在for的title上能遍历的最大值是 arr.length - 2，也就是i &lt; arr.length - 1；<br>这个是一个很实用的用法，我们在写for循环时，如果for循环体内有这样的情况，就应该考虑好for的title上最大的i &lt; arr.length值也应响应配合增加或减少。并且这个最大的arr.length值到底多少<strong>与函数体内最大的arr[i+1]有关，而与arr[i-1]无关。</strong>，当然，如果用到arr[i-1]时，<strong>就要考虑边界值的问题</strong>，也就是当i为0时的情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">       ...</span><br><span class="line">         &#125; else if (arr[i - 1] === 0 &amp;&amp; arr[i + 1] === 0) &#123;</span><br><span class="line">       ...</span><br><span class="line">       </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="arr-i-1-时考虑边界值，arr-i-1-时考虑i值最大值"><a href="#arr-i-1-时考虑边界值，arr-i-1-时考虑i值最大值" class="headerlink" title="arr[i-1]时考虑边界值，arr[i-1]时考虑i值最大值"></a>arr[i-1]时考虑边界值，arr[i-1]时考虑i值最大值</h3><p>参考《arr[i-1] 与 arr[i+1] 与 i&lt;arr.length-1 的妙用》</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>冒泡排序大白话解释就是，将数组内的最大值，从左到右或右带左地排序，这个过程好像数组内的最大值好像冒泡一样，从水底上浮的过程。<br>冒泡排序是每次比较左右两个值，每次进行比较交换位置。<br>如下图，要实现如下的一个渐进的排序过程：<br><figure class="image-box">
                <a rel="算法" href="/image/calc/bubble.jpg" title="undefined" data-fancybox="images"><img src="/image/calc/bubble.jpg" alt="" title="" class=""></a>
                <p></p>
            </figure><br><figure class="image-box">
                <a rel="算法" href="/image/calc/bubble1.jpg" title="undefined" data-fancybox="images"><img src="/image/calc/bubble1.jpg" alt="" title="" class=""></a>
                <p></p>
            </figure><br><figure class="image-box">
                <a rel="算法" href="/image/calc/bubble2.jpg" title="undefined" data-fancybox="images"><img src="/image/calc/bubble2.jpg" alt="" title="" class=""></a>
                <p></p>
            </figure></p>
<p>解题代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function calc(arr) &#123;</span><br><span class="line">    // 冒泡排序</span><br><span class="line">    for (let i = arr.length - 1; i &gt; 0; i--) &#123;</span><br><span class="line">        for (let j = 0; j &lt; i; j++) &#123;</span><br><span class="line">            if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">            let c = arr[j];</span><br><span class="line">            arr[j] = arr[j + 1]</span><br><span class="line">            arr[j + 1] = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">calc([1, 9, 5, 3, 4,0,2,999,6]) //[0, 1, 2, 3, 4, 5, 6, 9, 999]</span><br></pre></td></tr></table></figure></p>
<h3 id="要点分析-1"><a href="#要点分析-1" class="headerlink" title="要点分析"></a>要点分析</h3><p>这种排序是典型的需要n*n次的排序，需要在循环体内嵌套再次循环。<br>排序的关键是，需要一个遍历，逐步将数组的遍历范围逐步减少，为第二个遍历提供最大length；<br>第二个遍历针对第一个遍历提供的length进行全遍历，将最大值找出并一步步推到数组最右侧；</p>
<h3 id="双层遍历"><a href="#双层遍历" class="headerlink" title="双层遍历"></a>双层遍历</h3><p>冒泡排序关键点是用了双层排序。</p>
<h4 id="外层遍历限定内层遍历范围；"><a href="#外层遍历限定内层遍历范围；" class="headerlink" title="外层遍历限定内层遍历范围；"></a>外层遍历限定内层遍历范围；</h4><p>这里的范围是指，内层遍历，最大遍历次数i值；</p>
<h4 id="外层遍历逐步递减；"><a href="#外层遍历逐步递减；" class="headerlink" title="外层遍历逐步递减；"></a>外层遍历逐步递减；</h4><h4 id="内层遍历全遍历；"><a href="#内层遍历全遍历；" class="headerlink" title="内层遍历全遍历；"></a>内层遍历全遍历；</h4><h4 id="内层遍历负责位置替换，将最大值冒泡至最右侧；"><a href="#内层遍历负责位置替换，将最大值冒泡至最右侧；" class="headerlink" title="内层遍历负责位置替换，将最大值冒泡至最右侧；"></a>内层遍历负责位置替换，将最大值冒泡至最右侧；</h4><h3 id="边界值处理"><a href="#边界值处理" class="headerlink" title="边界值处理"></a>边界值处理</h3><p>外层遍历 <code>let i = arr.length - 1; i &gt; 0; i--</code>;其中i&gt;0,i的最小值不是1而是0；<br>但是arr[0]又必须遍历，其实已经在内层遍历中被遍历了。</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>选择排序<br>是一次次遍历，将最小值遍历到最左侧的过程，选择排序与冒泡排序实现的效果是一样的，思路不一样。<br>选择排序每次遍历以起始值arr[i]为参照，然后遍历 arr[i+1]到arr[arr.length-1]的范围，发现有值不一样，a[i]与最小值进行值的交换。<br>所以，选择排序是，一次遍历交换一次位置，冒泡排序是一次比较就交换一次位置，而一次遍历包含很多次比较。<br>所以选择排序类似定点比较交换，冒泡排序是左右比较交换，这就是二者区别。</p>
<p>如下图，要实现如下的一个渐进的排序过程：<br><figure class="image-box">
                <a rel="算法" href="/image/calc/select.jpg" title="undefined" data-fancybox="images"><img src="/image/calc/select.jpg" alt="" title="" class=""></a>
                <p></p>
            </figure><br><figure class="image-box">
                <a rel="算法" href="/image/calc/select1.jpg" title="undefined" data-fancybox="images"><img src="/image/calc/select1.jpg" alt="" title="" class=""></a>
                <p></p>
            </figure><br>解题代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function calc(arr) &#123;</span><br><span class="line">      // 选择排序</span><br><span class="line">      for (let i = 0, len = arr.length, min; i &lt; len; i++) &#123;</span><br><span class="line">        for (let j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">          if (arr[j] &lt; arr[i]) &#123;</span><br><span class="line">            let c = arr[i]</span><br><span class="line">            arr[i] = arr[j]</span><br><span class="line">            arr[j] = c</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return arr</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="要点解析"><a href="#要点解析" class="headerlink" title="要点解析"></a>要点解析</h3><p>选择排序与冒泡排序是两种相反的比较方法，冒泡排序是 i–，选择排序是 i++；<br>内层遍历范围也是相反的方向，选择排序内层遍历范围是从左到右不断收缩的过程，冒泡排序是右到左不断收缩。<br>其基本原理与冒泡排序相同；<br>详细参考《冒泡排序》</p>
<h3 id="选择排序与冒泡排序区别"><a href="#选择排序与冒泡排序区别" class="headerlink" title="选择排序与冒泡排序区别"></a>选择排序与冒泡排序区别</h3><p>前者是定点比较交换，后者是左右比较交换：<br><figure class="image-box">
                <a rel="算法" href="/image/calc/select-dubble.jpeg" title="undefined" data-fancybox="images"><img src="/image/calc/select-dubble.jpeg" alt="" title="" class=""></a>
                <p></p>
            </figure></p>
<h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><p>因为定点比较的原因，如果要定点比较的元素为 arr[i],那么内层遍历就从i+1开始遍历，这点也是值得注意和借鉴的地方。</p>
<h3 id="代码优化写法-推荐"><a href="#代码优化写法-推荐" class="headerlink" title="代码优化写法(推荐)"></a>代码优化写法(推荐)</h3><p>下面是针对上面写法的优化，因为<code>arr[i]</code>，只需要在内层函数变量完一遍后，才需要赋值，在内层函数遍历完之前，<code>arr[i]</code>值都是不稳定的，没必要频繁赋值.<br>因此引入了临时变量temp，这样的好处是，不用频繁地进行<code>arr[i] = arr[j]</code>赋值，减少操作arr数组，对性能也是有好处的，虽然可能只有微乎其微的性能，同时代码逻辑性更强且易读。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function calc(arr) &#123;</span><br><span class="line">      // 选择排序</span><br><span class="line">      for (let i = 0, len = arr.length, min; i &lt; len; i++) &#123;</span><br><span class="line">        引入临时变量</span><br><span class="line">          let temp = arr[i];</span><br><span class="line">        for (let j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">          if (arr[j] &lt; temp) &#123;</span><br><span class="line">            let c = temp</span><br><span class="line">            temp = arr[j]</span><br><span class="line">            arr[j] = c</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i]=temp;</span><br><span class="line">      &#125;</span><br><span class="line">      return arr</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="最大间距"><a href="#最大间距" class="headerlink" title="最大间距"></a>最大间距</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p><a href="https://leetcode-cn.com/problems/maximum-gap/" target="_blank" rel="noopener">力扣原题 – 最大间距</a><br>给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。<br>如果数组元素个数小于 2，则返回 0。</p>
<h3 id="推荐方法"><a href="#推荐方法" class="headerlink" title="推荐方法"></a>推荐方法</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>这种题一般通过排序完成，并且在排序的过程中，获取最大值，以下通过 冒泡排序的方式来做，主要利用冒泡的时候，其他已经逐步排序好最大值了，利用这逐步排序好的最大值，逐步求出间距：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function getDistance(a, b, max) &#123;</span><br><span class="line">     const num = a - b;</span><br><span class="line">     if (max &lt; num) &#123;</span><br><span class="line">       max = Math.abs(num);</span><br><span class="line">     &#125;</span><br><span class="line">     return max;</span><br><span class="line">   &#125;</span><br><span class="line">   function calc(arr) &#123;</span><br><span class="line">     let max=0;</span><br><span class="line">     for (let i = arr.length - 1, tmp; i &gt; 0; i--) &#123;</span><br><span class="line">       for (let j = 0; j &lt; i; j++) &#123;</span><br><span class="line">         if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">           let c = arr[j];</span><br><span class="line">           arr[j] = arr[j + 1];</span><br><span class="line">           arr[j + 1] = c;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if (i &lt; (arr.length - 1)) &#123;</span><br><span class="line">         max = getDistance(arr[i + 1], arr[i], max);</span><br><span class="line">         if (i === 1) &#123;</span><br><span class="line">           max = getDistance(arr[1], arr[0], max);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return max;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h4><p>当i === (arr.length - 2)与i=1时需要处理不同逻辑。</p>
<h3 id="不推荐方法-1"><a href="#不推荐方法-1" class="headerlink" title="不推荐方法"></a>不推荐方法</h3><p>不推荐理由，利用sort进行了一次遍历，然后又用遍历求最大间距，用了两次遍历，相比上面的推荐方法的一次遍历，这种方法性能不好。<br><figure class="image-box">
                <a rel="算法" href="/image/calc/max.jpg" title="undefined" data-fancybox="images"><img src="/image/calc/max.jpg" alt="" title="" class=""></a>
                <p></p>
            </figure></p>
<h2 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a>数组中的第K个最大元素</h2><p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">力扣原题 – 数组中的第K个最大元素</a><br>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br>示例 1:<br>输入: [3,2,1,5,6,4] 和 k = 2<br>输出: 5<br>示例 2:</p>
<p>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4<br>输出: 4<br>说明:</p>
<p>先说不推荐方法</p>
<h3 id="不推荐方法-2"><a href="#不推荐方法-2" class="headerlink" title="不推荐方法"></a>不推荐方法</h3><p>这种方法非常容易理解，但是却有浪费之嫌，因为根本不需要对整个数组先排序再查找，因为一旦找到第k个值，就可以停止程序了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export default (arr, k) =&gt; &#123;</span><br><span class="line">  return arr.sort((a, b) =&gt; b - a)[k - 1]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="推荐方法-1"><a href="#推荐方法-1" class="headerlink" title="推荐方法"></a>推荐方法</h3><p>利用冒泡排序来做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">export default (arr, k) =&gt; &#123;</span><br><span class="line">  let len = arr.length - 1</span><br><span class="line">  for (let i = len, tmp; i &gt; len - k; i--) &#123;</span><br><span class="line">    for (let j = 0; j &lt; i; j++) &#123;</span><br><span class="line">      if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">        tmp = arr[j]</span><br><span class="line">        arr[j] = arr[j + 1]</span><br><span class="line">        arr[j + 1] = tmp</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // arr[len+1-k]</span><br><span class="line">  return arr[len - (k - 1)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="对以上排序-题-算法-的小结"><a href="#对以上排序-题-算法-的小结" class="headerlink" title="对以上排序(题\算法)的小结"></a>对以上排序(题\算法)的小结</h2><p>以上的排序题中，如<code>数组中的第K个最大元素</code>，示例中都使用了冒泡排序的算法来做的，其他也可以使用选择排序，二者都是想通互换的。</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="要点分析-2"><a href="#要点分析-2" class="headerlink" title="要点分析"></a>要点分析</h3><p>快速排序，以数组中间一个元素为基准，小于的放在左边，大于的放在右边，然后递归，排序完成。<br><figure class="image-box">
                <a rel="算法" href="/image/calc/quick0.jpg" title="undefined" data-fancybox="images"><img src="/image/calc/quick0.jpg" alt="" title="" class=""></a>
                <p></p>
            </figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function calc(ary)&#123;</span><br><span class="line">       console.log(ary)</span><br><span class="line">       if(ary.length&lt;=1)&#123;</span><br><span class="line">           return ary;</span><br><span class="line">       &#125;</span><br><span class="line">       var pointIndex = Math.floor(ary.length/2);</span><br><span class="line">       //从ary中删除pointIndex，并且通过[0]取出pointValue值</span><br><span class="line">       var pointValue = ary.splice(pointIndex, 1)[0];</span><br><span class="line">       var left = [];</span><br><span class="line">       var right = [];</span><br><span class="line">       for (var i=0; i&lt;ary.length; i++)&#123;</span><br><span class="line">           var cur = ary[i];</span><br><span class="line">           cur &lt; pointValue ? left.push(cur) : right.push(cur);</span><br><span class="line">       &#125;</span><br><span class="line">       return quickSort(left).concat([pointValue],quickSort(right));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="中间值，左右两边分组"><a href="#中间值，左右两边分组" class="headerlink" title="中间值，左右两边分组"></a>中间值，左右两边分组</h3><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3>
        </div>
        
<blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2019-08-15T16:38:47.000Z" itemprop="dateUpdated">2019-08-16 00:38:47</time>
</span><br>


        
        博客内容均为原创，转载注明出处，原文地址：<a href="/2019/08/10/calc/" target="_blank" rel="external">https://yewills.github.io/2019/08/10/calc/</a>
        
    </div>
    <footer>
        <a href="https://yewills.github.io">
            <img src="/img/avatar.jpg" alt="Mr.Yellow">
            Mr.Yellow
        </a>
    </footer>
</blockquote>

        
            <div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>

            
        
        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

            <div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://yewills.github.io/2019/08/10/calc/&title=《算法》 — Mr.Yellow.Wills&pic=https://yewills.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://yewills.github.io/2019/08/10/calc/&title=《算法》 — Mr.Yellow.Wills&source=hellow kity" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>

        </div>
        
            


        
    </div>
    
<nav class="post-nav flex-row flex-justify-between flex-row-reverse">
  

  
    <div class="next">
      <a href="/2019/08/08/aaa/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">No title</h4>
      </a>
    </div>
  
</nav>


    
    
        <aside class="post-widget">
            <nav class="post-toc-wrap" id="post-toc">
                <strong>目录</strong>
                <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#电话号码"><span class="post-toc-number">1.</span> <span class="post-toc-text">电话号码</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#概述"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">概述</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#两两组合"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">两两组合</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#递归"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">递归</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#return-arr-0-很需要"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">return arr[0] 很需要</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#递归完了还会往下执行"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">递归完了还会往下执行</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#卡牌分组"><span class="post-toc-number">2.</span> <span class="post-toc-text">卡牌分组</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#概述-1"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">概述</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#解决方法"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">解决方法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#代码"><span class="post-toc-number">2.2.1.</span> <span class="post-toc-text">代码</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#方法要点"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">方法要点</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#用递归写最大公约数"><span class="post-toc-number">2.3.1.</span> <span class="post-toc-text">用递归写最大公约数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#最大公约数"><span class="post-toc-number">2.3.2.</span> <span class="post-toc-text">最大公约数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#最大公约数除了1值外，其他值都合法"><span class="post-toc-number">2.3.3.</span> <span class="post-toc-text">最大公约数除了1值外，其他值都合法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#shift-方式的-数组内两两比较"><span class="post-toc-number">2.3.4.</span> <span class="post-toc-text">shift()方式的 数组内两两比较</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#不推荐方法"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">不推荐方法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#代码-1"><span class="post-toc-number">2.4.1.</span> <span class="post-toc-text">代码</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#两种方法的利弊"><span class="post-toc-number">2.4.2.</span> <span class="post-toc-text">两种方法的利弊</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#种花问题"><span class="post-toc-number">3.</span> <span class="post-toc-text">种花问题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#概述-2"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">概述</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#要点分析"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">要点分析</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数学建模"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">数学建模</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何跳级忽略某些元素遍历"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">如何跳级忽略某些元素遍历</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#边界问题"><span class="post-toc-number">3.5.</span> <span class="post-toc-text">边界问题</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#arr-i-1-与-arr-i-1-与-i-lt-arr-length-1-的妙用"><span class="post-toc-number">3.6.</span> <span class="post-toc-text">arr[i-1] 与 arr[i+1] 与 i&lt;arr.length-1 的妙用</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#arr-i-1-时考虑边界值，arr-i-1-时考虑i值最大值"><span class="post-toc-number">3.7.</span> <span class="post-toc-text">arr[i-1]时考虑边界值，arr[i-1]时考虑i值最大值</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#冒泡排序"><span class="post-toc-number">4.</span> <span class="post-toc-text">冒泡排序</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#概述-3"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">概述</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#要点分析-1"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">要点分析</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#双层遍历"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">双层遍历</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#外层遍历限定内层遍历范围；"><span class="post-toc-number">4.3.1.</span> <span class="post-toc-text">外层遍历限定内层遍历范围；</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#外层遍历逐步递减；"><span class="post-toc-number">4.3.2.</span> <span class="post-toc-text">外层遍历逐步递减；</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#内层遍历全遍历；"><span class="post-toc-number">4.3.3.</span> <span class="post-toc-text">内层遍历全遍历；</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#内层遍历负责位置替换，将最大值冒泡至最右侧；"><span class="post-toc-number">4.3.4.</span> <span class="post-toc-text">内层遍历负责位置替换，将最大值冒泡至最右侧；</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#边界值处理"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">边界值处理</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#选择排序"><span class="post-toc-number">5.</span> <span class="post-toc-text">选择排序</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#概述-4"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">概述</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#要点解析"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">要点解析</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#选择排序与冒泡排序区别"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">选择排序与冒泡排序区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#小技巧"><span class="post-toc-number">5.4.</span> <span class="post-toc-text">小技巧</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#代码优化写法-推荐"><span class="post-toc-number">5.5.</span> <span class="post-toc-text">代码优化写法(推荐)</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#最大间距"><span class="post-toc-number">6.</span> <span class="post-toc-text">最大间距</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#概述-5"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">概述</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#推荐方法"><span class="post-toc-number">6.2.</span> <span class="post-toc-text">推荐方法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#介绍"><span class="post-toc-number">6.2.1.</span> <span class="post-toc-text">介绍</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#边界处理"><span class="post-toc-number">6.2.2.</span> <span class="post-toc-text">边界处理</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#不推荐方法-1"><span class="post-toc-number">6.3.</span> <span class="post-toc-text">不推荐方法</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#数组中的第K个最大元素"><span class="post-toc-number">7.</span> <span class="post-toc-text">数组中的第K个最大元素</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#不推荐方法-2"><span class="post-toc-number">7.1.</span> <span class="post-toc-text">不推荐方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#推荐方法-1"><span class="post-toc-number">7.2.</span> <span class="post-toc-text">推荐方法</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#对以上排序-题-算法-的小结"><span class="post-toc-number">8.</span> <span class="post-toc-text">对以上排序(题\算法)的小结</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#快速排序"><span class="post-toc-number">9.</span> <span class="post-toc-text">快速排序</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#要点分析-2"><span class="post-toc-number">9.1.</span> <span class="post-toc-text">要点分析</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#中间值，左右两边分组"><span class="post-toc-number">9.2.</span> <span class="post-toc-text">中间值，左右两边分组</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#递归-1"><span class="post-toc-number">9.3.</span> <span class="post-toc-text">递归</span></a></li></ol></li></ol>
            </nav>
            <div class="toc-bar"><div>
        </div></div></aside>
    
</article>

    <div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        我们一起来让这个世界有趣一点
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/reward-wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check" data-wechat="/img/reward-wechat.jpg" data-alipay="/img/reward-alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>

    

</div>

        <footer class="footer">
    
    <div class="top">
        
            <p>
    <span>Links：</span>
    
    <span class="blogroll-item">
        <a href="https://www.lujingtao.com" target="_blank">HOME</a>
    </span>
    
</p>

        
    </div>
    
    <div class="bottom">
        <p>
            <span>
                Mr.Yellow &copy; 2017 - 2019
            </span>
        		
           	
            
            
            <span>
	            Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/codefine/hexo-theme-mellow" target="_blank">mellow</a>
            </span>
            
            
            

            
                
<span class="site-uv" title="总访客量">
    <i class="icon icon-user"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_uv"></i>
</span>


<span class="site-pv" title="总访问量">
    <i class="icon icon-eye"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_pv"></i>
</span>

            
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://yewills.github.io/2019/08/10/calc/&title=《算法》 — Mr.Yellow.Wills&pic=https://yewills.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://yewills.github.io/2019/08/10/calc/&title=《算法》 — Mr.Yellow.Wills&source=hellow kity" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAACuCAAAAACKZ2kyAAABy0lEQVR42u3aO3LDMAwFwNz/0spM2iQUHkDKKpaVJ5HptQsMfl9f5XP9nPoz6evNBxcXd8y9lue/Z9Yf+fvJyj1rAy4u7vPcemCahKf0Xbi4uO/nrsNT/c40IOLi4r6fmxZL81QJFxf3U9xK8ZOWMXXikVoNFxd3wJ0Hplf3d3FxcUPuNTjr9ug8eP1xAy4u7iPcefsjHZD00qNt3RpcXNwCtx5u0gwkHcZUfixcXNxnuPO6I31Xitu8vIWLi9sapdTXLHof2SuoboofXFzcY9xeWEnHMOmXDyY/uLi4W7m91GQyaNlc/ODi4h5oi/QKlV546s1McXFxP8tNX6eFzegGXFzcR7iTxal0kSJd1wgSHVxc3K3c+kX1oLYOVemYNujK4OLibuLWob2AlTZE4l8aFxf3ALfSEu01QCdf7KZWw8XFPcxNg8tkhaK3AFpaz8LFxd3KvcKTJkb1/5bSI1xc3Ee49ZM2PeeLGvHOCC4u7lZufThaH6701i9wcXHfxq2PUXstkknovBm14uLivoA7Wb2qBLKbqIWLi/sybprK9Iap8c4ILi7uMW69+Jn/vZ7W3Cxh4OLiHuPOG6YTbiWR2tzfxcXFXd35DQPyi7IWR8fvAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>


    
    <!-- main-js -->
<script type="text/javascript" src="//cdn.bootcss.com/jquery/2.1.0/jquery.min.js"></script>
<script type="text/javascript" src="/js/plugins/fastclick.js?v=1.3.9"></script>
<script type="text/javascript" src="/js/plugins/ios-orientationchange-fix.js?v=1.3.9"></script>
<script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.2/dist/jquery.fancybox.min.js"></script>

<script type="text/javascript" src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>

<script type="text/javascript" src="/js/method.js?v=1.3.9"></script>
<script type="text/javascript" src="/js/blog.js?v=1.3.9"></script>

<!-- third-party -->






<script type="text/javascript" src="/js/plugins/local_search.js?v=1.3.9"></script>
<script type="text/javascript">
	var search_path = "search.xml";
	if (search_path.length === 0) {
		search_path = "search.xml";
	}
	var path = "/" + search_path;
	searchFunc(path, "local-search-input", "local-search-result");
</script>



<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



    
    





    <!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
            processEscapes: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>







    
</body>
</html>
